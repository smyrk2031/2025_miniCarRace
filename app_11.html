<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>MiniCar SLAM - é«˜åº¦æ“ä½œç‰ˆ</title>
<style>
* { box-sizing: border-box; }
body { 
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
  margin: 0; 
  padding: 0; 
  background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
  color: #fff;
  overflow-x: hidden;
}

.container {
  display: flex;
  height: 100vh;
}

.sidebar {
  width: 500px;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(10px);
  padding: 20px;
  overflow-y: auto;
  border-right: 2px solid rgba(255,255,255,0.1);
}

.main-content {
  flex: 1;
  padding: 20px;
  display: flex;
  flex-direction: column;
}

.table-sidebar {
  width: 400px;
  min-width: 200px;
  max-width: 800px;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(10px);
  border-left: 2px solid rgba(255,255,255,0.1);
  display: flex;
  flex-direction: column;
  position: relative;
  transition: width 0.3s ease;
}

.table-sidebar.closed {
  width: 0 !important;
  min-width: 0;
  padding: 0;
  border: none;
  overflow: hidden;
}

.table-header {
  padding: 15px;
  background: rgba(255,255,255,0.1);
  border-bottom: 2px solid rgba(255,255,255,0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.table-header h3 {
  margin: 0;
  color: #4ecdc4;
  font-size: 1.1em;
}

.table-close-btn {
  background: rgba(255,100,100,0.6);
  border: none;
  border-radius: 5px;
  color: white;
  font-size: 16px;
  width: 30px;
  height: 30px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.table-close-btn:hover {
  background: rgba(255,100,100,0.9);
}

.table-toggle-btn {
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 30px;
  height: 60px;
  background: rgba(78,205,196,0.8);
  border: none;
  border-radius: 5px 0 0 5px;
  color: white;
  font-size: 18px;
  cursor: pointer;
  display: none;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  z-index: 1000;
  pointer-events: auto;
}

.table-toggle-btn:hover {
  background: rgba(78,205,196,1);
  width: 32px;
}

body.table-closed .table-toggle-btn {
  display: flex;
}

.table-resize-handle {
  position: absolute;
  left: 0;
  top: 0;
  width: 5px;
  height: 100%;
  cursor: ew-resize;
  background: transparent;
  transition: background 0.3s ease;
}

.table-resize-handle:hover {
  background: rgba(78,205,196,0.5);
}

/* ãƒãƒ¼ã‚«ãƒ¼ãƒ‘ãƒãƒ«ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ï¼†ã‚¹ãƒªãƒ ï¼‰ */
.marker-panel {
  background: linear-gradient(135deg, rgba(78,205,196,0.08), rgba(255,107,107,0.08));
  border-bottom: 1px solid rgba(255,255,255,0.1);
  padding: 12px 15px;
}

.marker-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.marker-header h3 {
  margin: 0;
  font-size: 0.95em;
  color: rgba(255,255,255,0.9);
  font-weight: 500;
  letter-spacing: 0.5px;
}

.marker-size-control {
  display: flex;
  align-items: center;
  gap: 8px;
  background: rgba(0,0,0,0.3);
  padding: 4px 10px;
  border-radius: 12px;
}

.marker-size-control input[type="range"] {
  width: 60px;
  height: 4px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(255,255,255,0.2);
  border-radius: 2px;
  outline: none;
}

.marker-size-control input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 12px;
  height: 12px;
  background: #4ecdc4;
  cursor: pointer;
  border-radius: 50%;
  box-shadow: 0 0 5px rgba(78,205,196,0.5);
}

.marker-size-control input[type="range"]::-moz-range-thumb {
  width: 12px;
  height: 12px;
  background: #4ecdc4;
  cursor: pointer;
  border-radius: 50%;
  border: none;
  box-shadow: 0 0 5px rgba(78,205,196,0.5);
}

.marker-size-control span {
  font-size: 0.75em;
  color: rgba(255,255,255,0.8);
  min-width: 20px;
  text-align: center;
  font-weight: 600;
}

.marker-rules {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.marker-rule {
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  padding: 8px 10px;
  border: 1px solid rgba(255,255,255,0.05);
  transition: all 0.2s ease;
}

.marker-rule:hover {
  background: rgba(0,0,0,0.3);
  border-color: rgba(255,255,255,0.1);
}

.marker-rule-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 6px;
}

.marker-rule-header input[type="checkbox"] {
  width: 16px;
  height: 16px;
  cursor: pointer;
  accent-color: #4ecdc4;
}

.marker-rule-header label {
  flex: 1;
  font-size: 0.85em;
  color: rgba(255,255,255,0.9);
  cursor: pointer;
  user-select: none;
  font-weight: 500;
}

.marker-rule-header input[type="color"] {
  width: 28px;
  height: 28px;
  border: 2px solid rgba(255,255,255,0.2);
  border-radius: 6px;
  cursor: pointer;
  background: none;
  transition: all 0.2s ease;
}

.marker-rule-header input[type="color"]:hover {
  border-color: rgba(255,255,255,0.4);
  transform: scale(1.05);
}

.marker-rule-control {
  display: flex;
  align-items: center;
  gap: 6px;
  padding-left: 24px;
}

.marker-rule-control .control-label {
  font-size: 0.7em;
  color: rgba(255,255,255,0.6);
  min-width: 35px;
}

.marker-rule-control input[type="range"] {
  flex: 1;
  height: 3px;
  -webkit-appearance: none;
  appearance: none;
  background: rgba(255,255,255,0.15);
  border-radius: 2px;
  outline: none;
}

.marker-rule-control input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 10px;
  height: 10px;
  background: rgba(255,255,255,0.9);
  cursor: pointer;
  border-radius: 50%;
}

.marker-rule-control input[type="range"]::-moz-range-thumb {
  width: 10px;
  height: 10px;
  background: rgba(255,255,255,0.9);
  cursor: pointer;
  border-radius: 50%;
  border: none;
}

.marker-rule-control input[type="number"] {
  width: 45px;
  padding: 3px 6px;
  background: rgba(0,0,0,0.3);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 4px;
  color: white;
  font-size: 0.75em;
  text-align: center;
}

.marker-rule-control input[type="number"]:focus {
  outline: none;
  border-color: #4ecdc4;
  background: rgba(0,0,0,0.5);
}

.marker-rule-control .control-value {
  font-size: 0.7em;
  color: rgba(255,255,255,0.8);
  min-width: 35px;
  text-align: right;
  font-weight: 600;
}

.marker-rule-control > span:not(.control-label):not(.control-value) {
  font-size: 0.8em;
  color: rgba(255,255,255,0.4);
}

.table-container {
  flex: 1;
  overflow: auto;
  padding: 10px;
}

.data-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
  color: #fff;
}

.data-table thead {
  position: sticky;
  top: 0;
  background: rgba(0,0,0,0.95);
  z-index: 2;
}

.data-table th {
  padding: 8px 4px;
  text-align: left;
  border-bottom: 2px solid rgba(78,205,196,0.5);
  font-weight: bold;
  white-space: nowrap;
  background: rgba(0,0,0,0.95);
}

.data-table td {
  padding: 6px 4px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  white-space: nowrap;
}

.data-table tr:hover {
  background: rgba(255,255,255,0.05);
}

.data-table tr.current-row {
  background: rgba(0,255,100,0.3) !important;
  font-weight: bold;
}

.data-table tr.current-row td {
  border-top: 2px solid rgba(0,255,100,0.8);
  border-bottom: 2px solid rgba(0,255,100,0.8);
}

.header {
  text-align: center;
  margin-bottom: 25px;
  padding: 18px;
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
  backdrop-filter: blur(10px);
}

.header h1 {
  margin: 0;
  font-size: 2em;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.header p {
  margin: 8px 0 0 0;
  opacity: 0.8;
  font-size: 1em;
}

.control-panel {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 18px;
  margin-bottom: 18px;
  border: 1px solid rgba(255,255,255,0.1);
}

.control-group {
  margin-bottom: 20px;
}

.control-group h3 {
  margin: 0 0 12px 0;
  color: #4ecdc4;
  font-size: 1.1em;
  border-bottom: 2px solid rgba(78,205,196,0.3);
  padding-bottom: 6px;
  cursor: pointer;
  user-select: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
}

.control-group h3:hover {
  color: #5fddce;
  background: rgba(78,205,196,0.1);
  padding-left: 8px;
  border-radius: 8px;
}

.control-group h3::after {
  content: 'â–¼';
  font-size: 0.8em;
  transition: transform 0.3s ease;
}

.control-group h3.collapsed::after {
  transform: rotate(-90deg);
}

.control-group-content {
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.3s ease;
  max-height: 2000px;
  opacity: 1;
}

.control-group-content.collapsed {
  max-height: 0;
  opacity: 0;
}

.file-input {
  width: 100%;
  padding: 10px;
  border: 2px dashed rgba(255,255,255,0.3);
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.file-input:hover {
  border-color: #4ecdc4;
  background: rgba(78,205,196,0.1);
}

.sensor-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.sensor-checkbox {
  display: flex;
  align-items: center;
  padding: 6px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
  transition: all 0.3s ease;
  font-size: 13px;
}

.sensor-checkbox:hover {
  background: rgba(255,255,255,0.1);
}

.sensor-checkbox input {
  margin-right: 6px;
  transform: scale(1.1);
}

.angle-controls {
  margin-top: 15px;
}

.angle-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  margin-bottom: 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
}

.angle-item label {
  font-size: 12px;
  min-width: 80px;
}

.angle-item input[type="number"] {
  width: 70px;
  padding: 4px 8px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 4px;
  color: #fff;
  font-size: 13px;
  text-align: center;
}

.angle-item input[type="range"] {
  flex: 1;
  margin: 0 10px;
}

.interactive-graph {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 15px;
  border: 1px solid rgba(255,255,255,0.1);
  margin-bottom: 15px;
}

.graph-container {
  position: relative;
  width: 100%;
  height: 240px;
  background: rgba(0,0,0,0.3);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.2);
  margin: 12px 0;
  cursor: crosshair;
}

.graph-canvas {
  width: 100%;
  height: 100%;
  border-radius: 10px;
}

.graph-title {
  font-size: 1em;
  font-weight: bold;
  margin-bottom: 8px;
  color: #ff6b6b;
}

.graph-title.steering,
.graph-title.radius {
  color: #4ecdc4;
}

.graph-range-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-top: 8px;
  margin-bottom: 8px;
  padding: 10px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
}

.range-input-group {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
}

.range-input-group label {
  font-weight: bold;
  min-width: 40px;
}

.range-input-group input {
  width: 60px;
  padding: 4px 6px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 4px;
  color: #fff;
  font-size: 12px;
  text-align: center;
}

.graph-controls {
  display: flex;
  gap: 6px;
  margin-top: 8px;
  flex-wrap: wrap;
}

.btn {
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  border: none;
  padding: 5px 10px;
  border-radius: 12px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 11px;
}

.btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.btn:active {
  transform: translateY(0);
}

.btn.secondary {
  background: linear-gradient(45deg, #667eea, #764ba2);
}

.btn.danger {
  background: linear-gradient(45deg, #ff416c, #ff4b2b);
}

.btn.mode-toggle {
  background: linear-gradient(45deg, #ffa500, #ff8c00);
  padding: 6px 14px;
  font-size: 12px;
  margin-bottom: 8px;
}

.btn.mode-toggle.active {
  background: linear-gradient(45deg, #00d4aa, #00a896);
  box-shadow: 0 0 15px rgba(0, 212, 170, 0.5);
}

.map-table-container {
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  padding: 12px;
  margin-top: 8px;
  max-height: 350px;
  overflow-y: auto;
}

.map-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
}

.map-table th {
  background: rgba(78, 205, 196, 0.2);
  color: #4ecdc4;
  padding: 8px 6px;
  text-align: center;
  font-weight: bold;
  border-bottom: 2px solid rgba(78, 205, 196, 0.4);
  position: sticky;
  top: 0;
  z-index: 1;
}

.map-table td {
  padding: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.map-table input {
  width: 100%;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  color: #fff;
  padding: 4px 6px;
  border-radius: 4px;
  font-size: 12px;
  text-align: center;
}

.map-table input:focus {
  outline: none;
  border-color: #4ecdc4;
  background: rgba(78, 205, 196, 0.15);
}

.map-table .btn-delete {
  background: linear-gradient(45deg, #ff416c, #ff4b2b);
  border: none;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
  font-weight: bold;
}

.map-table .btn-delete:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 8px rgba(255, 65, 108, 0.5);
}

.map-table-actions {
  display: flex;
  gap: 6px;
  margin-top: 8px;
  justify-content: center;
}

.canvas-wrapper {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: rgba(0,0,0,0.3);
  border-radius: 20px;
  padding: 20px;
  border: 2px solid rgba(255,255,255,0.1);
}

.canvas-container {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
}

#trackCanvas {
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 15px;
  background: #111;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  cursor: grab;
}

#trackCanvas.dragging {
  cursor: grabbing;
}

.control-graph-panel {
  margin-top: 15px;
  padding: 10px 15px;
  background: rgba(255,255,255,0.05);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.1);
}

.control-graph-panel h3 {
  margin: 0 0 10px 0;
  color: #4ecdc4;
  font-size: 0.95em;
  text-align: center;
}

.control-graph-container {
  position: relative;
  width: 100%;
  height: 150px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.2);
  cursor: grab;
}

.control-graph-container.dragging {
  cursor: grabbing;
}

.control-graph-canvas {
  width: 100%;
  height: 100%;
  border-radius: 8px;
}

.control-graph-controls {
  display: flex;
  gap: 8px;
  margin-top: 8px;
  justify-content: center;
  align-items: center;
}

.control-graph-btn {
  background: rgba(78,205,196,0.6);
  border: none;
  padding: 4px 10px;
  border-radius: 10px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  font-size: 10px;
  transition: all 0.3s ease;
}

.control-graph-btn:hover {
  background: rgba(78,205,196,0.9);
  transform: translateY(-1px);
}

.zoom-mode-selector {
  display: flex;
  gap: 4px;
  background: rgba(0,0,0,0.3);
  padding: 4px;
  border-radius: 10px;
}

.zoom-mode-btn {
  background: rgba(255,255,255,0.1);
  border: none;
  padding: 4px 8px;
  border-radius: 6px;
  color: white;
  font-size: 10px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.zoom-mode-btn:hover {
  background: rgba(255,255,255,0.2);
}

.zoom-mode-btn.active {
  background: rgba(78,205,196,0.8);
  font-weight: bold;
}

.sensor-selection {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
  padding: 8px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  margin-bottom: 8px;
}

.sensor-select-checkbox {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 0.85em;
}

.sensor-select-checkbox:hover {
  background: rgba(255,255,255,0.1);
}

.sensor-select-checkbox input[type="checkbox"] {
  cursor: pointer;
}

.map-control-item {
  display: flex;
  align-items: center;
  gap: 5px;
  margin-bottom: 6px;
  padding: 4px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

.btn {
  padding: 8px 16px;
  border: none;
  border-radius: 8px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 0.9em;
}

.btn.primary {
  background: linear-gradient(135deg, #4ecdc4, #44a08d);
}

.btn.primary:hover {
  background: linear-gradient(135deg, #5fddce, #55b19d);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(78,205,196,0.4);
}

.btn.secondary {
  background: rgba(255,255,255,0.1);
}

.btn.secondary:hover {
  background: rgba(255,255,255,0.2);
  transform: translateY(-1px);
}

.tooltip-icon {
  display: inline-block;
  margin-left: 5px;
  width: 16px;
  height: 16px;
  background: rgba(255,255,255,0.1);
  border-radius: 50%;
  text-align: center;
  line-height: 16px;
  font-size: 12px;
  cursor: help;
  color: #4ecdc4;
  transition: all 0.3s ease;
}

.tooltip-icon:hover {
  background: rgba(78,205,196,0.3);
  transform: scale(1.2);
}

.accordion-section {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 0;
  margin-bottom: 18px;
  border: 1px solid rgba(255,255,255,0.1);
  overflow: hidden;
}

.accordion-title {
  margin: 0;
  padding: 15px 18px;
  color: #4ecdc4;
  font-size: 1.1em;
  cursor: pointer;
  user-select: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
  background: rgba(255,255,255,0.03);
}

.accordion-title:hover {
  background: rgba(78,205,196,0.1);
}

.accordion-icon {
  transition: transform 0.3s ease;
}

.accordion-content {
  padding: 18px;
  max-height: 2000px;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
  opacity: 1;
}

.accordion-content.collapsed {
  max-height: 0;
  padding: 0 18px;
  opacity: 0;
}

.time-control-panel {
  margin-top: 0;
  margin-bottom: 15px;
  padding: 10px 15px;
  background: rgba(255,255,255,0.05);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.1);
}

.time-control-header {
  display: flex;
  align-items: center;
  gap: 15px;
  margin-bottom: 8px;
}

.time-control-panel h3 {
  margin: 0;
  color: #4ecdc4;
  font-size: 1em;
  flex-shrink: 0;
}

.time-slider-container {
  position: relative;
  padding: 8px 0;
  margin-bottom: 22px;
}

.time-slider {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: rgba(255,255,255,0.2);
  outline: none;
  -webkit-appearance: none;
  cursor: pointer;
}

.time-ticks {
  position: absolute;
  width: 100%;
  height: 18px;
  top: 18px;
  left: 0;
  display: flex;
  justify-content: space-between;
  pointer-events: none;
}

.time-tick {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.time-tick-line {
  width: 1px;
  height: 6px;
  background: rgba(78,205,196,0.5);
  margin-bottom: 2px;
}

.time-tick-label {
  font-size: 9px;
  color: rgba(255,255,255,0.6);
  white-space: nowrap;
}

.time-slider::-webkit-slider-thumb {
  appearance: none;
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  cursor: pointer;
  box-shadow: 0 0 10px rgba(78,205,196,0.8);
}

.time-slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  cursor: pointer;
  border: none;
  box-shadow: 0 0 10px rgba(78,205,196,0.8);
}

.time-info {
  display: none;
}

.time-display {
  padding: 4px 12px;
  background: rgba(78,205,196,0.15);
  border-radius: 6px;
  font-size: 0.85em;
  font-weight: bold;
  white-space: nowrap;
  flex-shrink: 0;
}

.playback-controls {
  display: flex;
  gap: 6px;
  flex-shrink: 0;
}

.play-btn {
  background: linear-gradient(45deg, #00d2ff, #3a47d5);
  border: none;
  padding: 6px 12px;
  border-radius: 15px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  font-size: 11px;
  transition: all 0.3s ease;
  white-space: nowrap;
}

.play-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 5px 15px rgba(0,210,255,0.4);
}

.stats-panel {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 12px;
  margin-top: 15px;
  border: 1px solid rgba(255,255,255,0.1);
}

.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.stat-item {
  text-align: center;
  padding: 6px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
}

.stat-value {
  font-size: 1.2em;
  font-weight: bold;
  color: #4ecdc4;
}

.stat-label {
  font-size: 0.8em;
  opacity: 0.8;
  margin-top: 3px;
}

.map-quality-panel {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 12px;
  margin-top: 15px;
  border: 1px solid rgba(255,255,255,0.1);
}

.map-quality-panel h3, .interactive-graph h3, .stats-panel h3 {
  cursor: pointer;
  user-select: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
  padding: 6px;
  border-radius: 8px;
}

.map-quality-panel h3:hover, .interactive-graph h3:hover, .stats-panel h3:hover {
  background: rgba(78,205,196,0.1);
}

.map-quality-panel h3::after, .interactive-graph h3::after, .stats-panel h3::after {
  content: 'â–¼';
  font-size: 0.8em;
  transition: transform 0.3s ease;
}

.map-quality-panel h3.collapsed::after, .interactive-graph h3.collapsed::after, .stats-panel h3.collapsed::after {
  transform: rotate(-90deg);
}

.panel-content {
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.3s ease;
  max-height: 3000px;
  opacity: 1;
}

.panel-content.collapsed {
  max-height: 0;
  opacity: 0;
}

.quality-slider {
  width: 100%;
  margin: 8px 0;
}

.quality-label {
  display: flex;
  justify-content: space-between;
  font-size: 0.85em;
  opacity: 0.8;
}

.map-control-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-top: 12px;
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ */
@media (max-width: 1400px) {
  .container {
    flex-direction: column;
  }
  
  .sidebar {
    width: 100%;
    height: auto;
    max-height: 60vh;
  }
  
  .main-content {
    height: 40vh;
  }
}

/* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.control-panel, .interactive-graph, .stats-panel {
  animation: fadeIn 0.6s ease-out;
}

/* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º */
.sidebar::-webkit-scrollbar {
  width: 8px;
}

.sidebar::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.1);
  border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb {
  background: rgba(78,205,196,0.6);
  border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
  background: rgba(78,205,196,0.8);
}
</style>
</head>
<body>

<div class="container">
  <div class="sidebar">
    <div class="header">
      <h1>ğŸš— MiniCar SLAM <span style="font-size: 0.5em; font-weight: 300; opacity: 0.6; letter-spacing: 1px;">v0.1.0.7</span></h1>
      <p>é«˜åº¦æ“ä½œç‰ˆ - Zoomãƒ»Rotationãƒ»Dragå¯¾å¿œ</p>
      <p style="font-size: 0.85em; opacity: 0.7; margin-top: 3px;">Simultaneous Localization And Mapping</p>
    </div>

    <div class="control-panel">
      <div class="control-group">
        <h3>ğŸ“ ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«</h3>
        <div class="control-group-content">
        <input type="file" id="csvFile" accept=".csv" class="file-input">
        </div>
      </div>

      <div class="control-group">
        <h3>ğŸ” æœ‰åŠ¹ã‚»ãƒ³ã‚µ</h3>
        <div class="control-group-content">
        <div class="sensor-controls">
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(255,50,150,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="RrLH" checked>
            <span style="color: #ff3296;">â—</span> RrLH
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(100,200,255,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="FrLH" checked>
            <span style="color: #64c8ff;">â—</span> FrLH
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(50,255,50,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="Fr" checked>
            <span style="color: #32ff32;">â—</span> Fr
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(255,200,50,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="FrRH" checked>
            <span style="color: #ffc832;">â—</span> FrRH
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(255,100,50,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="RrRH" checked>
            <span style="color: #ff6432;">â—</span> RrRH
          </label>
          </div>
        </div>
      </div>

      <div class="control-group">
        <h3>ğŸ“ ã‚»ãƒ³ã‚µãƒ¼å–ä»˜è§’åº¦ï¼ˆè»Šä¸¡å‰æ–¹ã‚’0åº¦ã€å³å›ã‚Šï¼‰</h3>
        <div class="control-group-content">
        <div class="angle-controls">
          <div class="angle-item">
            <label><span style="color: #32ff32;">â—</span> Fr (æ­£é¢)</label>
            <input type="range" min="0" max="360" value="0" oninput="updateSensorAngle('Fr', this.value)">
            <input type="number" id="angleFr" min="0" max="360" value="0" onchange="updateSensorAngle('Fr', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #ffc832;">â—</span> FrRH (å³å‰)</label>
            <input type="range" min="0" max="360" value="35" oninput="updateSensorAngle('FrRH', this.value)">
            <input type="number" id="angleFrRH" min="0" max="360" value="35" onchange="updateSensorAngle('FrRH', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #ff6432;">â—</span> RrRH (å³å¾Œ)</label>
            <input type="range" min="0" max="360" value="90" oninput="updateSensorAngle('RrRH', this.value)">
            <input type="number" id="angleRrRH" min="0" max="360" value="90" onchange="updateSensorAngle('RrRH', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #ff3296;">â—</span> RrLH (å·¦å¾Œ)</label>
            <input type="range" min="0" max="360" value="270" oninput="updateSensorAngle('RrLH', this.value)">
            <input type="number" id="angleRrLH" min="0" max="360" value="270" onchange="updateSensorAngle('RrLH', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #64c8ff;">â—</span> FrLH (å·¦å‰)</label>
            <input type="range" min="0" max="360" value="325" oninput="updateSensorAngle('FrLH', this.value)">
            <input type="number" id="angleFrLH" min="0" max="360" value="325" onchange="updateSensorAngle('FrLH', this.value)">Â°
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="interactive-graph">
      <h3>âš™ï¸ ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒãƒƒãƒ—èª¿æ•´</h3>
      
      <div class="control-group" style="margin-bottom: 15px; padding: 10px; background: rgba(78,205,196,0.1); border-radius: 8px;">
        <label style="font-size: 0.9em; display: block; margin-bottom: 5px; color: #4ecdc4; font-weight: bold;">ğŸš— ãƒ›ã‚¤ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ (mm)</label>
        <div class="slider-container">
          <input type="range" min="50" max="500" step="10" value="150" oninput="updateWheelbase(this.value)" style="flex: 1;">
          <input type="number" id="wheelbaseValue" min="50" max="500" step="10" value="150" onchange="updateWheelbase(this.value)" style="width: 70px;">
        </div>
      </div>
      
      <div class="control-group" style="margin-bottom: 15px; padding: 10px; background: rgba(255,184,77,0.1); border-radius: 8px; border: 1px solid rgba(255,184,77,0.3);">
        <h4 style="margin: 0 0 10px 0; color: #ffb84d; font-size: 0.95em;">âš™ï¸ ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h4>
        
        <label style="font-size: 0.85em; display: flex; align-items: center; margin-bottom: 3px;">
          ğŸ“ é€Ÿåº¦ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°
          <span class="tooltip-icon" title="é€Ÿåº¦ã®å…¨ä½“çš„ãªå€ç‡ã‚’èª¿æ•´ã—ã¾ã™ã€‚ã‚³ãƒ¼ã‚¹å…¨ä½“ãŒå¤§ãã™ãã‚‹/å°ã•ã™ãã‚‹å ´åˆã«èª¿æ•´ã—ã¦ãã ã•ã„ã€‚">â“˜</span>
        </label>
        <div class="slider-container" style="margin-bottom: 12px;">
          <input type="range" min="0.1" max="10" step="0.1" value="1.0" oninput="updateSpeedScale(this.value)" style="flex: 1;">
          <input type="number" id="speedScaleValue" min="0.1" max="10" step="0.1" value="1.0" onchange="updateSpeedScale(this.value)" style="width: 70px;">
        </div>
        
        <label style="font-size: 0.85em; display: flex; align-items: center; margin-bottom: 3px;">
          ğŸ¯ æ—‹å›åŠå¾„ã‚²ã‚¤ãƒ³
          <span class="tooltip-icon" title="æ—‹å›åŠå¾„ã®è£œæ­£ä¿‚æ•°ã§ã™ã€‚ã‚«ãƒ¼ãƒ–ãŒç·©ã™ãã‚‹å ´åˆã¯å°ã•ãã€ãã¤ã™ãã‚‹å ´åˆã¯å¤§ããèª¿æ•´ã—ã¦ãã ã•ã„ã€‚">â“˜</span>
        </label>
        <div class="slider-container" style="margin-bottom: 12px;">
          <input type="range" min="0.1" max="5" step="0.1" value="1.0" oninput="updateRadiusGain(this.value)" style="flex: 1;">
          <input type="number" id="radiusGainValue" min="0.1" max="5" step="0.1" value="1.0" onchange="updateRadiusGain(this.value)" style="width: 70px;">
        </div>
        
        <label style="font-size: 0.85em; display: flex; align-items: center; margin-bottom: 3px;">
          â±ï¸ æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«
          <span class="tooltip-icon" title="æ™‚é–“ã®æµã‚Œã‚’èª¿æ•´ã—ã¾ã™ã€‚é€šå¸¸ã¯1.0ã®ã¾ã¾ã§å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚">â“˜</span>
        </label>
        <div class="slider-container" style="margin-bottom: 12px;">
          <input type="range" min="0.1" max="5" step="0.1" value="1.0" oninput="updateTimeScale(this.value)" style="flex: 1;">
          <input type="number" id="timeScaleValue" min="0.1" max="5" step="0.1" value="1.0" onchange="updateTimeScale(this.value)" style="width: 70px;">
        </div>
        
        <button class="btn primary" onclick="recalculatePositions()" style="width: 100%; font-size: 0.85em;">ğŸ’« ä½ç½®ã‚’å†è¨ˆç®—</button>
        <button class="btn secondary" onclick="resetCalibration()" style="width: 100%; font-size: 0.85em; margin-top: 5px;">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
      
      <div class="control-group" style="margin-bottom: 15px; padding: 10px; background: rgba(138,201,38,0.1); border-radius: 8px; border: 1px solid rgba(138,201,38,0.3);">
        <h4 style="margin: 0 0 10px 0; color: #8ac926; font-size: 0.95em;">ğŸ“ å®Ÿã‚³ãƒ¼ã‚¹å¯¸æ³•</h4>
        
        <label style="font-size: 0.85em; display: block; margin-bottom: 3px;">ç¸¦ç·šã®é•·ã• (m)</label>
        <input type="number" id="courseVertical" min="1" max="100" step="0.5" value="15" style="width: 100%; margin-bottom: 8px; padding: 4px;">
        
        <label style="font-size: 0.85em; display: block; margin-bottom: 3px;">æ¨ªç·šã®é•·ã• (m)</label>
        <input type="number" id="courseHorizontal" min="1" max="100" step="0.5" value="4" style="width: 100%; margin-bottom: 8px; padding: 4px;">
        
        <label style="font-size: 0.85em; display: block; margin-bottom: 3px;">é“å¹… (m)</label>
        <input type="number" id="courseWidth" min="0.5" max="10" step="0.1" value="1.5" style="width: 100%; margin-bottom: 8px; padding: 4px;">
        
        <button class="btn" onclick="showCourseReference()" style="width: 100%; font-size: 0.85em;">ğŸ“Š ã‚³ãƒ¼ã‚¹å‚ç…§ç·šã‚’è¡¨ç¤º</button>
      </div>
      
      <div>
        <div class="graph-title">ğŸš— è»Šé€Ÿãƒãƒƒãƒ— (Thr% â†’ m/s)</div>
        
        <div style="text-align: center; margin-bottom: 8px;">
          <button class="btn mode-toggle" id="speedModeBtn" onclick="toggleSpeedMapMode()">ğŸ“Š ã‚°ãƒ©ãƒ•ãƒ¢ãƒ¼ãƒ‰</button>
        </div>
        
        <!-- ã‚°ãƒ©ãƒ•ãƒ¢ãƒ¼ãƒ‰ -->
        <div id="speedGraphMode">
        <div class="graph-range-controls">
          <div class="range-input-group">
            <label>Xè»¸ Min:</label>
            <input type="number" id="speedXMin" value="0" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Xè»¸ Max:</label>
            <input type="number" id="speedXMax" value="100" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Min:</label>
            <input type="number" id="speedYMin" value="0" step="0.5" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Max:</label>
            <input type="number" id="speedYMax" value="5" step="0.5" onchange="updateGraphRange()">
          </div>
        </div>
        <div class="graph-container" id="speedGraphContainer">
          <canvas class="graph-canvas" id="speedGraph"></canvas>
        </div>
        <div class="graph-controls">
          <button class="btn" onclick="addSpeedPoint()">+</button>
          <button class="btn secondary" onclick="resetSpeedMap()">ğŸ”„</button>
          </div>
        </div>
        
        <!-- ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ¢ãƒ¼ãƒ‰ -->
        <div id="speedTableMode" style="display: none;">
          <div class="map-table-container">
            <table class="map-table">
              <thead>
                <tr>
                  <th style="width: 35%;">Throttle (%)</th>
                  <th style="width: 35%;">Speed (m/s)</th>
                  <th style="width: 30%;">æ“ä½œ</th>
                </tr>
              </thead>
              <tbody id="speedTableBody">
              </tbody>
            </table>
          </div>
          <div class="map-table-actions">
            <button class="btn" onclick="addSpeedPointTable()">â• ãƒã‚¤ãƒ³ãƒˆè¿½åŠ </button>
            <button class="btn secondary" onclick="resetSpeedMap()">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
          </div>
        </div>
      </div>

      <div style="margin-top: 15px;">
        <div class="graph-title radius">ğŸ¯ æ—‹å›åŠå¾„ãƒãƒƒãƒ— (Str% â†’ mm)</div>
        
        <div style="text-align: center; margin-bottom: 8px;">
          <button class="btn mode-toggle" id="radiusModeBtn" onclick="toggleRadiusMapMode()">ğŸ“Š ã‚°ãƒ©ãƒ•ãƒ¢ãƒ¼ãƒ‰</button>
        </div>
        
        <!-- ã‚°ãƒ©ãƒ•ãƒ¢ãƒ¼ãƒ‰ -->
        <div id="radiusGraphMode">
        <div class="graph-range-controls">
          <div class="range-input-group">
            <label>Xè»¸ Min:</label>
              <input type="number" id="radiusXMin" value="-100" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Xè»¸ Max:</label>
              <input type="number" id="radiusXMax" value="100" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Min:</label>
              <input type="number" id="radiusYMin" value="0" step="500" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Max:</label>
              <input type="number" id="radiusYMax" value="100000" step="5000" onchange="updateGraphRange()">
          </div>
        </div>
          <div class="graph-container" id="radiusGraphContainer">
            <canvas class="graph-canvas" id="radiusGraph"></canvas>
        </div>
        <div class="graph-controls">
            <button class="btn" onclick="addRadiusPoint()">+</button>
            <button class="btn secondary" onclick="resetRadiusMap()">ğŸ”„</button>
          </div>
        </div>
        
        <!-- ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ¢ãƒ¼ãƒ‰ -->
        <div id="radiusTableMode" style="display: none;">
          <div style="text-align: center; font-size: 0.8em; color: #4ecdc4; margin-bottom: 8px; padding: 6px; background: rgba(78, 205, 196, 0.1); border-radius: 4px;">
            ğŸ’¡ 0ã€œ100ã®æ­£ã®å€¤ã‚’ç·¨é›†ã™ã‚‹ã¨ã€è‡ªå‹•çš„ã«-100ã€œ0ã®è² ã®å€¤ã«ã‚‚åæ˜ ã•ã‚Œã¾ã™
          </div>
          <div class="map-table-container">
            <table class="map-table">
              <thead>
                <tr>
                  <th style="width: 35%;">Steering (%)</th>
                  <th style="width: 35%;">Radius (mm)</th>
                  <th style="width: 30%;">æ“ä½œ</th>
                </tr>
              </thead>
              <tbody id="radiusTableBody">
              </tbody>
            </table>
          </div>
          <div class="map-table-actions">
            <button class="btn" onclick="addRadiusPointTable()">â• ãƒã‚¤ãƒ³ãƒˆè¿½åŠ </button>
            <button class="btn secondary" onclick="resetRadiusMap()">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
          </div>
        </div>
      </div>

      <div style="margin-top: 15px;">
        <div class="graph-title" style="color: #ffa500;">âš¡ é€Ÿåº¦ä¾å­˜ä¿‚æ•°ãƒãƒƒãƒ— (Thr% â†’ ä¿‚æ•°)</div>
        
        <div style="text-align: center; margin-bottom: 8px;">
          <button class="btn mode-toggle" id="speedCoefModeBtn" onclick="toggleSpeedCoefMapMode()">ğŸ“Š ã‚°ãƒ©ãƒ•ãƒ¢ãƒ¼ãƒ‰</button>
        </div>
        
        <!-- ã‚°ãƒ©ãƒ•ãƒ¢ãƒ¼ãƒ‰ -->
        <div id="speedCoefGraphMode">
          <div class="graph-range-controls">
            <div class="range-input-group">
              <label>Xè»¸ Min:</label>
              <input type="number" id="speedCoefXMin" value="0" step="10" onchange="updateGraphRange()">
            </div>
            <div class="range-input-group">
              <label>Xè»¸ Max:</label>
              <input type="number" id="speedCoefXMax" value="100" step="10" onchange="updateGraphRange()">
            </div>
            <div class="range-input-group">
              <label>Yè»¸ Min:</label>
              <input type="number" id="speedCoefYMin" value="0.5" step="0.1" onchange="updateGraphRange()">
            </div>
            <div class="range-input-group">
              <label>Yè»¸ Max:</label>
              <input type="number" id="speedCoefYMax" value="3.0" step="0.1" onchange="updateGraphRange()">
            </div>
          </div>
          <div class="graph-container" id="speedCoefGraphContainer">
            <canvas class="graph-canvas" id="speedCoefGraph"></canvas>
          </div>
          <div class="graph-controls">
            <button class="btn" onclick="addSpeedCoefPoint()">+</button>
            <button class="btn secondary" onclick="resetSpeedCoefMap()">ğŸ”„</button>
          </div>
        </div>
        
        <!-- ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ¢ãƒ¼ãƒ‰ -->
        <div id="speedCoefTableMode" style="display: none;">
          <div style="text-align: center; font-size: 0.8em; color: #ffa500; margin-bottom: 8px; padding: 6px; background: rgba(255, 165, 0, 0.1); border-radius: 4px;">
            ğŸ’¡ é€Ÿåº¦ãŒé«˜ã„ã»ã©æ—‹å›åŠå¾„ãŒå¤§ãããªã‚Šã¾ã™ï¼ˆã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ãƒ†ã‚¢ï¼‰
          </div>
          <div class="map-table-container">
            <table class="map-table">
              <thead>
                <tr>
                  <th style="width: 40%;">Throttle (%)</th>
                  <th style="width: 35%;">ä¿‚æ•°</th>
                  <th style="width: 25%;">æ“ä½œ</th>
                </tr>
              </thead>
              <tbody id="speedCoefTableBody">
              </tbody>
            </table>
          </div>
          <div class="map-table-actions">
            <button class="btn" onclick="addSpeedCoefPointTable()">â• ãƒã‚¤ãƒ³ãƒˆè¿½åŠ </button>
            <button class="btn secondary" onclick="resetSpeedCoefMap()">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
          </div>
        </div>
      </div>

      <div style="margin-top: 12px; text-align: center;">
        <button class="btn" onclick="exportMaps()">ğŸ’¾ ä¿å­˜</button>
        <button class="btn" onclick="importMaps()">ğŸ“ èª­è¾¼</button>
      </div>
    </div>

    <div class="map-quality-panel">
      <h3>ğŸ¨ ãƒãƒƒãƒ—è¡¨ç¤ºè¨­å®š</h3>
      <div class="quality-label">
        <span>ã‚»ãƒ³ã‚µç‚¹å¯†åº¦</span>
        <span id="densityValue">1</span>
      </div>
      <input type="range" class="quality-slider" id="densitySlider" min="1" max="100" value="1" oninput="updateDensity(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>ã‚»ãƒ³ã‚µç‚¹ã‚µã‚¤ã‚º</span>
        <span id="sizeValue">4px</span>
      </div>
      <input type="range" class="quality-slider" id="sizeSlider" min="1" max="10" value="4" oninput="updatePointSize(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>ç·šã®å¤ªã•</span>
        <span id="lineWidthValue">1px</span>
      </div>
      <input type="range" class="quality-slider" id="lineWidthSlider" min="0.5" max="3" step="0.5" value="1" oninput="updateLineWidth(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>éå»ãƒ—ãƒ­ãƒƒãƒˆè¡¨ç¤ºæ•°</span>
        <span id="pastPlotsValue">5</span>
      </div>
      <input type="range" class="quality-slider" id="pastPlotsSlider" min="0" max="20" value="5" oninput="updatePastPlots(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>æœªæ¥ãƒ—ãƒ­ãƒƒãƒˆè¡¨ç¤ºæ•° (0=å…¨åŒºé–“)</span>
        <span id="futurePlotsValue">5</span>
      </div>
      <input type="range" class="quality-slider" id="futurePlotsSlider" min="0" max="20" value="5" oninput="updateFuturePlots(this.value)">
    </div>
    
    <div class="map-quality-panel">
      <h3>ğŸ—ºï¸ ãƒãƒƒãƒ—æ“ä½œè¨­å®š</h3>
      <div class="quality-label">
        <span>ã‚ºãƒ¼ãƒ </span>
        <span id="zoomValue">1.0x</span>
      </div>
      <input type="range" class="quality-slider" id="zoomSlider" min="0.1" max="10" step="0.1" value="1" oninput="updateZoom(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>å›è»¢è§’åº¦</span>
        <span id="rotationValue">0Â°</span>
      </div>
      <input type="range" class="quality-slider" id="rotationSlider" min="0" max="360" step="1" value="0" oninput="updateRotation(this.value)">
      
      <div class="map-control-buttons">
        <button class="btn secondary" onclick="resetView()">ğŸ”„ ãƒ“ãƒ¥ãƒ¼ãƒªã‚»ãƒƒãƒˆ</button>
        <button class="btn secondary" onclick="resetRotation()">ğŸ§­ æ–¹è§’ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
    </div>

    <div class="stats-panel">
      <h3>ğŸ“Š çµ±è¨ˆæƒ…å ±</h3>
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-value" id="totalPoints">0</div>
          <div class="stat-label">ç·ãƒ‡ãƒ¼ã‚¿æ•°</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="trackLength">0m</div>
          <div class="stat-label">è»Œè·¡é•·</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="maxSpeed">0m/s</div>
          <div class="stat-label">æœ€å¤§é€Ÿåº¦</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="avgSpeed">0m/s</div>
          <div class="stat-label">å¹³å‡é€Ÿåº¦</div>
        </div>
      </div>
    </div>
  </div>

  <div class="main-content">
    <div class="canvas-wrapper">
      <div class="time-control-panel">
        <div class="time-control-header">
          <h3>â±ï¸ ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³åˆ¶å¾¡</h3>
          <div class="time-display" id="timeDisplay">æ™‚åˆ»: --:--:--.---</div>
          <div class="playback-controls">
            <button class="play-btn" id="playBtn" onclick="togglePlayback()">â–¶ å†ç”Ÿ</button>
            <button class="play-btn" onclick="resetPlayback()">â® æœ€åˆã‹ã‚‰</button>
            <button class="play-btn" onclick="jumpToEnd()">â­ æœ€å¾Œã¸</button>
            <button class="play-btn" onclick="addAnnotation()" style="background: linear-gradient(45deg, #ffd700, #ff8c00);" title="ç¾åœ¨ä½ç½®ã«æ³¨é‡ˆã‚’è¿½åŠ ">ğŸ“ æ³¨é‡ˆè¿½åŠ </button>
          </div>
        </div>
        <div class="time-slider-container">
          <input type="range" class="time-slider" id="timeSlider" min="0" max="100" value="100">
          <div class="time-ticks" id="timeTicks"></div>
        </div>
        <div class="time-info">
          <span id="startTime">é–‹å§‹: --:--:--.---</span>
          <span id="endTime">çµ‚äº†: --:--:--.---</span>
        </div>
      </div>
      
      <div class="canvas-container">
        <canvas id="trackCanvas" width="900" height="700"></canvas>
      </div>
      
      <div class="control-graph-panel">
        <h3>ğŸ® åˆ¶å¾¡å…¥åŠ›ã®æ™‚ç³»åˆ—å¤‰åŒ–</h3>
        <div class="control-graph-container" id="controlGraphContainer">
          <canvas class="control-graph-canvas" id="controlGraph"></canvas>
        </div>
        <div class="control-graph-controls">
          <div class="zoom-mode-selector">
            <button class="zoom-mode-btn active" id="zoomModeX" onclick="setControlGraphZoomMode('x')">Xè»¸</button>
            <button class="zoom-mode-btn" id="zoomModeY" onclick="setControlGraphZoomMode('y')">Yè»¸</button>
            <button class="zoom-mode-btn" id="zoomModeBoth" onclick="setControlGraphZoomMode('both')">ä¸¡è»¸</button>
          </div>
          <button class="control-graph-btn" onclick="zoomInControlGraph()">ğŸ”+ ã‚ºãƒ¼ãƒ ã‚¤ãƒ³</button>
          <button class="control-graph-btn" onclick="zoomOutControlGraph()">ğŸ”- ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ</button>
          <button class="control-graph-btn" onclick="resetControlGraphView()">ğŸ”„ å…¨ä½“è¡¨ç¤º</button>
        </div>
      </div>
      
      <div class="control-graph-panel">
        <h3>ğŸ“¡ è¶…éŸ³æ³¢ã‚»ãƒ³ã‚µå€¤ã®æ™‚ç³»åˆ—å¤‰åŒ–</h3>
        <div class="sensor-selection" id="sensorSelection">
          <label class="sensor-select-checkbox">
            <input type="checkbox" value="RrLH" checked onchange="drawSensorGraph()">
            <span style="color: #ff3296;">â— RrLH</span>
          </label>
          <label class="sensor-select-checkbox">
            <input type="checkbox" value="FrLH" checked onchange="drawSensorGraph()">
            <span style="color: #64c8ff;">â— FrLH</span>
          </label>
          <label class="sensor-select-checkbox">
            <input type="checkbox" value="Fr" checked onchange="drawSensorGraph()">
            <span style="color: #32ff32;">â— Fr</span>
          </label>
          <label class="sensor-select-checkbox">
            <input type="checkbox" value="FrRH" checked onchange="drawSensorGraph()">
            <span style="color: #ffc832;">â— FrRH</span>
          </label>
          <label class="sensor-select-checkbox">
            <input type="checkbox" value="RrRH" checked onchange="drawSensorGraph()">
            <span style="color: #ff6432;">â— RrRH</span>
          </label>
        </div>
        <div class="control-graph-container" id="sensorGraphContainer">
          <canvas class="control-graph-canvas" id="sensorGraph"></canvas>
        </div>
        <div class="control-graph-controls">
          <div class="zoom-mode-selector">
            <button class="zoom-mode-btn active" id="sensorZoomModeX" onclick="setSensorGraphZoomMode('x')">Xè»¸</button>
            <button class="zoom-mode-btn" id="sensorZoomModeY" onclick="setSensorGraphZoomMode('y')">Yè»¸</button>
            <button class="zoom-mode-btn" id="sensorZoomModeBoth" onclick="setSensorGraphZoomMode('both')">ä¸¡è»¸</button>
          </div>
          <button class="control-graph-btn" onclick="zoomInSensorGraph()">ğŸ”+ ã‚ºãƒ¼ãƒ ã‚¤ãƒ³</button>
          <button class="control-graph-btn" onclick="zoomOutSensorGraph()">ğŸ”- ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ</button>
          <button class="control-graph-btn" onclick="resetSensorGraphView()">ğŸ”„ å…¨ä½“è¡¨ç¤º</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
  <div class="table-sidebar" id="tableSidebar">
    <div class="table-resize-handle" id="tableResizeHandle"></div>
    
    <!-- ãƒãƒ¼ã‚«ãƒ¼è¨­å®šãƒ‘ãƒãƒ« -->
    <div class="marker-panel">
      <div class="marker-header">
        <h3>ğŸ“ ãƒãƒ¼ã‚«ãƒ¼</h3>
        <div class="marker-size-control">
          <input type="range" id="markerSizeSlider" min="3" max="20" step="1" value="6" oninput="updateMarkerSize(this.value)">
          <span id="markerSizeValue">6</span>
        </div>
      </div>
      
      <div class="marker-rules">
        <!-- ãƒ«ãƒ¼ãƒ«â‘  -->
        <div class="marker-rule">
          <div class="marker-rule-header">
            <input type="checkbox" id="rule1MarkerEnabled" checked onchange="toggleMarker('rule1', this.checked)">
            <label for="rule1MarkerEnabled">ğŸš§ ç‹­ã„é“</label>
            <input type="color" id="rule1ColorPicker" value="#808080" onchange="updateMarkerColor('rule1', this.value)">
          </div>
          <div class="marker-rule-control">
            <span class="control-label">é–¾å€¤</span>
            <input type="range" id="rule1ThresholdSlider" min="50" max="1000" step="50" value="300" oninput="updateMarkerThreshold('rule1', this.value)">
            <span class="control-value" id="rule1ThresholdValue">300</span>
          </div>
        </div>
        
        <!-- ãƒ«ãƒ¼ãƒ«â‘¡ -->
        <div class="marker-rule">
          <div class="marker-rule-header">
            <input type="checkbox" id="rule2MarkerEnabled" checked onchange="toggleMarker('rule2', this.checked)">
            <label for="rule2MarkerEnabled">ğŸ”„ å¤§æ“èˆµ</label>
            <input type="color" id="rule2ColorPicker" value="#FF6B6B" onchange="updateMarkerColor('rule2', this.value)">
          </div>
          <div class="marker-rule-control">
            <span class="control-label">ç¯„å›²</span>
            <input type="number" id="rule2MinValue" value="90" min="0" max="100" onchange="updateMarkerRange('rule2')">
            <span>-</span>
            <input type="number" id="rule2MaxValue" value="100" min="0" max="100" onchange="updateMarkerRange('rule2')">
          </div>
        </div>
        
        <!-- ãƒ«ãƒ¼ãƒ«â‘¢ -->
        <div class="marker-rule">
          <div class="marker-rule-header">
            <input type="checkbox" id="rule3MarkerEnabled" checked onchange="toggleMarker('rule3', this.checked)">
            <label for="rule3MarkerEnabled">âš¡ é«˜é§†å‹•</label>
            <input type="color" id="rule3ColorPicker" value="#4ECDC4" onchange="updateMarkerColor('rule3', this.value)">
          </div>
          <div class="marker-rule-control">
            <span class="control-label">ç¯„å›²</span>
            <input type="number" id="rule3MinValue" value="80" min="0" max="100" onchange="updateMarkerRange('rule3')">
            <span>-</span>
            <input type="number" id="rule3MaxValue" value="100" min="0" max="100" onchange="updateMarkerRange('rule3')">
          </div>
        </div>
      </div>
    </div>
    
    <div class="table-header">
      <h3>ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«</h3>
      <button class="table-close-btn" onclick="toggleTableSidebar()">âœ•</button>
    </div>
    <div class="table-container" id="tableContainer">
      <table class="data-table" id="dataTable">
        <thead>
          <tr id="tableHeaderRow"></tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>
</div>

<!-- ãƒ†ãƒ¼ãƒ–ãƒ«é–‹ããƒœã‚¿ãƒ³ï¼ˆbodyã®ç›´ä¸‹ï¼‰ -->
<button class="table-toggle-btn" id="tableToggleBtn" onclick="toggleTableSidebar()">â—€</button>

<script>
// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let csvData = [];
let headers = [];
let positions = [];
let currentTimeIndex = 0;
let isPlaying = false;
let playbackInterval = null;

// è»Šä¸¡ã¨ã‚³ãƒ¼ã‚¹ã®ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆmmå˜ä½ï¼‰
const VEHICLE_LENGTH = 250;  // mm
const VEHICLE_WIDTH = 150;   // mm
const COURSE_WIDTH = 1000;   // mm

// è¡¨ç¤ºè¨­å®š
let sensorDensity = 1;
let sensorPointSize = 4;
let sensorLineWidth = 1;
let pastPlotsCount = 5;
let futurePlotsCount = 5;  // æ–°è¦ï¼šæœªæ¥ãƒ—ãƒ­ãƒƒãƒˆè¡¨ç¤ºæ•°
let vehicleSizeMultiplier = 1.8;  // è»Šä¸¡ã‚µã‚¤ã‚ºå€ç‡ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§1.8å€ï¼‰

// è»Šä¸¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
let wheelbase = 0.15;  // ãƒ›ã‚¤ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ï¼ˆmï¼‰ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 150mm

// ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
let speedScale = 1.0;     // é€Ÿåº¦ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°
let radiusGain = 1.0;     // æ—‹å›åŠå¾„ã‚²ã‚¤ãƒ³
let timeScale = 1.0;      // æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«

// ã‚³ãƒ¼ã‚¹å¯¸æ³•ã®å‚ç…§ç·šã‚’è¡¨ç¤ºã™ã‚‹ãƒ•ãƒ©ã‚°
let showCourseRef = false;

// ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿
let medianFilterEnabled = false;
let filteredData = [];  // ãƒ•ã‚£ãƒ«ã‚¿æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿

// ãƒãƒƒãƒ—æ“ä½œè¨­å®š
let mapZoom = 1.0;
let mapOffsetX = 0;
let mapOffsetY = 0;
let mapRotation = 0;  // ãƒ©ã‚¸ã‚¢ãƒ³
let isDraggingMap = false;
let dragStartX = 0;
let dragStartY = 0;
let isDraggingVehicle = false;
let isDraggingCompass = false;
let compassX = 0;
let compassY = 0;

// ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼è¨­å®š
let isTableOpen = true;
let isResizingTable = false;
let tableStartX = 0;
let tableStartWidth = 0;

// åˆ¶å¾¡ã‚°ãƒ©ãƒ•æ“ä½œè¨­å®š
let controlGraphZoomX = 1.0;
let controlGraphZoomY = 1.0;
let controlGraphOffsetX = 0;
let controlGraphOffsetY = 0;
let isDraggingControlGraph = false;
let controlGraphDragStartX = 0;
let controlGraphDragStartY = 0;
let controlGraphZoomMode = 'x'; // 'x', 'y', 'both'

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•æ“ä½œè¨­å®š
let sensorGraph, sensorCtx;
let sensorGraphZoomX = 1.0;
let sensorGraphZoomY = 1.0;
let sensorGraphOffsetX = 0;
let sensorGraphOffsetY = 0;
let isDraggingSensorGraph = false;
let sensorGraphDragStartX = 0;
let sensorGraphDragStartY = 0;
let sensorGraphZoomMode = 'x'; // 'x', 'y', 'both'

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’ä¿å­˜
let canvasScaleInfo = {
  minX: 0,
  minY: 0,
  scale: 1,
  margin: 80,
  centerX: 0,
  centerY: 0
};

// ã‚»ãƒ³ã‚µãƒ¼å–ä»˜è§’åº¦ï¼ˆåº¦ï¼‰- è»Šä¸¡å‰æ–¹ã‚’0åº¦ã¨ã—ã¦å³å›ã‚Š
let sensorAngles = {
  'Fr': 0,
  'FrRH': 35,
  'RrRH': 90,
  'RrLH': 270,
  'FrLH': 325
};

// ã‚°ãƒ©ãƒ•ç¯„å›²è¨­å®š
let graphRanges = {
  speed: { xMin: 0, xMax: 100, yMin: 0, yMax: 5 },
  radius: { xMin: -100, xMax: 100, yMin: 0, yMax: 100000 },
  speedCoef: { xMin: 0, xMax: 100, yMin: 0.5, yMax: 3.0 }
};

let speedMap = [
  {key: 0, value: 0}, {key: 10, value: 0.2}, {key: 20, value: 0.4},
  {key: 30, value: 1}, {key: 40, value: 1.5}, {key: 50, value: 2},
  {key: 60, value: 2.5}, {key: 70, value: 3}, {key: 80, value: 3.5},
  {key: 90, value: 4}, {key: 100, value: 5}
];
let radiusMap = [
  {key: -100, value: 3000}, {key: -75, value: 3800}, {key: -50, value: 5000},
  {key: -30, value: 8500}, {key: -20, value: 17000}, {key: -10, value: 42000},
  {key: 0, value: 100000},
  {key: 10, value: 42000}, {key: 20, value: 17000}, {key: 30, value: 8500},
  {key: 50, value: 5000}, {key: 75, value: 3800}, {key: 100, value: 3000}
];

// é€Ÿåº¦ä¾å­˜ä¿‚æ•°ãƒãƒƒãƒ—ï¼ˆThrottle% â†’ æ—‹å›åŠå¾„è£œæ­£ä¿‚æ•°ï¼‰
// ã‚¿ãƒŸãƒ¤ ã‚¨ã‚¢ãƒ­ãƒãƒ³ãƒ†ã®ç‰¹æ€§ï¼šä½é€Ÿã§ã¯èˆµè§’é€šã‚Šã€é«˜é€Ÿã§ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ãƒ†ã‚¢
let radiusSpeedCoefMap = [
  {key: 0,   value: 1.0},   // åœæ­¢ã€œæ¥µä½é€Ÿï¼šè¨­è¨ˆé€šã‚Š
  {key: 20,  value: 1.05},  // ä½é€Ÿï¼šã‚ãšã‹ã«ã‚¢ãƒ³ãƒ€ãƒ¼
  {key: 40,  value: 1.15},  // ä¸­ä½é€Ÿï¼šè»½ã„ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ãƒ†ã‚¢
  {key: 60,  value: 1.3},   // ä¸­é€Ÿï¼šæ˜ç¢ºãªã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ãƒ†ã‚¢
  {key: 80,  value: 1.5},   // é«˜é€Ÿï¼šå¼·ã„ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ãƒ†ã‚¢
  {key: 100, value: 1.8}    // æœ€é«˜é€Ÿï¼šéå¸¸ã«æ›²ãŒã‚Šã«ãã„
];

// ã‚»ãƒ³ã‚µãƒ¼ã”ã¨ã®è‰²å®šç¾©
const sensorColors = {
  'RrLH': {r: 255, g: 50, b: 150},   // ãƒ”ãƒ³ã‚¯
  'FrLH': {r: 100, g: 200, b: 255},  // æ°´è‰²
  'Fr': {r: 50, g: 255, b: 50},      // ç·‘
  'FrRH': {r: 255, g: 200, b: 50},   // é»„è‰²
  'RrRH': {r: 255, g: 100, b: 50}    // ã‚ªãƒ¬ãƒ³ã‚¸
};

// ã‚°ãƒ©ãƒ•é–¢é€£å¤‰æ•°
let speedGraph, radiusGraph, speedCoefGraph;
let speedCtx, radiusCtx, speedCoefCtx;
let controlGraph, controlCtx;
let isDragging = false;
let dragPoint = null;
let dragGraph = null;

// ãƒãƒƒãƒ—ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ç®¡ç†
let speedMapMode = 'graph'; // 'graph' or 'table'
let radiusMapMode = 'graph'; // 'graph' or 'table'
let speedCoefMapMode = 'graph'; // 'graph' or 'table'

// ãƒãƒ¼ã‚«ãƒ¼è¨­å®š
let markerSettings = {
  rule1: {  // ç‹­ã„é“åˆ¤å®šï¼ˆRrLH & RrRHï¼‰
    enabled: true,
    threshold: 300,  // mm
    color: '#808080',  // ã‚°ãƒ¬ãƒ¼
    name: 'ãƒ«ãƒ¼ãƒ«â‘  ç‹­ã„é“'
  },
  rule2: {  // æ“èˆµæŒ‡ç¤ºç¯„å›²
    enabled: true,
    minValue: 90,  // çµ¶å¯¾å€¤ã§ã®æœ€å°å€¤
    maxValue: 100, // çµ¶å¯¾å€¤ã§ã®æœ€å¤§å€¤
    color: '#FF6B6B',  // èµ¤ç³»
    name: 'ãƒ«ãƒ¼ãƒ«â‘¡ å¤§æ“èˆµ'
  },
  rule3: {  // é§†å‹•æŒ‡ç¤ºç¯„å›²
    enabled: true,
    minValue: 80,  // æœ€å°å€¤
    maxValue: 100, // æœ€å¤§å€¤
    color: '#4ECDC4',  // é’ç·‘ç³»
    name: 'ãƒ«ãƒ¼ãƒ«â‘¢ é«˜é§†å‹•'
  }
};

// ãƒãƒ¼ã‚«ãƒ¼å…±é€šè¨­å®š
let markerSize = 6;  // ã²ã—å½¢ã®ã‚µã‚¤ã‚ºï¼ˆåˆæœŸå€¤ã¯ä»¥å‰ã®åŠåˆ†ï¼‰

// ãƒãƒ¼ã‚«ãƒ¼ãƒ‡ãƒ¼ã‚¿ï¼ˆå„ãƒ«ãƒ¼ãƒ«ã”ã¨ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—ï¼‰
let markersByRule = {
  rule1: [],
  rule2: [],
  rule3: []
};

// æ³¨é‡ˆæ©Ÿèƒ½
let annotations = [];  // æ³¨é‡ˆãƒ‡ãƒ¼ã‚¿ã®é…åˆ—
let selectedAnnotation = null;  // é¸æŠä¸­ã®æ³¨é‡ˆ
let isDraggingAnnotation = false;  // æ³¨é‡ˆã‚’ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã‹ã©ã†ã‹
let annotationIdCounter = 0;  // æ³¨é‡ˆã®ãƒ¦ãƒ‹ãƒ¼ã‚¯IDç”Ÿæˆç”¨

// åˆæœŸåŒ–
document.addEventListener('DOMContentLoaded', function() {
  initializeGraphs();
  initializeControlGraph();
  initializeSensorGraph();
  setupEventListeners();
  setupAccordion();
  setupTableSidebar();
  setupControlGraphEvents();
  setupSensorGraphEvents();
  drawAllGraphs();
  updateSpeedTable();
  updateRadiusTable();
  updateSpeedCoefTable();
});

// ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
function setupTableSidebar() {
  const resizeHandle = document.getElementById('tableResizeHandle');
  const tableSidebar = document.getElementById('tableSidebar');
  
  // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã®ã‚¤ãƒ™ãƒ³ãƒˆ
  resizeHandle.addEventListener('mousedown', (e) => {
    isResizingTable = true;
    tableStartX = e.clientX;
    tableStartWidth = tableSidebar.offsetWidth;
    e.preventDefault();
  });
  
  document.addEventListener('mousemove', (e) => {
    if (isResizingTable) {
      const deltaX = tableStartX - e.clientX;
      const newWidth = Math.max(200, Math.min(800, tableStartWidth + deltaX));
      tableSidebar.style.width = newWidth + 'px';
    }
  });
  
  document.addEventListener('mouseup', () => {
    isResizingTable = false;
  });
}

// ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ãƒˆã‚°ãƒ«
function toggleTableSidebar() {
  const tableSidebar = document.getElementById('tableSidebar');
  const toggleBtn = document.getElementById('tableToggleBtn');
  isTableOpen = !isTableOpen;
  
  if (isTableOpen) {
    tableSidebar.classList.remove('closed');
    document.body.classList.remove('table-closed');
    toggleBtn.textContent = 'â—€';
  } else {
    tableSidebar.classList.add('closed');
    document.body.classList.add('table-closed');
    toggleBtn.textContent = 'â—€';
  }
}

// ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤ºã‚’æ›´æ–°
function updateTableDisplay() {
  if (!csvData.length) return;
  
  const headerRow = document.getElementById('tableHeaderRow');
  const tableBody = document.getElementById('tableBody');
  
  // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ä½œæˆ
  headerRow.innerHTML = '';
  headers.forEach(header => {
    const th = document.createElement('th');
    th.textContent = header;
    headerRow.appendChild(th);
  });
  
  // ãƒ‡ãƒ¼ã‚¿è¡Œã‚’ä½œæˆ
  tableBody.innerHTML = '';
  csvData.forEach((row, index) => {
    const tr = document.createElement('tr');
    tr.id = 'tableRow' + index;
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tableBody.appendChild(tr);
  });
  
  // ç¾åœ¨ã®è¡Œã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
  scrollToCurrentRow();
}

// ç¾åœ¨ã®è¡Œã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
function scrollToCurrentRow() {
  if (!csvData.length) return;
  
  const tableContainer = document.getElementById('tableContainer');
  const currentRow = document.getElementById('tableRow' + currentTimeIndex);
  
  // ã™ã¹ã¦ã®è¡Œã‹ã‚‰ current-row ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
  document.querySelectorAll('.data-table tr.current-row').forEach(row => {
    row.classList.remove('current-row');
  });
  
  if (currentRow) {
    currentRow.classList.add('current-row');
    
    // ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä¸­å¤®ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
    const containerHeight = tableContainer.clientHeight;
    const rowTop = currentRow.offsetTop;
    const rowHeight = currentRow.offsetHeight;
    const scrollTop = rowTop - (containerHeight / 2) + (rowHeight / 2);
    
    tableContainer.scrollTop = scrollTop;
  }
}

// ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³æ©Ÿèƒ½ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
function toggleAccordion(header) {
  const content = header.nextElementSibling;
  const icon = header.querySelector('.accordion-icon');
  
  content.classList.toggle('collapsed');
  
  if (content.classList.contains('collapsed')) {
    icon.textContent = 'â–¶';
  } else {
    icon.textContent = 'â–¼';
  }
}

function setupAccordion() {
  // control-groupã®ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³
  const controlHeaders = document.querySelectorAll('.control-group h3');
  controlHeaders.forEach(header => {
    header.addEventListener('click', function() {
      this.classList.toggle('collapsed');
      const content = this.nextElementSibling;
      content.classList.toggle('collapsed');
    });
  });
  
  // ãã®ä»–ã®ãƒ‘ãƒãƒ«ã®ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³
  const panelHeaders = document.querySelectorAll('.interactive-graph > h3, .map-quality-panel > h3, .stats-panel > h3');
  panelHeaders.forEach(header => {
    // h3ã®æ¬¡ã®è¦ç´ ä»¥é™ã‚’ã™ã¹ã¦panel-contentã§å›²ã‚€
    const panel = header.parentElement;
    const wrapper = document.createElement('div');
    wrapper.className = 'panel-content';
    
    // h3ã®æ¬¡ã®è¦ç´ ã‹ã‚‰å…¨ã¦ç§»å‹•
    let next = header.nextElementSibling;
    while (next) {
      const current = next;
      next = next.nextElementSibling;
      wrapper.appendChild(current);
    }
    
    panel.appendChild(wrapper);
    
    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
    header.addEventListener('click', function() {
      this.classList.toggle('collapsed');
      wrapper.classList.toggle('collapsed');
    });
  });
}

// ã‚°ãƒ©ãƒ•ç¯„å›²æ›´æ–°
function updateGraphRange() {
  graphRanges.speed.xMin = parseFloat(document.getElementById('speedXMin').value);
  graphRanges.speed.xMax = parseFloat(document.getElementById('speedXMax').value);
  graphRanges.speed.yMin = parseFloat(document.getElementById('speedYMin').value);
  graphRanges.speed.yMax = parseFloat(document.getElementById('speedYMax').value);
  
  graphRanges.radius.xMin = parseFloat(document.getElementById('radiusXMin').value);
  graphRanges.radius.xMax = parseFloat(document.getElementById('radiusXMax').value);
  graphRanges.radius.yMin = parseFloat(document.getElementById('radiusYMin').value);
  graphRanges.radius.yMax = parseFloat(document.getElementById('radiusYMax').value);
  
  graphRanges.speedCoef.xMin = parseFloat(document.getElementById('speedCoefXMin').value);
  graphRanges.speedCoef.xMax = parseFloat(document.getElementById('speedCoefXMax').value);
  graphRanges.speedCoef.yMin = parseFloat(document.getElementById('speedCoefYMin').value);
  graphRanges.speedCoef.yMax = parseFloat(document.getElementById('speedCoefYMax').value);
  
  drawAllGraphs();
}

// ã‚»ãƒ³ã‚µãƒ¼è§’åº¦æ›´æ–°
function updateSensorAngle(sensor, value) {
  sensorAngles[sensor] = parseFloat(value);
  document.getElementById(`angle${sensor}`).value = value;
  document.querySelector(`#angle${sensor}`).previousElementSibling.value = value;
  
  if (positions.length > 0) {
    drawTrack();
  }
}

// è»Šä¸¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ›´æ–°
function updateWheelbase(value) {
  wheelbase = parseFloat(value) / 1000;  // mmã‹ã‚‰mã«å¤‰æ›
  const numberInput = document.getElementById('wheelbaseValue');
  const rangeInput = document.querySelector('input[type="range"][oninput*="updateWheelbase"]');
  if (numberInput) numberInput.value = value;
  if (rangeInput) rangeInput.value = value;
  console.log(`ãƒ›ã‚¤ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹æ›´æ–°: ${value}mm = ${wheelbase}m`);
}

function recalculatePositions() {
  if (csvData.length > 0) {
    calculatePositions();
    drawTrack();
  }
}

// ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°
function updateSpeedScale(value) {
  speedScale = parseFloat(value);
  const numberInput = document.getElementById('speedScaleValue');
  const rangeInput = document.querySelector('input[type="range"][oninput*="updateSpeedScale"]');
  if (numberInput) numberInput.value = value;
  if (rangeInput) rangeInput.value = value;
  console.log(`é€Ÿåº¦ã‚¹ã‚±ãƒ¼ãƒ«æ›´æ–°: ${speedScale}`);
}

function updateRadiusGain(value) {
  radiusGain = parseFloat(value);
  const numberInput = document.getElementById('radiusGainValue');
  const rangeInput = document.querySelector('input[type="range"][oninput*="updateRadiusGain"]');
  if (numberInput) numberInput.value = value;
  if (rangeInput) rangeInput.value = value;
  console.log(`æ—‹å›åŠå¾„ã‚²ã‚¤ãƒ³æ›´æ–°: ${radiusGain}`);
}

function updateTimeScale(value) {
  timeScale = parseFloat(value);
  const numberInput = document.getElementById('timeScaleValue');
  const rangeInput = document.querySelector('input[type="range"][oninput*="updateTimeScale"]');
  if (numberInput) numberInput.value = value;
  if (rangeInput) rangeInput.value = value;
  console.log(`æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«æ›´æ–°: ${timeScale}`);
}

function resetCalibration() {
  speedScale = 1.0;
  steeringGain = 1.0;
  timeScale = 1.0;
  
  document.getElementById('speedScaleValue').value = 1.0;
  document.getElementById('steeringGainValue').value = 1.0;
  document.getElementById('timeScaleValue').value = 1.0;
  
  document.querySelectorAll('input[type="range"][oninput*="updateSpeedScale"]')[0].value = 1.0;
  document.querySelectorAll('input[type="range"][oninput*="updateSteeringGain"]')[0].value = 1.0;
  document.querySelectorAll('input[type="range"][oninput*="updateTimeScale"]')[0].value = 1.0;
  
  console.log('ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
  
  if (csvData.length > 0) {
    recalculatePositions();
  }
}

function showCourseReference() {
  showCourseRef = !showCourseRef;
  const btn = event.target;
  if (showCourseRef) {
    btn.textContent = 'âœ… å‚ç…§ç·šã‚’éè¡¨ç¤º';
    btn.style.background = 'linear-gradient(135deg, #8ac926, #6ba01e)';
  } else {
    btn.textContent = 'ğŸ“Š ã‚³ãƒ¼ã‚¹å‚ç…§ç·šã‚’è¡¨ç¤º';
    btn.style.background = '';
  }
  drawTrack();
}

function resetSpeedMap() {
  speedMap = [
    {key: 0, value: 0}, {key: 10, value: 0.2}, {key: 20, value: 0.4},
    {key: 30, value: 1}, {key: 40, value: 1.5}, {key: 50, value: 2},
    {key: 60, value: 2.5}, {key: 70, value: 3}, {key: 80, value: 3.5},
    {key: 90, value: 4}, {key: 100, value: 5}
  ];
  drawAllGraphs();
  updateSpeedTable();
  if (csvData.length > 0) {
    recalculatePositions();
  }
}

function resetRadiusMap() {
  radiusMap = [
    {key: -100, value: 3000}, {key: -75, value: 3800}, {key: -50, value: 5000},
    {key: -30, value: 8500}, {key: -20, value: 17000}, {key: -10, value: 42000},
    {key: 0, value: 100000},
    {key: 10, value: 42000}, {key: 20, value: 17000}, {key: 30, value: 8500},
    {key: 50, value: 5000}, {key: 75, value: 3800}, {key: 100, value: 3000}
  ];
  drawAllGraphs();
  updateRadiusTable();
  if (csvData.length > 0) {
    recalculatePositions();
  }
}

// ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿é–¢æ•°
function median(arr) {
  if (arr.length === 0) return 0;
  const sorted = [...arr].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
}

function applyMedianFilter() {
  if (!csvData.length) return;
  
  const windowSize = 5; // 5ç‚¹ã®ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿
  filteredData = csvData.map((row, i) => {
    const newRow = [...row];
    
    // å„ã‚»ãƒ³ã‚µãƒ¼åˆ—ã«ãƒ•ã‚£ãƒ«ã‚¿ã‚’é©ç”¨
    headers.forEach((header, idx) => {
      if (header === 'RrLH' || header === 'FrLH' || header === 'Fr' || header === 'FrRH' || header === 'RrRH') {
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’åé›†
        const window = [];
        for (let j = Math.max(0, i - Math.floor(windowSize / 2)); j <= Math.min(csvData.length - 1, i + Math.floor(windowSize / 2)); j++) {
          const val = parseFloat(csvData[j][idx]);
          if (!isNaN(val)) {
            window.push(val);
          }
        }
        // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ã‚’è¨ˆç®—
        newRow[idx] = median(window);
      }
    });
    
    return newRow;
  });
  
  console.log(`ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿é©ç”¨: ${filteredData.length}ç‚¹å‡¦ç†`);
}

function toggleMedianFilter() {
  medianFilterEnabled = !medianFilterEnabled;
  
  if (medianFilterEnabled && filteredData.length === 0) {
    applyMedianFilter();
  }
  
  console.log(`ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿åˆ‡ã‚Šæ›¿ãˆ: ${medianFilterEnabled ? 'ON' : 'OFF'}`);
  console.log(`filteredData.length: ${filteredData.length}, csvData.length: ${csvData.length}`);
  
  // ãƒãƒ¼ã‚«ãƒ¼ã‚’å†æ¤œå‡ºï¼ˆãƒ•ã‚£ãƒ«ã‚¿çŠ¶æ…‹ã«å¿œã˜ã¦ï¼‰
  if (csvData.length > 0) {
    detectAllMarkers();
    console.log('ãƒãƒ¼ã‚«ãƒ¼å†æ¤œå‡ºå®Œäº†');
  }
  
  // å†æç”»
  drawTrack();
  drawControlGraph();
  drawSensorGraph();
}

// æ³¨é‡ˆæ©Ÿèƒ½
function addAnnotation() {
  if (!positions.length || currentTimeIndex >= positions.length) {
    alert('ãƒ‡ãƒ¼ã‚¿ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„ã‹ã€ç„¡åŠ¹ãªä½ç½®ã§ã™');
    return;
  }
  
  const pos = positions[currentTimeIndex];
  
  // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ç”¨ã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’ä½œæˆ
  showAnnotationDialog('', (text) => {
    if (text === null || text.trim() === '') return;
    
    // æ³¨é‡ˆãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
    const annotation = {
      id: annotationIdCounter++,
      timeIndex: currentTimeIndex,
      vehicleX: pos.x,  // è»Šä¸¡ä½ç½®ï¼ˆmmï¼‰
      vehicleY: pos.y,
      offsetX: 100,  // æ³¨é‡ˆã®ç›¸å¯¾ä½ç½®ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
      offsetY: -100,
      text: text.trim(),
      opacity: 0.9,
      width: 200,  // æ³¨é‡ˆãƒœãƒƒã‚¯ã‚¹ã®å¹…
      height: 100   // æ³¨é‡ˆãƒœãƒƒã‚¯ã‚¹ã®é«˜ã•ï¼ˆ5è¡Œåˆ†ï¼‰
    };
    
    annotations.push(annotation);
    console.log(`æ³¨é‡ˆè¿½åŠ : ID=${annotation.id}, æ™‚åˆ»=${currentTimeIndex}`);
    drawTrack();
  });
}

function editAnnotation(annotation) {
  showAnnotationDialog(annotation.text, (newText) => {
    if (newText !== null && newText.trim() !== '') {
      annotation.text = newText.trim();
      drawTrack();
    }
  });
}

// æ³¨é‡ˆå…¥åŠ›ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ï¼ˆæ”¹è¡Œå¯¾å¿œï¼‰
function showAnnotationDialog(initialText, callback) {
  // æ—¢å­˜ã®ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒã‚ã‚Œã°å‰Šé™¤
  const existingDialog = document.getElementById('annotationDialog');
  if (existingDialog) {
    existingDialog.remove();
  }
  
  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’ä½œæˆ
  const dialog = document.createElement('div');
  dialog.id = 'annotationDialog';
  dialog.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(30, 30, 30, 0.95);
    padding: 20px;
    border-radius: 10px;
    border: 2px solid #ffd700;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    z-index: 10000;
    min-width: 400px;
  `;
  
  dialog.innerHTML = `
    <div style="color: #ffd700; font-size: 16px; font-weight: bold; margin-bottom: 5px;">ğŸ“ æ³¨é‡ˆãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›</div>
    <div style="color: rgba(255,255,255,0.6); font-size: 12px; margin-bottom: 10px;">Enterã§æ”¹è¡Œã€Ctrl+Enterã§æ±ºå®š</div>
    <textarea id="annotationTextarea" style="
      width: 100%;
      height: 120px;
      padding: 10px;
      border: 1px solid #666;
      border-radius: 5px;
      background: rgba(50, 50, 50, 0.9);
      color: white;
      font-size: 14px;
      font-family: Arial, sans-serif;
      resize: vertical;
    ">${initialText}</textarea>
    <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: flex-end;">
      <button id="annotationCancelBtn" style="
        padding: 8px 20px;
        border: none;
        border-radius: 5px;
        background: #666;
        color: white;
        cursor: pointer;
        font-size: 14px;
      ">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
      <button id="annotationOkBtn" style="
        padding: 8px 20px;
        border: none;
        border-radius: 5px;
        background: linear-gradient(45deg, #ffd700, #ff8c00);
        color: white;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
      ">OK</button>
    </div>
  `;
  
  document.body.appendChild(dialog);
  
  const textarea = document.getElementById('annotationTextarea');
  const okBtn = document.getElementById('annotationOkBtn');
  const cancelBtn = document.getElementById('annotationCancelBtn');
  
  // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’å½“ã¦ã‚‹
  textarea.focus();
  textarea.setSelectionRange(textarea.value.length, textarea.value.length);
  
  // OKãƒœã‚¿ãƒ³
  okBtn.onclick = () => {
    callback(textarea.value);
    dialog.remove();
  };
  
  // ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³
  cancelBtn.onclick = () => {
    callback(null);
    dialog.remove();
  };
  
  // Enterã‚­ãƒ¼ï¼ˆCtrl+Enterã§æ±ºå®šï¼‰
  textarea.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.ctrlKey) {
      e.preventDefault();
      okBtn.click();
    }
  });
}

function deleteAnnotation(annotation) {
  if (confirm('ã“ã®æ³¨é‡ˆã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
    const index = annotations.indexOf(annotation);
    if (index > -1) {
      annotations.splice(index, 1);
      selectedAnnotation = null;
      drawTrack();
    }
  }
}

function adjustAnnotationOpacity(annotation, delta) {
  annotation.opacity = Math.max(0.1, Math.min(1.0, annotation.opacity + delta));
  drawTrack();
}

// å¯†åº¦ã¨ã‚µã‚¤ã‚ºèª¿æ•´
function updateDensity(value) {
  sensorDensity = parseInt(value);
  document.getElementById('densityValue').textContent = value;
  drawTrack();
}

function updatePointSize(value) {
  sensorPointSize = parseInt(value);
  document.getElementById('sizeValue').textContent = value + 'px';
  // ãƒ—ãƒ­ãƒƒãƒˆã‚µã‚¤ã‚ºã«å¿œã˜ã¦è»Šä¸¡ã‚µã‚¤ã‚ºã‚‚èª¿æ•´ï¼ˆåŸºæœ¬1.8å€ã€ãƒ—ãƒ­ãƒƒãƒˆã‚µã‚¤ã‚º4ã‚’åŸºæº–ã«æ¯”ä¾‹ï¼‰
  vehicleSizeMultiplier = 1.8 * (sensorPointSize / 4);
  drawTrack();
}

function updateLineWidth(value) {
  sensorLineWidth = parseFloat(value);
  document.getElementById('lineWidthValue').textContent = value + 'px';
  drawTrack();
}

function updatePastPlots(value) {
  pastPlotsCount = parseInt(value);
  document.getElementById('pastPlotsValue').textContent = value;
  drawTrack();
}

function updateFuturePlots(value) {
  futurePlotsCount = parseInt(value);
  document.getElementById('futurePlotsValue').textContent = value + (value === 0 ? ' (å…¨åŒºé–“)' : '');
  drawTrack();
}

// ãƒãƒƒãƒ—æ“ä½œé–¢æ•°
function updateZoom(value) {
  mapZoom = parseFloat(value);
  document.getElementById('zoomValue').textContent = value + 'x';
  drawTrack();
}

function updateRotation(value) {
  mapRotation = parseFloat(value) * Math.PI / 180;
  document.getElementById('rotationValue').textContent = value + 'Â°';
  drawTrack();
}

function resetView() {
  mapZoom = 1.0;
  mapOffsetX = 0;
  mapOffsetY = 0;
  mapRotation = 0;
  document.getElementById('zoomSlider').value = 1.0;
  document.getElementById('zoomValue').textContent = '1.0x';
  document.getElementById('rotationSlider').value = 0;
  document.getElementById('rotationValue').textContent = '0Â°';
  drawTrack();
}

function resetRotation() {
  mapRotation = 0;
  document.getElementById('rotationSlider').value = 0;
  document.getElementById('rotationValue').textContent = '0Â°';
  drawTrack();
}

// ãƒãƒ¼ã‚«ãƒ¼è¨­å®šé–¢æ•°ï¼ˆæ±ç”¨ï¼‰
function toggleMarker(rule, enabled) {
  markerSettings[rule].enabled = enabled;
  if (enabled && csvData.length > 0) {
    detectAllMarkers();
  }
  drawTrack();
}

function updateMarkerSize(value) {
  markerSize = parseFloat(value);
  document.getElementById('markerSizeValue').textContent = value;
  drawTrack();
}

function updateMarkerThreshold(rule, value) {
  markerSettings[rule].threshold = parseFloat(value);
  document.getElementById(`${rule}ThresholdValue`).textContent = value;
  if (markerSettings[rule].enabled && csvData.length > 0) {
    detectAllMarkers();
    drawTrack();
  }
}

function updateMarkerRange(rule) {
  const minValue = parseFloat(document.getElementById(`${rule}MinValue`).value);
  const maxValue = parseFloat(document.getElementById(`${rule}MaxValue`).value);
  markerSettings[rule].minValue = minValue;
  markerSettings[rule].maxValue = maxValue;
  if (markerSettings[rule].enabled && csvData.length > 0) {
    detectAllMarkers();
    drawTrack();
  }
}

function updateMarkerColor(rule, color) {
  markerSettings[rule].color = color;
  drawTrack();
}

// å…¨ãƒãƒ¼ã‚«ãƒ¼ã‚’æ¤œå‡º
function detectAllMarkers() {
  console.log('=== detectAllMarkersé–‹å§‹ ===');
  console.log(`medianFilterEnabled: ${medianFilterEnabled}`);
  console.log(`filteredData.length: ${filteredData.length}`);
  console.log(`csvData.length: ${csvData.length}`);
  
  // åˆæœŸåŒ–
  markersByRule = {
    rule1: [],
    rule2: [],
    rule3: []
  };
  
  if (!csvData || csvData.length === 0 || !headers) {
    console.log('csvDataã¾ãŸã¯headersãŒç©ºã§ã™');
    return;
  }
  
  // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãŒæœ‰åŠ¹ãªå ´åˆã¯ãƒ•ã‚£ãƒ«ã‚¿æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
  const useFilteredData = medianFilterEnabled && filteredData.length > 0;
  const dataSource = useFilteredData ? filteredData : csvData;
  
  console.log(`ä½¿ç”¨ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹: ${useFilteredData ? 'filteredData' : 'csvData'} (${dataSource.length}è¡Œ)`);
  
  // ãƒ«ãƒ¼ãƒ«â‘  ç‹­ã„é“åˆ¤å®šï¼ˆRrLH & RrRHï¼‰
  if (markerSettings.rule1.enabled) {
    const rrLhIdx = headers.indexOf('RrLH');
    const rrRhIdx = headers.indexOf('RrRH');
    
    if (rrLhIdx !== -1 && rrRhIdx !== -1) {
      const threshold = markerSettings.rule1.threshold;
      dataSource.forEach((row, i) => {
        const rrLh = parseFloat(row[rrLhIdx]);
        const rrRh = parseFloat(row[rrRhIdx]);
        
        if (!isNaN(rrLh) && !isNaN(rrRh) && rrLh <= threshold && rrRh <= threshold) {
          markersByRule.rule1.push(i);
        }
      });
    }
  }
  
  // ãƒ«ãƒ¼ãƒ«â‘¡ æ“èˆµæŒ‡ç¤ºç¯„å›²
  if (markerSettings.rule2.enabled) {
    const strIdx = headers.indexOf('Str');
    
    if (strIdx !== -1) {
      const minVal = markerSettings.rule2.minValue;
      const maxVal = markerSettings.rule2.maxValue;
      
      dataSource.forEach((row, i) => {
        const str = parseFloat(row[strIdx]);
        const absStr = Math.abs(str);
        
        if (!isNaN(str) && absStr >= minVal && absStr <= maxVal) {
          markersByRule.rule2.push(i);
        }
      });
    }
  }
  
  // ãƒ«ãƒ¼ãƒ«â‘¢ é§†å‹•æŒ‡ç¤ºç¯„å›²
  if (markerSettings.rule3.enabled) {
    const thrIdx = headers.indexOf('Thr');
    
    if (thrIdx !== -1) {
      const minVal = markerSettings.rule3.minValue;
      const maxVal = markerSettings.rule3.maxValue;
      
      dataSource.forEach((row, i) => {
        const thr = parseFloat(row[thrIdx]);
        
        if (!isNaN(thr) && thr >= minVal && thr <= maxVal) {
          markersByRule.rule3.push(i);
        }
      });
    }
  }
  
  const filterStatus = useFilteredData ? 'ãƒ•ã‚£ãƒ«ã‚¿æ¸ˆã¿' : 'å…ƒãƒ‡ãƒ¼ã‚¿';
  console.log(`ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡ºçµæœ(${filterStatus}): ãƒ«ãƒ¼ãƒ«â‘ =${markersByRule.rule1.length}, ãƒ«ãƒ¼ãƒ«â‘¡=${markersByRule.rule2.length}, ãƒ«ãƒ¼ãƒ«â‘¢=${markersByRule.rule3.length}`);
  
  // ãƒ«ãƒ¼ãƒ«â‘ ã®æœ€åˆã®5å€‹ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
  if (markersByRule.rule1.length > 0) {
    console.log(`ãƒ«ãƒ¼ãƒ«â‘ ã®æœ€åˆã®5å€‹: [${markersByRule.rule1.slice(0, 5).join(', ')}]`);
  }
  
  console.log('=== detectAllMarkersçµ‚äº† ===');
}

// åˆ¶å¾¡ã‚°ãƒ©ãƒ•åˆæœŸåŒ–
function initializeControlGraph() {
  controlGraph = document.getElementById('controlGraph');
  if (controlGraph) {
    controlCtx = controlGraph.getContext('2d');
    const container = controlGraph.parentElement;
    const rect = container.getBoundingClientRect();
    controlGraph.width = rect.width;
    controlGraph.height = 150;
  }
}

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•åˆæœŸåŒ–
function initializeSensorGraph() {
  sensorGraph = document.getElementById('sensorGraph');
  if (sensorGraph) {
    sensorCtx = sensorGraph.getContext('2d');
    const container = sensorGraph.parentElement;
    const rect = container.getBoundingClientRect();
    sensorGraph.width = rect.width;
    sensorGraph.height = 200;
  }
}

// åˆ¶å¾¡ã‚°ãƒ©ãƒ•ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
function setupControlGraphEvents() {
  const container = document.getElementById('controlGraphContainer');
  if (!container) return;
  
  // ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³
  container.addEventListener('mousedown', (e) => {
    isDraggingControlGraph = true;
    controlGraphDragStartX = e.clientX;
    controlGraphDragStartY = e.clientY;
    container.classList.add('dragging');
  });
  
  // ãƒã‚¦ã‚¹ç§»å‹•
  container.addEventListener('mousemove', (e) => {
    if (!isDraggingControlGraph) return;
    
    const deltaX = e.clientX - controlGraphDragStartX;
    const deltaY = e.clientY - controlGraphDragStartY;
    
    controlGraphOffsetX += deltaX;
    controlGraphOffsetY += deltaY;
    
    controlGraphDragStartX = e.clientX;
    controlGraphDragStartY = e.clientY;
    
    drawControlGraph();
  });
  
  // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—
  const handleMouseUp = () => {
    isDraggingControlGraph = false;
    container.classList.remove('dragging');
  };
  
  container.addEventListener('mouseup', handleMouseUp);
  container.addEventListener('mouseleave', handleMouseUp);
  
  // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«
  container.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = -Math.sign(e.deltaY) * 0.1;
    
    if (controlGraphZoomMode === 'x') {
      controlGraphZoomX = Math.max(0.5, Math.min(10, controlGraphZoomX + delta));
    } else if (controlGraphZoomMode === 'y') {
      controlGraphZoomY = Math.max(0.5, Math.min(10, controlGraphZoomY + delta));
    } else {
      controlGraphZoomX = Math.max(0.5, Math.min(10, controlGraphZoomX + delta));
      controlGraphZoomY = Math.max(0.5, Math.min(10, controlGraphZoomY + delta));
    }
    drawControlGraph();
  });
}

// ã‚ºãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
function setControlGraphZoomMode(mode) {
  controlGraphZoomMode = mode;
  
  // ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
  document.querySelectorAll('.zoom-mode-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  
  if (mode === 'x') {
    document.getElementById('zoomModeX').classList.add('active');
  } else if (mode === 'y') {
    document.getElementById('zoomModeY').classList.add('active');
  } else {
    document.getElementById('zoomModeBoth').classList.add('active');
  }
}

// åˆ¶å¾¡ã‚°ãƒ©ãƒ•ã®ã‚ºãƒ¼ãƒ ãƒ»ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½
function zoomInControlGraph() {
  const delta = 0.2;
  if (controlGraphZoomMode === 'x') {
    controlGraphZoomX = Math.min(10, controlGraphZoomX + delta);
  } else if (controlGraphZoomMode === 'y') {
    controlGraphZoomY = Math.min(10, controlGraphZoomY + delta);
  } else {
    controlGraphZoomX = Math.min(10, controlGraphZoomX + delta);
    controlGraphZoomY = Math.min(10, controlGraphZoomY + delta);
  }
  drawControlGraph();
}

function zoomOutControlGraph() {
  const delta = 0.2;
  if (controlGraphZoomMode === 'x') {
    controlGraphZoomX = Math.max(0.5, controlGraphZoomX - delta);
  } else if (controlGraphZoomMode === 'y') {
    controlGraphZoomY = Math.max(0.5, controlGraphZoomY - delta);
  } else {
    controlGraphZoomX = Math.max(0.5, controlGraphZoomX - delta);
    controlGraphZoomY = Math.max(0.5, controlGraphZoomY - delta);
  }
  drawControlGraph();
}

function resetControlGraphView() {
  controlGraphZoomX = 1.0;
  controlGraphZoomY = 1.0;
  controlGraphOffsetX = 0;
  controlGraphOffsetY = 0;
  drawControlGraph();
}

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
function setupSensorGraphEvents() {
  const container = document.getElementById('sensorGraphContainer');
  if (!container) return;
  
  // ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³
  container.addEventListener('mousedown', (e) => {
    isDraggingSensorGraph = true;
    sensorGraphDragStartX = e.clientX;
    sensorGraphDragStartY = e.clientY;
    container.classList.add('dragging');
  });
  
  // ãƒã‚¦ã‚¹ç§»å‹•
  container.addEventListener('mousemove', (e) => {
    if (!isDraggingSensorGraph) return;
    
    const deltaX = e.clientX - sensorGraphDragStartX;
    const deltaY = e.clientY - sensorGraphDragStartY;
    
    sensorGraphOffsetX += deltaX;
    sensorGraphOffsetY += deltaY;
    
    sensorGraphDragStartX = e.clientX;
    sensorGraphDragStartY = e.clientY;
    
    drawSensorGraph();
  });
  
  // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—
  const handleMouseUp = () => {
    if (isDraggingSensorGraph) {
      isDraggingSensorGraph = false;
      container.classList.remove('dragging');
    }
  };
  
  container.addEventListener('mouseup', handleMouseUp);
  container.addEventListener('mouseleave', handleMouseUp);
  
  // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«
  container.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = -Math.sign(e.deltaY) * 0.1;
    
    if (sensorGraphZoomMode === 'x') {
      sensorGraphZoomX = Math.max(0.5, Math.min(10, sensorGraphZoomX + delta));
    } else if (sensorGraphZoomMode === 'y') {
      sensorGraphZoomY = Math.max(0.5, Math.min(10, sensorGraphZoomY + delta));
    } else {
      sensorGraphZoomX = Math.max(0.5, Math.min(10, sensorGraphZoomX + delta));
      sensorGraphZoomY = Math.max(0.5, Math.min(10, sensorGraphZoomY + delta));
    }
    drawSensorGraph();
  });
}

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•ã®ã‚ºãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
function setSensorGraphZoomMode(mode) {
  sensorGraphZoomMode = mode;
  
  document.querySelectorAll('#sensorZoomModeX, #sensorZoomModeY, #sensorZoomModeBoth').forEach(btn => {
    btn.classList.remove('active');
  });
  
  if (mode === 'x') {
    document.getElementById('sensorZoomModeX').classList.add('active');
  } else if (mode === 'y') {
    document.getElementById('sensorZoomModeY').classList.add('active');
  } else {
    document.getElementById('sensorZoomModeBoth').classList.add('active');
  }
}

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•ã®ã‚ºãƒ¼ãƒ ãƒ»ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½
function zoomInSensorGraph() {
  const delta = 0.2;
  if (sensorGraphZoomMode === 'x') {
    sensorGraphZoomX = Math.min(10, sensorGraphZoomX + delta);
  } else if (sensorGraphZoomMode === 'y') {
    sensorGraphZoomY = Math.min(10, sensorGraphZoomY + delta);
  } else {
    sensorGraphZoomX = Math.min(10, sensorGraphZoomX + delta);
    sensorGraphZoomY = Math.min(10, sensorGraphZoomY + delta);
  }
  drawSensorGraph();
}

function zoomOutSensorGraph() {
  const delta = 0.2;
  if (sensorGraphZoomMode === 'x') {
    sensorGraphZoomX = Math.max(0.5, sensorGraphZoomX - delta);
  } else if (sensorGraphZoomMode === 'y') {
    sensorGraphZoomY = Math.max(0.5, sensorGraphZoomY - delta);
  } else {
    sensorGraphZoomX = Math.max(0.5, sensorGraphZoomX - delta);
    sensorGraphZoomY = Math.max(0.5, sensorGraphZoomY - delta);
  }
  drawSensorGraph();
}

function resetSensorGraphView() {
  sensorGraphZoomX = 1.0;
  sensorGraphZoomY = 1.0;
  sensorGraphOffsetX = 0;
  sensorGraphOffsetY = 0;
  drawSensorGraph();
}

// ã‚°ãƒ©ãƒ•åˆæœŸåŒ–
function initializeGraphs() {
  speedGraph = document.getElementById('speedGraph');
  radiusGraph = document.getElementById('radiusGraph');
  speedCoefGraph = document.getElementById('speedCoefGraph');
  speedCtx = speedGraph.getContext('2d');
  radiusCtx = radiusGraph.getContext('2d');
  speedCoefCtx = speedCoefGraph.getContext('2d');
  
  const container = document.getElementById('speedGraphContainer');
  const rect = container.getBoundingClientRect();
  speedGraph.width = rect.width;
  speedGraph.height = 240;
  radiusGraph.width = rect.width;
  radiusGraph.height = 240;
  speedCoefGraph.width = rect.width;
  speedCoefGraph.height = 240;
  
  setupGraphEvents();
}

// ã‚°ãƒ©ãƒ•ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
function setupGraphEvents() {
  speedGraph.addEventListener('mousedown', (e) => handleGraphMouseDown(e, 'speed'));
  speedGraph.addEventListener('mousemove', (e) => handleGraphMouseMove(e, 'speed'));
  speedGraph.addEventListener('mouseup', (e) => handleGraphMouseUp(e, 'speed'));
  speedGraph.addEventListener('dblclick', (e) => handleGraphDoubleClick(e, 'speed'));
  
  radiusGraph.addEventListener('mousedown', (e) => handleGraphMouseDown(e, 'radius'));
  radiusGraph.addEventListener('mousemove', (e) => handleGraphMouseMove(e, 'radius'));
  radiusGraph.addEventListener('mouseup', (e) => handleGraphMouseUp(e, 'radius'));
  radiusGraph.addEventListener('dblclick', (e) => handleGraphDoubleClick(e, 'radius'));
  
  speedCoefGraph.addEventListener('mousedown', (e) => handleGraphMouseDown(e, 'speedCoef'));
  speedCoefGraph.addEventListener('mousemove', (e) => handleGraphMouseMove(e, 'speedCoef'));
  speedCoefGraph.addEventListener('mouseup', (e) => handleGraphMouseUp(e, 'speedCoef'));
  speedCoefGraph.addEventListener('dblclick', (e) => handleGraphDoubleClick(e, 'speedCoef'));
}

// ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
function setupEventListeners() {
  document.getElementById('csvFile').addEventListener('change', handleCSVUpload);
  document.querySelectorAll('.sensorCheckbox').forEach(cb => {
    cb.addEventListener('change', drawTrack);
  });
  
  const timeSlider = document.getElementById('timeSlider');
  timeSlider.addEventListener('input', function() {
    currentTimeIndex = parseInt(this.value);
    updateTimeDisplay();
    drawTrack();
  });
  
  // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
  const trackCanvas = document.getElementById('trackCanvas');
  trackCanvas.addEventListener('mousedown', handleCanvasMouseDown);
  trackCanvas.addEventListener('mousemove', handleCanvasMouseMove);
  trackCanvas.addEventListener('mouseup', handleCanvasMouseUp);
  trackCanvas.addEventListener('wheel', handleCanvasWheel);
  trackCanvas.addEventListener('mouseleave', handleCanvasMouseUp);
  
  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ³¨é‡ˆæ“ä½œç”¨ï¼‰
  document.addEventListener('keydown', (e) => {
    if (!selectedAnnotation) return;
    
    if (e.key === 'e' || e.key === 'E') {
      e.preventDefault();
      editAnnotation(selectedAnnotation);
    } else if (e.key === 'd' || e.key === 'D' || e.key === 'Delete') {
      e.preventDefault();
      deleteAnnotation(selectedAnnotation);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      adjustAnnotationOpacity(selectedAnnotation, 0.1);
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      adjustAnnotationOpacity(selectedAnnotation, -0.1);
    }
  });
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³å‡¦ç†
function handleCanvasMouseDown(e) {
  if (!positions.length) return;
  
  const canvas = e.target;
  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;
  
  // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ç¢ºèª
  if (canvas.medianBtnBounds) {
    const btn = canvas.medianBtnBounds;
    if (clickX >= btn.x && clickX <= btn.x + btn.width &&
        clickY >= btn.y && clickY <= btn.y + btn.height) {
      toggleMedianFilter();
      return;
    }
  }
  
  // æ³¨é‡ˆã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ç¢ºèª
  let clickedAnnotation = null;
  for (let i = annotations.length - 1; i >= 0; i--) {
    const ann = annotations[i];
    if (ann._canvasBounds) {
      const bounds = ann._canvasBounds;
      if (clickX >= bounds.x && clickX <= bounds.x + bounds.width &&
          clickY >= bounds.y && clickY <= bounds.y + bounds.height) {
        clickedAnnotation = ann;
        break;
      }
    }
  }
  
  if (clickedAnnotation) {
    selectedAnnotation = clickedAnnotation;
    isDraggingAnnotation = true;
    dragStartX = clickX;
    dragStartY = clickY;
    canvas.style.cursor = 'move';
    drawTrack();
    return;
  }
  
  // æ³¨é‡ˆä»¥å¤–ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰é¸æŠè§£é™¤
  if (selectedAnnotation) {
    selectedAnnotation = null;
    drawTrack();
  }
  
  // ã‚³ãƒ³ãƒ‘ã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ç¢ºèª
  const compassRadius = 40;
  const compassCenterX = canvas.width - 80;
  const compassCenterY = 80;
  const distToCompass = Math.sqrt((clickX - compassCenterX) ** 2 + (clickY - compassCenterY) ** 2);
  
  if (distToCompass <= compassRadius) {
    isDraggingCompass = true;
    compassX = compassCenterX;
    compassY = compassCenterY;
    canvas.classList.add('dragging');
    return;
  }
  
  // å†ç”Ÿä¸­ã¯è»Šä¸¡ãƒ‰ãƒ©ãƒƒã‚°ã®ã¿ç„¡åŠ¹ã€ãƒ‘ãƒ³æ“ä½œã¯æœ‰åŠ¹
  if (isPlaying) {
    // å†ç”Ÿä¸­ã¯ãƒãƒƒãƒ—ãƒ‰ãƒ©ãƒƒã‚°ã®ã¿è¨±å¯
    isDraggingMap = true;
    dragStartX = clickX;
    dragStartY = clickY;
    canvas.classList.add('dragging');
    return;
  }
  
  // è‡ªè»Šãƒ—ãƒ­ãƒƒãƒˆã¾ãŸã¯è»Œè·¡ãƒ©ã‚¤ãƒ³è¿‘ãã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ç¢ºèª
  const clickThreshold = 20; // ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã®é–¾å€¤ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
  let nearVehicleOrTrack = false;
  
  // ç¾åœ¨ã®è»Šä¸¡ä½ç½®ã¨ã®è·é›¢ã‚’ãƒã‚§ãƒƒã‚¯
  if (currentTimeIndex < positions.length) {
    const currentPos = positions[currentTimeIndex];
    const transformedPos = applyTransform(currentPos.x, currentPos.y);
    const distToVehicle = Math.sqrt((clickX - transformedPos.x) ** 2 + (clickY - transformedPos.y) ** 2);
    
    if (distToVehicle <= clickThreshold * 2) {
      nearVehicleOrTrack = true;
    }
  }
  
  // è»Œè·¡ãƒ©ã‚¤ãƒ³ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
  if (!nearVehicleOrTrack) {
    for (let i = 0; i < Math.min(currentTimeIndex, positions.length - 1); i++) {
      const p1 = positions[i];
      const p2 = positions[i + 1];
      const tp1 = applyTransform(p1.x, p1.y);
      const tp2 = applyTransform(p2.x, p2.y);
      
      const distToLine = pointToLineDistance(clickX, clickY, tp1.x, tp1.y, tp2.x, tp2.y);
      
      if (distToLine <= clickThreshold) {
        nearVehicleOrTrack = true;
        break;
      }
    }
  }
  
  if (nearVehicleOrTrack) {
    // è‡ªè»Šãƒ—ãƒ­ãƒƒãƒˆã¾ãŸã¯ãƒ©ã‚¤ãƒ³ä¸Šï¼šè»Šä¸¡ãƒ‰ãƒ©ãƒƒã‚°
    isDraggingVehicle = true;
    updateVehiclePositionFromMouse(clickX, clickY);
  } else {
    // ãã‚Œä»¥å¤–ï¼šãƒãƒƒãƒ—ãƒ‰ãƒ©ãƒƒã‚°
    isDraggingMap = true;
    dragStartX = clickX;
    dragStartY = clickY;
    canvas.classList.add('dragging');
  }
}

// ç‚¹ã‹ã‚‰ç·šåˆ†ã¸ã®æœ€çŸ­è·é›¢ã‚’è¨ˆç®—
function pointToLineDistance(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  
  let xx, yy;
  
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }
  
  const dx = px - xx;
  const dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒã‚¦ã‚¹ç§»å‹•å‡¦ç†
function handleCanvasMouseMove(e) {
  if (!positions.length && !isDraggingCompass) return;
  
  const canvas = e.target;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  // ãƒ›ãƒãƒ¼ä¸­ã®æ³¨é‡ˆã‚’ç¢ºèªï¼ˆãƒ‰ãƒ©ãƒƒã‚°ä¸­ã§ãªã„å ´åˆï¼‰
  if (!isDraggingAnnotation && !isDraggingMap && !isDraggingCompass && !isDraggingVehicle) {
    let hovering = false;
    for (let i = annotations.length - 1; i >= 0; i--) {
      const ann = annotations[i];
      if (ann._canvasBounds) {
        const bounds = ann._canvasBounds;
        if (mouseX >= bounds.x && mouseX <= bounds.x + bounds.width &&
            mouseY >= bounds.y && mouseY <= bounds.y + bounds.height) {
          hovering = true;
          break;
        }
      }
    }
    canvas.style.cursor = hovering ? 'pointer' : 'default';
  }
  
  if (isDraggingAnnotation && selectedAnnotation) {
    // æ³¨é‡ˆãƒ‰ãƒ©ãƒƒã‚°
    const deltaX = mouseX - dragStartX;
    const deltaY = mouseY - dragStartY;
    selectedAnnotation.offsetX += deltaX;
    selectedAnnotation.offsetY += deltaY;
    dragStartX = mouseX;
    dragStartY = mouseY;
    drawTrack();
  } else if (isDraggingCompass) {
    // ã‚³ãƒ³ãƒ‘ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ï¼šãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰ã®è§’åº¦ã‚’è¨ˆç®—
    const dx = mouseX - compassX;
    const dy = mouseY - compassY;
    const angle = Math.atan2(dy, dx);
    // atan2ã¯-Ï€ã‹ã‚‰Ï€ãªã®ã§ã€0ã‹ã‚‰2Ï€ã«å¤‰æ›ã—ã¦ã‹ã‚‰åº¦ã«å¤‰æ›
    let degrees = ((angle * 180 / Math.PI) + 90 + 360) % 360;
    mapRotation = degrees * Math.PI / 180;
    document.getElementById('rotationSlider').value = degrees;
    document.getElementById('rotationValue').textContent = degrees.toFixed(0) + 'Â°';
    drawTrack();
  } else if (isDraggingMap) {
    const deltaX = mouseX - dragStartX;
    const deltaY = mouseY - dragStartY;
    mapOffsetX += deltaX;
    mapOffsetY += deltaY;
    dragStartX = mouseX;
    dragStartY = mouseY;
    drawTrack();
  } else if (isDraggingVehicle && !isPlaying) {
    updateVehiclePositionFromMouse(mouseX, mouseY);
  }
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—å‡¦ç†
function handleCanvasMouseUp(e) {
  const canvas = document.getElementById('trackCanvas');
  isDraggingMap = false;
  isDraggingVehicle = false;
  isDraggingCompass = false;
  isDraggingAnnotation = false;
  canvas.classList.remove('dragging');
  canvas.style.cursor = 'default';
}

// ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ 
function handleCanvasWheel(e) {
  e.preventDefault();
  const delta = -Math.sign(e.deltaY) * 0.1;
  mapZoom = Math.max(0.1, Math.min(10, mapZoom + delta));
  document.getElementById('zoomSlider').value = mapZoom;
  document.getElementById('zoomValue').textContent = mapZoom.toFixed(1) + 'x';
  drawTrack();
}

// ãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰æœ€ã‚‚è¿‘ã„è»Šä¸¡ä½ç½®ã‚’æ›´æ–°ï¼ˆã‚ºãƒ¼ãƒ å¯¾å¿œç‰ˆï¼‰
function updateVehiclePositionFromMouse(mouseX, mouseY) {
  if (!positions.length) return;
  
  let minDistance = Infinity;
  let nearestIndex = 0;
  
  // ã™ã¹ã¦ã®ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã¯é‡ã„ã®ã§ã€ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¦é«˜é€ŸåŒ–
  const step = Math.max(1, Math.floor(positions.length / 500));
    
  for (let i = 0; i < positions.length; i += step) {
    const transformedPos = applyTransform(positions[i].x, positions[i].y);
    const distance = Math.sqrt((mouseX - transformedPos.x) ** 2 + (mouseY - transformedPos.y) ** 2);
    
    if (distance < minDistance) {
      minDistance = distance;
      nearestIndex = i;
    }
  }
  
  // å‘¨è¾ºã‚’ç´°ã‹ããƒã‚§ãƒƒã‚¯
  const searchRange = Math.min(50, positions.length);
  const startIdx = Math.max(0, nearestIndex - searchRange);
  const endIdx = Math.min(positions.length - 1, nearestIndex + searchRange);
  
  for (let i = startIdx; i <= endIdx; i++) {
    const transformedPos = applyTransform(positions[i].x, positions[i].y);
    const distance = Math.sqrt((mouseX - transformedPos.x) ** 2 + (mouseY - transformedPos.y) ** 2);
    
    if (distance < minDistance) {
      minDistance = distance;
      nearestIndex = i;
    }
  }
  
  currentTimeIndex = nearestIndex;
  document.getElementById('timeSlider').value = currentTimeIndex;
  updateTimeDisplay();
  drawTrack();
}

// åº§æ¨™å¤‰æ›ï¼ˆã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³ãƒ»å›è»¢ã‚’é©ç”¨ï¼‰
function applyTransform(x, y) {
  const { minX, minY, scale, margin, centerX, centerY } = canvasScaleInfo;
  
  // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‹ã‚‰ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã¸ã®åŸºæœ¬å¤‰æ›
  let cx = margin + (x - minX) * scale;
  let cy = margin + (y - minY) * scale;
  
  // ä¸­å¿ƒã‚’åŸç‚¹ã¨ã™ã‚‹åº§æ¨™ç³»ã«å¤‰æ›
  cx -= centerX;
  cy -= centerY;
  
  // å›è»¢ã‚’é©ç”¨
  const rotatedX = cx * Math.cos(mapRotation) - cy * Math.sin(mapRotation);
  const rotatedY = cx * Math.sin(mapRotation) + cy * Math.cos(mapRotation);
  
  // ã‚ºãƒ¼ãƒ ã‚’é©ç”¨
  const zoomedX = rotatedX * mapZoom;
  const zoomedY = rotatedY * mapZoom;
  
  // ãƒ‘ãƒ³ã¨ã‚»ãƒ³ã‚¿ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨
  const finalX = zoomedX + centerX + mapOffsetX;
  const finalY = zoomedY + centerY + mapOffsetY;
  
  return { x: finalX, y: finalY };
}

// CSVã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†
function handleCSVUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(event) {
    const text = event.target.result;
    const lines = text.trim().split(/\r?\n/);
    headers = lines[0].split(',');
    csvData = lines.slice(1).map(line => line.split(','));
    
    // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
    filteredData = [];
    if (medianFilterEnabled) {
      applyMedianFilter();
    }
    
    calculatePositions();
    setupTimeSlider();
    updateStats();
    updateTableDisplay();
    drawControlGraph();
    drawSensorGraph();
    
    // ãƒãƒ¼ã‚«ãƒ¼æ¤œå‡º
    detectAllMarkers();
    
    drawTrack();
  };
  reader.readAsText(file);
}

// ä½ç½®è¨ˆç®—
function calculatePositions() {
  positions = [];
  let x = 0, y = 0, theta = 0;
  const scale = 1;
  
  csvData.forEach((row, i) => {
    const thr = parseFloat(row[headers.indexOf('Thr')]);
    const str = parseFloat(row[headers.indexOf('Str')]);
    const dt = (i > 0 ? (parseFloat(row[0]) - parseFloat(csvData[i-1][0])) : 0.04) * timeScale;
    
    // é€Ÿåº¦ã¨åŸºæº–æ—‹å›åŠå¾„ã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¿‚æ•°ã‚’é©ç”¨ï¼‰
    const speed = interpolateMap(speedMap, thr) * 1000 * speedScale; // mm/s
    const baseRadius = interpolateMap(radiusMap, str) * radiusGain; // mm
    
    // é€Ÿåº¦ä¾å­˜ä¿‚æ•°ã‚’å–å¾—ï¼ˆã‚¿ãƒŸãƒ¤ ã‚¨ã‚¢ãƒ­ãƒãƒ³ãƒ†ã®ç‰¹æ€§ï¼‰
    const speedCoef = interpolateMap(radiusSpeedCoefMap, thr);
    
    // å®Ÿéš›ã®æ—‹å›åŠå¾„ã‚’è¨ˆç®—ï¼ˆé€Ÿåº¦ãŒé«˜ã„ã»ã©æ—‹å›åŠå¾„ãŒå¤§ãããªã‚‹ï¼‰
    const actualRadius = baseRadius * speedCoef; // mm

    // æ—‹å›åŠå¾„ã‹ã‚‰è§’é€Ÿåº¦ã‚’è¨ˆç®—
    // omega = v / r (è§’é€Ÿåº¦ = é€Ÿåº¦ / æ—‹å›åŠå¾„)
    // é‡è¦ï¼šæ“èˆµæŒ‡ç¤ºã®ç¬¦å·ã‚’è€ƒæ…®ï¼ˆè² =å·¦æ—‹å›ã€æ­£=å³æ—‹å›ï¼‰
    const direction = str >= 0 ? -1 : 1; // å³æ—‹å›ã¯è² ã®è§’é€Ÿåº¦ã€å·¦æ—‹å›ã¯æ­£ã®è§’é€Ÿåº¦
    const omega = (actualRadius !== 0) ? direction * speed / actualRadius : 0; // rad/s

    // è§’åº¦ã‚’æ›´æ–°
    theta += omega * dt;
    
    // ä½ç½®ã‚’æ›´æ–°
    x += speed * dt * scale * Math.cos(theta);
    y += speed * dt * scale * Math.sin(theta);
    
    // ãƒ‡ãƒãƒƒã‚°: æœ€åˆã®æ•°è¡Œã‚’å‡ºåŠ›
    if (i < 5) {
      console.log(`[${i}] thr=${thr}%, str=${str}%, speed=${speed.toFixed(1)}mm/s, baseR=${baseRadius.toFixed(1)}mm, coef=${speedCoef.toFixed(2)}, actualR=${actualRadius.toFixed(1)}mm, omega=${omega.toFixed(4)}rad/s, dt=${dt.toFixed(4)}s, theta=${theta.toFixed(3)}rad, x=${x.toFixed(1)}mm, y=${y.toFixed(1)}mm`);
    }

    positions.push({x, y, theta, row});
  });
  
  console.log(`ä½ç½®è¨ˆç®—å®Œäº†: ${positions.length}ç‚¹, æœ€çµ‚ä½ç½® x=${x.toFixed(1)}mm, y=${y.toFixed(1)}mm`);
  console.log(`ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: é€Ÿåº¦=${speedScale}x, æ—‹å›åŠå¾„=${radiusGain}x, æ™‚é–“=${timeScale}x`);
  console.log(`é€Ÿåº¦ä¾å­˜ä¿‚æ•°é©ç”¨: ã‚¿ãƒŸãƒ¤ ã‚¨ã‚¢ãƒ­ãƒãƒ³ãƒ†ã®ç‰¹æ€§åæ˜ ï¼ˆé«˜é€Ÿæ™‚ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ãƒ†ã‚¢ï¼‰`);
}

// UNIXæ™‚åˆ»ã‚’æ™‚:åˆ†:ç§’.ãƒŸãƒªç§’å½¢å¼ã«å¤‰æ›
function formatUnixTime(unixTime) {
  const date = new Date(unixTime * 1000);
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  const milliseconds = String(date.getMilliseconds()).padStart(3, '0');
  return `${hours}:${minutes}:${seconds}.${milliseconds}`;
}

// ã‚¿ã‚¤ãƒ ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼è¨­å®š
function setupTimeSlider() {
  const timeSlider = document.getElementById('timeSlider');
  timeSlider.max = csvData.length - 1;
  timeSlider.value = csvData.length - 1;
  currentTimeIndex = csvData.length - 1;
  
  if (csvData.length > 0) {
    const startUnixTime = parseFloat(csvData[0][0]);
    const endUnixTime = parseFloat(csvData[csvData.length - 1][0]);
    
    const startTime = formatUnixTime(startUnixTime);
    const endTime = formatUnixTime(endUnixTime);
    
    document.getElementById('startTime').textContent = `é–‹å§‹: ${startTime}`;
    document.getElementById('endTime').textContent = `çµ‚äº†: ${endTime}`;
    
    generateTimeTicks();
  }
  
  updateTimeDisplay();
}

// æ™‚åˆ»ãƒ†ã‚£ãƒƒã‚¯ã‚’ç”Ÿæˆ
function generateTimeTicks() {
  const ticksContainer = document.getElementById('timeTicks');
  ticksContainer.innerHTML = '';
  
  const numTicks = 11;
  
  for (let i = 0; i < numTicks; i++) {
    const percentage = i / (numTicks - 1);
    const dataIndex = Math.floor(percentage * (csvData.length - 1));
    const unixTime = parseFloat(csvData[dataIndex][0]);
    const formattedTime = formatUnixTime(unixTime);
    
    const tickDiv = document.createElement('div');
    tickDiv.className = 'time-tick';
    
    const tickLine = document.createElement('div');
    tickLine.className = 'time-tick-line';
    
    const tickLabel = document.createElement('div');
    tickLabel.className = 'time-tick-label';
    tickLabel.textContent = formattedTime;
    
    tickDiv.appendChild(tickLine);
    tickDiv.appendChild(tickLabel);
    ticksContainer.appendChild(tickDiv);
  }
}

// æ™‚åˆ»è¡¨ç¤ºæ›´æ–°
function updateTimeDisplay() {
  if (csvData.length > 0 && currentTimeIndex < csvData.length) {
    const unixTime = parseFloat(csvData[currentTimeIndex][0]);
    const formattedTime = formatUnixTime(unixTime);
    document.getElementById('timeDisplay').textContent = `æ™‚åˆ»: ${formattedTime}`;
    scrollToCurrentRow();
    drawControlGraph();
    drawSensorGraph();
  }
}

// å†ç”Ÿåˆ¶å¾¡
function togglePlayback() {
  isPlaying = !isPlaying;
  const playBtn = document.getElementById('playBtn');
  
  if (isPlaying) {
    playBtn.textContent = 'â¸ ä¸€æ™‚åœæ­¢';
    playbackInterval = setInterval(() => {
      currentTimeIndex++;
      if (currentTimeIndex >= csvData.length - 1) {
        currentTimeIndex = csvData.length - 1;
        togglePlayback();
        return;
      }
      document.getElementById('timeSlider').value = currentTimeIndex;
      updateTimeDisplay();
      drawTrack();
    }, 50);
  } else {
    playBtn.textContent = 'â–¶ å†ç”Ÿ';
    if (playbackInterval) {
      clearInterval(playbackInterval);
      playbackInterval = null;
    }
  }
}

function resetPlayback() {
  currentTimeIndex = 0;
  document.getElementById('timeSlider').value = 0;
  updateTimeDisplay();
  drawTrack();
}

function jumpToEnd() {
  currentTimeIndex = csvData.length - 1;
  document.getElementById('timeSlider').value = currentTimeIndex;
  updateTimeDisplay();
  drawTrack();
}

// ãƒã‚¦ã‚¹å‡¦ç†
function handleGraphMouseDown(e, graphType) {
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const point = findNearestPoint(x, y, graphType);
  if (point && getDistance(x, y, point.canvasX, point.canvasY) < 15) {
    isDragging = true;
    dragPoint = point;
    dragGraph = graphType;
    e.target.style.cursor = 'grabbing';
  }
}

function handleGraphMouseMove(e, graphType) {
  if (!isDragging || dragGraph !== graphType) return;
  
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const dataValue = canvasToData(x, y, graphType);
  if (dataValue) {
    dragPoint.key = dataValue.x;
    dragPoint.value = dataValue.y;
    
    if (graphType === 'speed') {
      speedMap.sort((a, b) => a.key - b.key);
    } else if (graphType === 'radius') {
      radiusMap.sort((a, b) => a.key - b.key);
    } else if (graphType === 'speedCoef') {
      radiusSpeedCoefMap.sort((a, b) => a.key - b.key);
    }
    
    drawAllGraphs();
    calculatePositions();
    drawTrack();
  }
}

function handleGraphMouseUp(e, graphType) {
  if (isDragging && dragGraph === graphType) {
    isDragging = false;
    dragPoint = null;
    dragGraph = null;
    e.target.style.cursor = 'crosshair';
  }
}

function handleGraphDoubleClick(e, graphType) {
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const dataValue = canvasToData(x, y, graphType);
  if (dataValue) {
    if (graphType === 'speed') {
      speedMap.push({key: dataValue.x, value: dataValue.y});
      speedMap.sort((a, b) => a.key - b.key);
    } else if (graphType === 'radius') {
      radiusMap.push({key: dataValue.x, value: dataValue.y});
      radiusMap.sort((a, b) => a.key - b.key);
    } else if (graphType === 'speedCoef') {
      radiusSpeedCoefMap.push({key: dataValue.x, value: dataValue.y});
      radiusSpeedCoefMap.sort((a, b) => a.key - b.key);
    }
    drawAllGraphs();
    calculatePositions();
    drawTrack();
  }
}

// åº§æ¨™å¤‰æ›ï¼ˆæ”¹å–„ç‰ˆ - ç¯„å›²è¨­å®šã‚’ä½¿ç”¨ï¼‰
function canvasToData(x, y, graphType) {
  let canvas, range;
  
  if (graphType === 'speed') {
    canvas = speedGraph;
    range = graphRanges.speed;
  } else if (graphType === 'radius') {
    canvas = radiusGraph;
    range = graphRanges.radius;
  } else if (graphType === 'speedCoef') {
    canvas = speedCoefGraph;
    range = graphRanges.speedCoef;
  }
  
  const marginLeft = graphType === 'radius' ? 65 : 50;
  const marginRight = 50;
  const marginTop = 50;
  const marginBottom = 50;
  const width = canvas.width - marginLeft - marginRight;
  const height = canvas.height - marginTop - marginBottom;
  
  const dataX = range.xMin + ((x - marginLeft) / width) * (range.xMax - range.xMin);
  const dataY = range.yMax - ((y - marginTop) / height) * (range.yMax - range.yMin);
  
  return {
    x: Math.max(range.xMin, Math.min(range.xMax, dataX)),
    y: Math.max(range.yMin, Math.min(range.yMax, dataY))
  };
}

function dataToCanvas(x, y, graphType) {
  let canvas, range;
  
  if (graphType === 'speed') {
    canvas = speedGraph;
    range = graphRanges.speed;
  } else if (graphType === 'radius') {
    canvas = radiusGraph;
    range = graphRanges.radius;
  } else if (graphType === 'speedCoef') {
    canvas = speedCoefGraph;
    range = graphRanges.speedCoef;
  }
  
  const marginLeft = graphType === 'radius' ? 65 : 50;
  const marginRight = 50;
  const marginTop = 50;
  const marginBottom = 50;
  const width = canvas.width - marginLeft - marginRight;
  const height = canvas.height - marginTop - marginBottom;
  
  const canvasX = marginLeft + ((x - range.xMin) / (range.xMax - range.xMin)) * width;
  const canvasY = marginTop + ((range.yMax - y) / (range.yMax - range.yMin)) * height;
  
  return {x: canvasX, y: canvasY};
}

function findNearestPoint(x, y, graphType) {
  let map;
  
  if (graphType === 'speed') {
    map = speedMap;
  } else if (graphType === 'radius') {
    map = radiusMap;
  } else if (graphType === 'speedCoef') {
    map = radiusSpeedCoefMap;
  }
  let nearest = null;
  let minDistance = Infinity;
  
  map.forEach(point => {
    const canvasPos = dataToCanvas(point.key, point.value, graphType);
    const distance = getDistance(x, y, canvasPos.x, canvasPos.y);
    if (distance < minDistance) {
      minDistance = distance;
      nearest = point;
    }
  });
  
  if (nearest) {
    const canvasPos = dataToCanvas(nearest.key, nearest.value, graphType);
    nearest.canvasX = canvasPos.x;
    nearest.canvasY = canvasPos.y;
  }
  
  return nearest;
}

function getDistance(x1, y1, x2, y2) {
  return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
}

// ã‚°ãƒ©ãƒ•æç”»
function drawAllGraphs() {
  drawGraph('speed');
  drawGraph('radius');
  drawGraph('speedCoef');
}

function drawGraph(graphType) {
  let canvas, ctx, map, range;
  
  if (graphType === 'speed') {
    canvas = speedGraph;
    ctx = speedCtx;
    map = speedMap;
    range = graphRanges.speed;
  } else if (graphType === 'radius') {
    canvas = radiusGraph;
    ctx = radiusCtx;
    map = radiusMap;
    range = graphRanges.radius;
  } else if (graphType === 'speedCoef') {
    canvas = speedCoefGraph;
    ctx = speedCoefCtx;
    map = radiusSpeedCoefMap;
    range = graphRanges.speedCoef;
  }
  
  // æ—‹å›åŠå¾„ã‚°ãƒ©ãƒ•ã¯å·¦ãƒãƒ¼ã‚¸ãƒ³ã‚’åºƒãï¼ˆå¤§ãã„æ•°å€¤ç”¨ï¼‰
  const marginLeft = graphType === 'radius' ? 65 : 50;
  const marginRight = 50;
  const marginTop = 50;
  const marginBottom = 50;
  const width = canvas.width - marginLeft - marginRight;
  const height = canvas.height - marginTop - marginBottom;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // ã‚°ãƒªãƒƒãƒ‰æç”»
  drawGrid(ctx, canvas, graphType, marginLeft, marginTop, width, height, range);
  
  // è»¸ãƒ©ãƒ™ãƒ«æç”»
  drawAxisLabels(ctx, canvas, graphType, marginLeft, marginTop, marginBottom, width, height, range);
  
  // ãƒ‡ãƒ¼ã‚¿ç·šæç”»
  if (graphType === 'speed') {
    ctx.strokeStyle = '#ff6b6b';
  } else if (graphType === 'radius') {
    ctx.strokeStyle = '#4ecdc4';
  } else if (graphType === 'speedCoef') {
    ctx.strokeStyle = '#ffa500';
  }
  ctx.lineWidth = 3;
  ctx.beginPath();
  
  map.forEach((point, index) => {
    const pos = dataToCanvas(point.key, point.value, graphType);
    if (index === 0) {
      ctx.moveTo(pos.x, pos.y);
    } else {
      ctx.lineTo(pos.x, pos.y);
    }
  });
  ctx.stroke();
  
  // ãƒ‡ãƒ¼ã‚¿ç‚¹æç”»
  map.forEach(point => {
    const pos = dataToCanvas(point.key, point.value, graphType);
    if (graphType === 'speed') {
      ctx.fillStyle = '#ff6b6b';
    } else if (graphType === 'radius') {
      ctx.fillStyle = '#4ecdc4';
    } else if (graphType === 'speedCoef') {
      ctx.fillStyle = '#ffa500';
    }
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  });
}

function drawGrid(ctx, canvas, graphType, marginLeft, marginTop, width, height, range) {
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  
  // ç¸¦ç·š
  for (let i = 0; i <= 10; i++) {
    const x = marginLeft + (i / 10) * width;
    ctx.beginPath();
    ctx.moveTo(x, marginTop);
    ctx.lineTo(x, marginTop + height);
    ctx.stroke();
  }
  
  // æ¨ªç·š
  for (let i = 0; i <= 10; i++) {
    const y = marginTop + (i / 10) * height;
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + width, y);
    ctx.stroke();
  }
  
  // æ ç·š
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 2;
  ctx.strokeRect(marginLeft, marginTop, width, height);
}

function drawAxisLabels(ctx, canvas, graphType, marginLeft, marginTop, marginBottom, width, height, range) {
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = 'bold 12px Arial';
  
  // Xè»¸ãƒ©ãƒ™ãƒ«
  for (let i = 0; i <= 10; i += 2) {
    const x = marginLeft + (i / 10) * width;
    const value = range.xMin + (i / 10) * (range.xMax - range.xMin);
    ctx.textAlign = 'center';
    ctx.fillText(value.toFixed(0), x, marginTop + height + 22);
  }
  
  // Yè»¸ãƒ©ãƒ™ãƒ«
  ctx.textAlign = 'right';
  for (let i = 0; i <= 10; i += 2) {
    const y = marginTop + ((10 - i) / 10) * height;
    const value = range.yMin + (i / 10) * (range.yMax - range.yMin);
    
    // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼šæ—‹å›åŠå¾„â†’æ•´æ•°ã€é€Ÿåº¦â†’å°æ•°ç‚¹1æ¡ã€ä¿‚æ•°â†’å°æ•°ç‚¹2æ¡
    let labelText;
    if (graphType === 'radius') {
      labelText = value.toFixed(0);
    } else if (graphType === 'speedCoef') {
      labelText = value.toFixed(2);
    } else {
      labelText = value.toFixed(1);
    }
    ctx.fillText(labelText, marginLeft - 12, y + 4);
  }
  
  // è»¸ã‚¿ã‚¤ãƒˆãƒ«
  ctx.font = 'bold 13px Arial';
  ctx.textAlign = 'center';
  let xAxisLabel, yAxisLabel;
  
  if (graphType === 'speed') {
    xAxisLabel = 'Throttle (%)';
    yAxisLabel = 'Speed (m/s)';
  } else if (graphType === 'radius') {
    xAxisLabel = 'Steering (%)';
    yAxisLabel = 'Radius (mm)';
  } else if (graphType === 'speedCoef') {
    xAxisLabel = 'Throttle (%)';
    yAxisLabel = 'Coefficient';
  }
  
  ctx.fillText(xAxisLabel, marginLeft + width / 2, canvas.height - 8);
  
  ctx.save();
  ctx.translate(20, marginTop + height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(yAxisLabel, 0, 0);
  ctx.restore();
}

// ãƒã‚¤ãƒ³ãƒˆè¿½åŠ 
function addSpeedPoint() {
  const range = graphRanges.speed;
  const newKey = speedMap.length > 0 ? speedMap[speedMap.length - 1].key + 10 : (range.xMin + range.xMax) / 2;
  const newValue = speedMap.length > 0 ? speedMap[speedMap.length - 1].value + 0.5 : (range.yMin + range.yMax) / 2;
  speedMap.push({key: Math.min(newKey, range.xMax), value: Math.min(newValue, range.yMax)});
  speedMap.sort((a, b) => a.key - b.key);
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

function addRadiusPoint() {
  const range = graphRanges.radius;
  const newKey = radiusMap.length > 0 ? radiusMap[radiusMap.length - 1].key + 25 : 0;
  const newValue = radiusMap.length > 0 ? radiusMap[radiusMap.length - 1].value : 1000;
  radiusMap.push({key: Math.min(newKey, range.xMax), value: Math.min(Math.max(newValue, range.yMin), range.yMax)});
  radiusMap.sort((a, b) => a.key - b.key);
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

// ãƒãƒƒãƒ—ãƒªã‚»ãƒƒãƒˆ
function resetSpeedMap() {
  speedMap = [
    {key: 0, value: 0}, {key: 10, value: 0.2}, {key: 20, value: 0.4},
    {key: 30, value: 1}, {key: 40, value: 1.5}, {key: 50, value: 2},
    {key: 60, value: 2.5}, {key: 70, value: 3}, {key: 80, value: 3.5},
    {key: 90, value: 4}, {key: 100, value: 5}
  ];
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

function resetRadiusMap() {
  radiusMap = [
    {key: -100, value: 3000}, {key: -75, value: 3800}, {key: -50, value: 5000},
    {key: -30, value: 8500}, {key: -20, value: 17000}, {key: -10, value: 42000},
    {key: 0, value: 100000},
    {key: 10, value: 42000}, {key: 20, value: 17000}, {key: 30, value: 8500},
    {key: 50, value: 5000}, {key: 75, value: 3800}, {key: 100, value: 3000}
  ];
  drawAllGraphs();
  updateRadiusTable();
  calculatePositions();
  drawTrack();
}

// ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
function toggleSpeedMapMode() {
  speedMapMode = speedMapMode === 'graph' ? 'table' : 'graph';
  const graphMode = document.getElementById('speedGraphMode');
  const tableMode = document.getElementById('speedTableMode');
  const btn = document.getElementById('speedModeBtn');
  
  if (speedMapMode === 'table') {
    graphMode.style.display = 'none';
    tableMode.style.display = 'block';
    btn.textContent = 'ğŸ“‹ ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ¢ãƒ¼ãƒ‰';
    btn.classList.add('active');
    updateSpeedTable();
  } else {
    graphMode.style.display = 'block';
    tableMode.style.display = 'none';
    btn.textContent = 'ğŸ“Š ã‚°ãƒ©ãƒ•ãƒ¢ãƒ¼ãƒ‰';
    btn.classList.remove('active');
  }
}

function toggleSpeedCoefMapMode() {
  speedCoefMapMode = speedCoefMapMode === 'graph' ? 'table' : 'graph';
  const graphMode = document.getElementById('speedCoefGraphMode');
  const tableMode = document.getElementById('speedCoefTableMode');
  const btn = document.getElementById('speedCoefModeBtn');
  
  if (speedCoefMapMode === 'table') {
    graphMode.style.display = 'none';
    tableMode.style.display = 'block';
    btn.textContent = 'ğŸ“‹ ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ¢ãƒ¼ãƒ‰';
    btn.classList.add('active');
    updateSpeedCoefTable();
  } else {
    graphMode.style.display = 'block';
    tableMode.style.display = 'none';
    btn.textContent = 'ğŸ“Š ã‚°ãƒ©ãƒ•ãƒ¢ãƒ¼ãƒ‰';
    btn.classList.remove('active');
  }
}

function toggleRadiusMapMode() {
  radiusMapMode = radiusMapMode === 'graph' ? 'table' : 'graph';
  const graphMode = document.getElementById('radiusGraphMode');
  const tableMode = document.getElementById('radiusTableMode');
  const btn = document.getElementById('radiusModeBtn');
  
  if (radiusMapMode === 'table') {
    graphMode.style.display = 'none';
    tableMode.style.display = 'block';
    btn.textContent = 'ğŸ“‹ ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ¢ãƒ¼ãƒ‰';
    btn.classList.add('active');
    updateRadiusTable();
  } else {
    graphMode.style.display = 'block';
    tableMode.style.display = 'none';
    btn.textContent = 'ğŸ“Š ã‚°ãƒ©ãƒ•ãƒ¢ãƒ¼ãƒ‰';
    btn.classList.remove('active');
  }
}

// ãƒ†ãƒ¼ãƒ–ãƒ«æ›´æ–°æ©Ÿèƒ½
function updateSpeedTable() {
  const tbody = document.getElementById('speedTableBody');
  if (!tbody) return;
  
  tbody.innerHTML = '';
  speedMap.forEach((point, index) => {
    const row = tbody.insertRow();
    
    const cellKey = row.insertCell(0);
    const inputKey = document.createElement('input');
    inputKey.type = 'number';
    inputKey.value = point.key;
    inputKey.step = '1';
    inputKey.onchange = () => updateSpeedMapPoint(index, 'key', parseFloat(inputKey.value));
    cellKey.appendChild(inputKey);
    
    const cellValue = row.insertCell(1);
    const inputValue = document.createElement('input');
    inputValue.type = 'number';
    inputValue.value = point.value;
    inputValue.step = '0.1';
    inputValue.onchange = () => updateSpeedMapPoint(index, 'value', parseFloat(inputValue.value));
    cellValue.appendChild(inputValue);
    
    const cellAction = row.insertCell(2);
    const btnDelete = document.createElement('button');
    btnDelete.className = 'btn-delete';
    btnDelete.textContent = 'ğŸ—‘ï¸';
    btnDelete.onclick = () => deleteSpeedMapPoint(index);
    cellAction.appendChild(btnDelete);
  });
}

function updateRadiusTable() {
  const tbody = document.getElementById('radiusTableBody');
  if (!tbody) return;
  
  tbody.innerHTML = '';
  radiusMap.forEach((point, index) => {
    const row = tbody.insertRow();
    
    const cellKey = row.insertCell(0);
    const inputKey = document.createElement('input');
    inputKey.type = 'number';
    inputKey.value = point.key;
    inputKey.step = '1';
    inputKey.onchange = () => updateRadiusMapPoint(index, 'key', parseFloat(inputKey.value));
    cellKey.appendChild(inputKey);
    
    const cellValue = row.insertCell(1);
    const inputValue = document.createElement('input');
    inputValue.type = 'number';
    inputValue.value = point.value;
    inputValue.step = '10';
    inputValue.onchange = () => updateRadiusMapPoint(index, 'value', parseFloat(inputValue.value));
    cellValue.appendChild(inputValue);
    
    const cellAction = row.insertCell(2);
    const btnDelete = document.createElement('button');
    btnDelete.className = 'btn-delete';
    btnDelete.textContent = 'ğŸ—‘ï¸';
    btnDelete.onclick = () => deleteRadiusMapPoint(index);
    cellAction.appendChild(btnDelete);
  });
}

function updateSpeedCoefTable() {
  const tbody = document.getElementById('speedCoefTableBody');
  if (!tbody) return;
  
  tbody.innerHTML = '';
  radiusSpeedCoefMap.forEach((point, index) => {
    const row = tbody.insertRow();
    
    const cellKey = row.insertCell(0);
    const inputKey = document.createElement('input');
    inputKey.type = 'number';
    inputKey.value = point.key;
    inputKey.step = '1';
    inputKey.onchange = () => updateSpeedCoefMapPoint(index, 'key', parseFloat(inputKey.value));
    cellKey.appendChild(inputKey);
    
    const cellValue = row.insertCell(1);
    const inputValue = document.createElement('input');
    inputValue.type = 'number';
    inputValue.value = point.value;
    inputValue.step = '0.05';
    inputValue.onchange = () => updateSpeedCoefMapPoint(index, 'value', parseFloat(inputValue.value));
    cellValue.appendChild(inputValue);
    
    const cellAction = row.insertCell(2);
    const btnDelete = document.createElement('button');
    btnDelete.className = 'btn-delete';
    btnDelete.textContent = 'ğŸ—‘ï¸';
    btnDelete.onclick = () => deleteSpeedCoefMapPoint(index);
    cellAction.appendChild(btnDelete);
  });
}

// ãƒã‚¤ãƒ³ãƒˆæ›´æ–°æ©Ÿèƒ½
function updateSpeedMapPoint(index, field, value) {
  speedMap[index][field] = value;
  speedMap.sort((a, b) => a.key - b.key);
  updateSpeedTable();
  drawAllGraphs();
  if (csvData.length > 0) {
    calculatePositions();
    drawTrack();
  }
}

function updateRadiusMapPoint(index, field, value) {
  radiusMap[index][field] = value;
  
  // å·¦å³å¯¾ç§°æ©Ÿèƒ½ï¼šæ­£ã®å´ã‚’ç·¨é›†ã—ãŸã‚‰ã€è² ã®å´ã«ã‚‚è‡ªå‹•åæ˜ 
  if (field === 'value') {
    const currentKey = radiusMap[index].key;
    if (currentKey >= 0) {
      // æ­£ã®å´ã‚’ç·¨é›†ã—ãŸå ´åˆã€è² ã®å´ã‚’æ¢ã—ã¦åŒã˜å€¤ã‚’è¨­å®š
      const mirrorKey = -currentKey;
      const mirrorIndex = radiusMap.findIndex(p => p.key === mirrorKey);
      if (mirrorIndex !== -1) {
        radiusMap[mirrorIndex].value = value;
      } else if (currentKey > 0) {
        // å¯¾å¿œã™ã‚‹è² ã®ã‚­ãƒ¼ãŒãªã„å ´åˆã¯æ–°è¦è¿½åŠ 
        radiusMap.push({key: mirrorKey, value: value});
      }
    }
  } else if (field === 'key') {
    // ã‚­ãƒ¼ã‚’ç·¨é›†ã—ãŸå ´åˆã‚‚å·¦å³å¯¾ç§°ã‚’ç¶­æŒ
    const oldKey = radiusMap[index].key;
    if (value >= 0 && oldKey >= 0) {
      // æ­£ã®å´ã®ã‚­ãƒ¼ã‚’å¤‰æ›´ã—ãŸå ´åˆ
      const mirrorOldKey = -oldKey;
      const mirrorIndex = radiusMap.findIndex(p => p.key === mirrorOldKey);
      if (mirrorIndex !== -1 && value > 0) {
        radiusMap[mirrorIndex].key = -value;
      }
    }
  }
  
  radiusMap.sort((a, b) => a.key - b.key);
  updateRadiusTable();
  drawAllGraphs();
  if (csvData.length > 0) {
    calculatePositions();
    drawTrack();
  }
}

// ãƒã‚¤ãƒ³ãƒˆè¿½åŠ æ©Ÿèƒ½
function addSpeedPointTable() {
  const lastPoint = speedMap[speedMap.length - 1];
  const newKey = lastPoint ? lastPoint.key + 10 : 50;
  const newValue = lastPoint ? lastPoint.value : 2.5;
  speedMap.push({key: newKey, value: newValue});
  speedMap.sort((a, b) => a.key - b.key);
  updateSpeedTable();
  drawAllGraphs();
}

function addRadiusPointTable() {
  // æ­£ã®å´ã®æœ€å¤§ã‚­ãƒ¼ã‚’æ¢ã™
  const positivePoints = radiusMap.filter(p => p.key > 0);
  const lastPositivePoint = positivePoints.length > 0 ? positivePoints[positivePoints.length - 1] : null;
  
  const newKey = lastPositivePoint ? Math.min(lastPositivePoint.key + 10, 100) : 10;
  const newValue = lastPositivePoint ? lastPositivePoint.value : 1000;
  
  // æ­£ã®å´ã«è¿½åŠ 
  radiusMap.push({key: newKey, value: newValue});
  
  // å·¦å³å¯¾ç§°ï¼šè² ã®å´ã«ã‚‚è¿½åŠ ï¼ˆ0åº¦ä»¥å¤–ï¼‰
  if (newKey > 0) {
    radiusMap.push({key: -newKey, value: newValue});
  }
  
  radiusMap.sort((a, b) => a.key - b.key);
  updateRadiusTable();
  drawAllGraphs();
}

// ãƒã‚¤ãƒ³ãƒˆå‰Šé™¤æ©Ÿèƒ½
function deleteSpeedMapPoint(index) {
  if (speedMap.length <= 2) {
    alert('æœ€ä½2ã¤ã®ãƒã‚¤ãƒ³ãƒˆãŒå¿…è¦ã§ã™ã€‚');
    return;
  }
  speedMap.splice(index, 1);
  updateSpeedTable();
  drawAllGraphs();
  if (csvData.length > 0) {
    calculatePositions();
    drawTrack();
  }
}

function deleteRadiusMapPoint(index) {
  if (radiusMap.length <= 3) {
    alert('æœ€ä½3ã¤ã®ãƒã‚¤ãƒ³ãƒˆï¼ˆä¸­å¿ƒ+å·¦å³ï¼‰ãŒå¿…è¦ã§ã™ã€‚');
    return;
  }
  
  const deletedKey = radiusMap[index].key;
  
  // å‰Šé™¤å®Ÿè¡Œ
  radiusMap.splice(index, 1);
  
  // å·¦å³å¯¾ç§°ï¼šæ­£ã®å´ã‚’å‰Šé™¤ã—ãŸã‚‰ã€å¯¾å¿œã™ã‚‹è² ã®å´ã‚‚å‰Šé™¤
  if (deletedKey > 0) {
    const mirrorKey = -deletedKey;
    const mirrorIndex = radiusMap.findIndex(p => p.key === mirrorKey);
    if (mirrorIndex !== -1) {
      radiusMap.splice(mirrorIndex, 1);
    }
  } else if (deletedKey < 0) {
    // è² ã®å´ã‚’å‰Šé™¤ã—ãŸã‚‰ã€å¯¾å¿œã™ã‚‹æ­£ã®å´ã‚‚å‰Šé™¤
    const mirrorKey = -deletedKey;
    const mirrorIndex = radiusMap.findIndex(p => p.key === mirrorKey);
    if (mirrorIndex !== -1) {
      radiusMap.splice(mirrorIndex, 1);
    }
  }
  
  updateRadiusTable();
  drawAllGraphs();
  if (csvData.length > 0) {
    calculatePositions();
    drawTrack();
  }
}

// é€Ÿåº¦ä¾å­˜ä¿‚æ•°ãƒãƒƒãƒ—ç”¨é–¢æ•°
function updateSpeedCoefMapPoint(index, field, value) {
  radiusSpeedCoefMap[index][field] = value;
  radiusSpeedCoefMap.sort((a, b) => a.key - b.key);
  updateSpeedCoefTable();
  drawAllGraphs();
  if (csvData.length > 0) {
    calculatePositions();
    drawTrack();
  }
}

function addSpeedCoefPointTable() {
  const lastPoint = radiusSpeedCoefMap[radiusSpeedCoefMap.length - 1];
  const newKey = lastPoint ? Math.min(lastPoint.key + 10, 100) : 50;
  const newValue = lastPoint ? lastPoint.value : 1.2;
  radiusSpeedCoefMap.push({key: newKey, value: newValue});
  radiusSpeedCoefMap.sort((a, b) => a.key - b.key);
  updateSpeedCoefTable();
  drawAllGraphs();
}

function addSpeedCoefPoint() {
  const range = graphRanges.speedCoef;
  const newKey = radiusSpeedCoefMap.length > 0 ? radiusSpeedCoefMap[radiusSpeedCoefMap.length - 1].key + 10 : 50;
  const newValue = radiusSpeedCoefMap.length > 0 ? radiusSpeedCoefMap[radiusSpeedCoefMap.length - 1].value : 1.2;
  radiusSpeedCoefMap.push({key: Math.min(newKey, range.xMax), value: Math.min(Math.max(newValue, range.yMin), range.yMax)});
  radiusSpeedCoefMap.sort((a, b) => a.key - b.key);
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

function deleteSpeedCoefMapPoint(index) {
  if (radiusSpeedCoefMap.length <= 2) {
    alert('æœ€ä½2ã¤ã®ãƒã‚¤ãƒ³ãƒˆãŒå¿…è¦ã§ã™ã€‚');
    return;
  }
  radiusSpeedCoefMap.splice(index, 1);
  updateSpeedCoefTable();
  drawAllGraphs();
  if (csvData.length > 0) {
    calculatePositions();
    drawTrack();
  }
}

function resetSpeedCoefMap() {
  radiusSpeedCoefMap = [
    {key: 0,   value: 1.0},
    {key: 20,  value: 1.05},
    {key: 40,  value: 1.15},
    {key: 60,  value: 1.3},
    {key: 80,  value: 1.5},
    {key: 100, value: 1.8}
  ];
  drawAllGraphs();
  updateSpeedCoefTable();
  calculatePositions();
  drawTrack();
}

// ãƒãƒƒãƒ—ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
function exportMaps() {
  const maps = {speedMap, radiusMap, radiusSpeedCoefMap, sensorAngles, graphRanges};
  const dataStr = JSON.stringify(maps, null, 2);
  const dataBlob = new Blob([dataStr], {type: 'application/json'});
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'minicar_maps_v4.json';
  link.click();
  URL.revokeObjectURL(url);
}

function importMaps() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
      try {
        const maps = JSON.parse(event.target.result);
        speedMap = maps.speedMap;
        radiusMap = maps.radiusMap || maps.steeringMap; // æ—§å½¢å¼ã¨ã®äº’æ›æ€§ã®ãŸã‚
        
        // é€Ÿåº¦ä¾å­˜ä¿‚æ•°ãƒãƒƒãƒ—ã®èª­ã¿è¾¼ã¿ï¼ˆãªã‘ã‚Œã°ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼‰
        if (maps.radiusSpeedCoefMap) {
          radiusSpeedCoefMap = maps.radiusSpeedCoefMap;
        } else {
          // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼ˆã‚¿ãƒŸãƒ¤ ã‚¨ã‚¢ãƒ­ãƒãƒ³ãƒ†ï¼‰
          radiusSpeedCoefMap = [
            {key: 0, value: 1.0}, {key: 20, value: 1.05},
            {key: 40, value: 1.15}, {key: 60, value: 1.3},
            {key: 80, value: 1.5}, {key: 100, value: 1.8}
          ];
        }
        
        if (maps.sensorAngles) {
          sensorAngles = maps.sensorAngles;
          Object.keys(sensorAngles).forEach(sensor => {
            document.getElementById(`angle${sensor}`).value = sensorAngles[sensor];
            document.querySelector(`#angle${sensor}`).previousElementSibling.value = sensorAngles[sensor];
          });
        }
        if (maps.graphRanges) {
          graphRanges = maps.graphRanges;
          document.getElementById('speedXMin').value = graphRanges.speed.xMin;
          document.getElementById('speedXMax').value = graphRanges.speed.xMax;
          document.getElementById('speedYMin').value = graphRanges.speed.yMin;
          document.getElementById('speedYMax').value = graphRanges.speed.yMax;
          const radiusRange = graphRanges.radius || graphRanges.steering;
          if (radiusRange) {
            document.getElementById('radiusXMin').value = radiusRange.xMin;
            document.getElementById('radiusXMax').value = radiusRange.xMax;
            document.getElementById('radiusYMin').value = radiusRange.yMin;
            document.getElementById('radiusYMax').value = radiusRange.yMax;
          }
          if (graphRanges.speedCoef) {
            document.getElementById('speedCoefXMin').value = graphRanges.speedCoef.xMin;
            document.getElementById('speedCoefXMax').value = graphRanges.speedCoef.xMax;
            document.getElementById('speedCoefYMin').value = graphRanges.speedCoef.yMin;
            document.getElementById('speedCoefYMax').value = graphRanges.speedCoef.yMax;
          }
        }
        drawAllGraphs();
        updateSpeedTable();
        updateRadiusTable();
        updateSpeedCoefTable();
        calculatePositions();
        drawTrack();
      } catch (error) {
        alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

// çµ±è¨ˆæƒ…å ±æ›´æ–°
function updateStats() {
  if (!csvData.length) return;
  
  document.getElementById('totalPoints').textContent = csvData.length;
  
  let totalDistance = 0;
  let maxSpeed = 0;
  let totalSpeed = 0;
  
  csvData.forEach((row, i) => {
    const thr = parseFloat(row[headers.indexOf('Thr')]);
    const speed = interpolateMap(speedMap, thr);
    const dt = i > 0 ? (parseFloat(row[0]) - parseFloat(csvData[i-1][0])) : 0.04;
    
    totalDistance += speed * dt;
    maxSpeed = Math.max(maxSpeed, speed);
    totalSpeed += speed;
  });
  
  document.getElementById('trackLength').textContent = totalDistance.toFixed(2) + 'm';
  document.getElementById('maxSpeed').textContent = maxSpeed.toFixed(2) + 'm/s';
  document.getElementById('avgSpeed').textContent = (totalSpeed / csvData.length).toFixed(2) + 'm/s';
}

// è»Œè·¡æç”»ï¼ˆæœ€é‡è¦é–¢æ•°ï¼‰
function drawTrack() {
  const canvas = document.getElementById('trackCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!positions.length) return;

  const activeSensors = Array.from(document.querySelectorAll('.sensorCheckbox:checked')).map(cb => cb.value);

  const xs = positions.map(p => p.x);
  const ys = positions.map(p => p.y);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  
  const margin = 50;  // ã‚°ãƒªãƒƒãƒ‰ã‚¨ãƒªã‚¢ã‚’åºƒã’ã‚‹ãŸã‚ç¸®å°
  const scaleX = (canvas.width - 2 * margin) / (maxX - minX + VEHICLE_LENGTH * 2);
  const scaleY = (canvas.height - 2 * margin) / (maxY - minY + VEHICLE_LENGTH * 2);
  const scale = Math.min(scaleX, scaleY);
  
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  // ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’ä¿å­˜ï¼ˆã‚¯ãƒªãƒƒã‚¯å‡¦ç†ã§ä½¿ç”¨ï¼‰
  canvasScaleInfo = { minX, minY, scale, margin, centerX, centerY };

  // å¤‰æ›ã‚’é©ç”¨ã—ã¦æç”»
  ctx.save();
  ctx.translate(centerX + mapOffsetX, centerY + mapOffsetY);
  ctx.rotate(mapRotation);
  ctx.scale(mapZoom, mapZoom);
  ctx.translate(-centerX, -centerY);

  // èƒŒæ™¯ã‚°ãƒªãƒƒãƒ‰ï¼ˆã‚ºãƒ¼ãƒ ã«å¿œã˜ã¦è‡ªå‹•èª¿æ•´ï¼‰
  // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ã‚°ãƒªãƒƒãƒ‰åˆ†å‰²æ•°ã‚’èª¿æ•´
  let gridDivisions;
  if (mapZoom < 0.3) {
    gridDivisions = 10;  // è¶…åºƒåŸŸè¡¨ç¤º
  } else if (mapZoom < 0.6) {
    gridDivisions = 15;  // åºƒåŸŸè¡¨ç¤º
  } else if (mapZoom < 1.5) {
    gridDivisions = 20;  // é€šå¸¸è¡¨ç¤º
  } else if (mapZoom < 3) {
    gridDivisions = 30;  // æ‹¡å¤§è¡¨ç¤º
  } else if (mapZoom < 5) {
    gridDivisions = 40;  // é«˜æ‹¡å¤§è¡¨ç¤º
  } else {
    gridDivisions = 50;  // è¶…é«˜æ‹¡å¤§è¡¨ç¤º
  }
  
  // ã‚°ãƒªãƒƒãƒ‰ç¯„å›²ã‚’å€ã«æ‹¡å¤§ï¼ˆXYä¸¡è»¸æ–¹å‘ï¼‰
  const gridStartX = margin - (canvas.width - 2 * margin) / 2;
  const gridEndX = canvas.width - margin + (canvas.width - 2 * margin) / 2;
  const gridStartY = margin - (canvas.height - 2 * margin) / 2;
  const gridEndY = canvas.height - margin + (canvas.height - 2 * margin) / 2;
  const gridWidth = gridEndX - gridStartX;
  const gridHeight = gridEndY - gridStartY;
  
  // ã‚°ãƒªãƒƒãƒ‰é–“éš”ã®å®Ÿã‚µã‚¤ã‚ºã‚’è¨ˆç®—ï¼ˆmmå˜ä½ï¼‰
  const canvasGridSpacing = gridWidth / gridDivisions;
  const realGridSpacing = canvasGridSpacing / (scale * mapZoom);
  
  // ã‚°ãƒªãƒƒãƒ‰æƒ…å ±ã‚’ä¿å­˜ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±è¡¨ç¤ºç”¨ï¼‰
  canvasScaleInfo.gridSpacing = realGridSpacing;
  
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1 / mapZoom;
  
  // Xè»¸æ–¹å‘ã®ã‚°ãƒªãƒƒãƒ‰ç·š
  for(let i = 0; i <= gridDivisions; i++){
    const x = gridStartX + i * gridWidth / gridDivisions;
    ctx.beginPath();
    ctx.moveTo(x, gridStartY);
    ctx.lineTo(x, gridEndY);
    ctx.stroke();
  }
  
  // Yè»¸æ–¹å‘ã®ã‚°ãƒªãƒƒãƒ‰ç·š
  for(let i = 0; i <= gridDivisions; i++){
    const y = gridStartY + i * gridHeight / gridDivisions;
    ctx.beginPath();
    ctx.moveTo(gridStartX, y);
    ctx.lineTo(gridEndX, y);
    ctx.stroke();
  }

  // ã‚³ãƒ¼ã‚¹å‚ç…§ç·šã‚’æç”»ï¼ˆå‡¹å‹ã‚³ãƒ¼ã‚¹ï¼‰
  if (showCourseRef) {
    const courseVertical = parseFloat(document.getElementById('courseVertical').value) * 1000; // m â†’ mm
    const courseHorizontal = parseFloat(document.getElementById('courseHorizontal').value) * 1000;
    const courseWidth = parseFloat(document.getElementById('courseWidth').value) * 1000;
    
    // ã‚³ãƒ¼ã‚¹ä¸­å¿ƒã‚’è¨ˆç®—
    const courseCenterX = centerX;
    const courseCenterY = centerY;
    
    // å‡¹å‹ã‚³ãƒ¼ã‚¹ã®å¤–å´ãƒ©ã‚¤ãƒ³ï¼ˆæ™‚è¨ˆå›ã‚Šï¼‰
    ctx.strokeStyle = 'rgba(138,201,38,0.7)';
    ctx.lineWidth = 3 / mapZoom;
    ctx.setLineDash([10 / mapZoom, 5 / mapZoom]);
    ctx.beginPath();
    
    const halfVert = courseVertical / 2;
    const halfHoriz = courseHorizontal / 2;
    
    // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨
    const refScale = scale;
    
    // å¤–å´ã®çŸ©å½¢ï¼ˆå·¦ä¸Šã‹ã‚‰æ™‚è¨ˆå›ã‚Šï¼‰
    ctx.moveTo(courseCenterX - halfHoriz * refScale, courseCenterY - halfVert * refScale);
    ctx.lineTo(courseCenterX + halfHoriz * refScale, courseCenterY - halfVert * refScale);
    ctx.lineTo(courseCenterX + halfHoriz * refScale, courseCenterY + halfVert * refScale);
    ctx.lineTo(courseCenterX - halfHoriz * refScale, courseCenterY + halfVert * refScale);
    ctx.closePath();
    ctx.stroke();
    
    // å†…å´ãƒ©ã‚¤ãƒ³ï¼ˆé“å¹…åˆ†å†…å´ï¼‰
    ctx.strokeStyle = 'rgba(138,201,38,0.5)';
    ctx.beginPath();
    const innerOffset = courseWidth * refScale;
    ctx.moveTo(courseCenterX - halfHoriz * refScale + innerOffset, courseCenterY - halfVert * refScale + innerOffset);
    ctx.lineTo(courseCenterX + halfHoriz * refScale - innerOffset, courseCenterY - halfVert * refScale + innerOffset);
    ctx.lineTo(courseCenterX + halfHoriz * refScale - innerOffset, courseCenterY + halfVert * refScale - innerOffset);
    ctx.lineTo(courseCenterX - halfHoriz * refScale + innerOffset, courseCenterY + halfVert * refScale - innerOffset);
    ctx.closePath();
    ctx.stroke();
    
    ctx.setLineDash([]);
    
    // å¯¸æ³•è¡¨ç¤º
    ctx.fillStyle = 'rgba(138,201,38,0.9)';
    ctx.font = `${14 / mapZoom}px Arial`;
    ctx.fillText(`${courseVertical/1000}m`, courseCenterX + halfHoriz * refScale + 10 / mapZoom, courseCenterY);
    ctx.fillText(`${courseHorizontal/1000}m`, courseCenterX, courseCenterY - halfVert * refScale - 10 / mapZoom);
  }

  // å…¨æ™‚åˆ»ç¯„å›²ã®è»Œè·¡ç·šã‚’æç”»
  ctx.strokeStyle = 'rgba(0,200,255,0.5)';
  ctx.lineWidth = 2 / mapZoom;
  ctx.beginPath();
  positions.forEach((p, i) => {
    const cx = margin + (p.x - minX) * scale;
    const cy = margin + (p.y - minY) * scale;
    if (i === 0) {
      ctx.moveTo(cx, cy);
    } else {
      ctx.lineTo(cx, cy);
    }
  });
  ctx.stroke();

  // ãƒãƒ¼ã‚«ãƒ¼ã‚’æç”»ï¼ˆã²ã—å½¢ãƒ—ãƒ­ãƒƒãƒˆ - ã‚»ãƒ³ã‚µãƒ¼ãƒ—ãƒ­ãƒƒãƒˆã‚ˆã‚Šä¸‹ã«è¡¨ç¤ºï¼‰
  drawMarkers(ctx, minX, minY, scale, margin);

  // ã‚»ãƒ³ã‚µãƒ¼ã”ã¨ã«ç‚¹ã¨ç·šã‚’æç”»
  activeSensors.forEach(name => {
    const idx = headers.indexOf(name);
    if (idx < 0) return;
    
    const color = sensorColors[name];
    const sensorAngleRad = (sensorAngles[name] || 0) * Math.PI / 180;
    
    let sensorPoints = [];
    positions.forEach((p, i) => {
      if (i % sensorDensity !== 0) return;
      
      const cx = margin + (p.x - minX) * scale;
      const cy = margin + (p.y - minY) * scale;
      
      // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãŒæœ‰åŠ¹ãªå ´åˆã¯ãƒ•ã‚£ãƒ«ã‚¿æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
      const dataSource = (medianFilterEnabled && filteredData.length > 0) ? filteredData : csvData;
      const distance = parseFloat(dataSource[i][idx]);
      
      const totalAngle = p.theta + sensorAngleRad;
      const sx = cx + distance * scale * Math.cos(totalAngle);
      const sy = cy + distance * scale * Math.sin(totalAngle);
      
      sensorPoints.push({x: sx, y: sy, index: i});
    });
    
    // ç·šã‚’æç”»
    if (sensorPoints.length > 1) {
      ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`;
      ctx.lineWidth = sensorLineWidth / mapZoom;
      ctx.beginPath();
      sensorPoints.forEach((point, i) => {
        if (i === 0) {
          ctx.moveTo(point.x, point.y);
        } else {
          ctx.lineTo(point.x, point.y);
        }
      });
      ctx.stroke();
    }
    
    // ã‚»ãƒ³ã‚µãƒ¼ç‚¹ã‚’æç”»ï¼ˆæ™‚åˆ»ã«åŸºã¥ã„ã¦è¦–è¦šçš„ã«å¤‰åŒ–ï¼‰
    sensorPoints.forEach(point => {
      const timeDiff = point.index - currentTimeIndex;
      let pointSize = sensorPointSize / mapZoom;
      let pointColor = color;
      let alpha = 0.95;
      
      if (timeDiff < 0) {
        // éå»ã®ãƒ—ãƒ­ãƒƒãƒˆ
        const pastIndex = Math.abs(timeDiff);
        
        if (pastIndex <= pastPlotsCount * sensorDensity) {
          // éå»pastPlotsCountå€‹ã®ãƒ—ãƒ­ãƒƒãƒˆï¼šé †ã«å°ã•ãã™ã‚‹
          const ratio = 1 - (pastIndex / (pastPlotsCount * sensorDensity)) * 0.6;
          pointSize = (sensorPointSize / mapZoom) * ratio;
          alpha = 0.95 * ratio;
        } else {
          // ãã‚Œã‚ˆã‚Šéå»ï¼šå°ã•ãç°è‰²
          pointSize = (sensorPointSize / mapZoom) * 0.3;
          pointColor = {r: 128, g: 128, b: 128};
          alpha = 0.4;
        }
      } else if (timeDiff > 0) {
        // æœªæ¥ã®ãƒ—ãƒ­ãƒƒãƒˆ
        if (futurePlotsCount === 0) {
          // 0æŒ‡å®šã®å ´åˆã¯å…¨åŒºé–“é€šå¸¸ã‚µã‚¤ã‚º
          pointSize = sensorPointSize / mapZoom;
        alpha = 0.7;
        } else {
          const futureIndex = timeDiff;
          if (futureIndex <= futurePlotsCount * sensorDensity) {
            // æœªæ¥futurePlotsCountå€‹ã®ãƒ—ãƒ­ãƒƒãƒˆï¼šé€šå¸¸ã‚µã‚¤ã‚º
            pointSize = sensorPointSize / mapZoom;
            alpha = 0.7;
          } else {
            // ãã‚Œã‚ˆã‚Šæœªæ¥ï¼šå°ã•ãç°è‰²
            pointSize = (sensorPointSize / mapZoom) * 0.3;
            pointColor = {r: 128, g: 128, b: 128};
            alpha = 0.4;
          }
        }
      }
      
      // ãƒã‚¤ãƒ³ãƒˆæç”»
      const grd = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, pointSize);
      grd.addColorStop(0, `rgba(${pointColor.r}, ${pointColor.g}, ${pointColor.b}, ${alpha})`);
      grd.addColorStop(1, `rgba(${pointColor.r}, ${pointColor.g}, ${pointColor.b}, 0)`);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(point.x, point.y, pointSize, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // ç¾åœ¨æ™‚åˆ»ã®ã‚»ãƒ³ã‚µãƒ¼ç‚¹ã‚’ç‰¹ã«ç›®ç«‹ãŸã›ã‚‹
    const currentPoint = sensorPoints.find(p => p.index === currentTimeIndex);
    if (currentPoint) {
      // å¤–å´ã®å…‰ã‚‹è¼ª
      const outerGrd = ctx.createRadialGradient(currentPoint.x, currentPoint.y, 0, currentPoint.x, currentPoint.y, (sensorPointSize / mapZoom) * 3);
      outerGrd.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`);
      outerGrd.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`);
      outerGrd.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
      ctx.fillStyle = outerGrd;
      ctx.beginPath();
      ctx.arc(currentPoint.x, currentPoint.y, (sensorPointSize / mapZoom) * 3, 0, Math.PI * 2);
      ctx.fill();
      
      // ä¸­å¿ƒã®æ˜ã‚‹ã„ç‚¹
      ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
      ctx.beginPath();
      ctx.arc(currentPoint.x, currentPoint.y, (sensorPointSize / mapZoom) * 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // ç™½ã„ç¸å–ã‚Š
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
      ctx.lineWidth = 2 / mapZoom;
      ctx.stroke();
    }
  });

  // ç¾åœ¨ã¾ã§ã®è»Œè·¡ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  if (currentTimeIndex > 0) {
    ctx.strokeStyle = 'rgba(0,255,255,0.9)';
    ctx.lineWidth = 3 / mapZoom;
    ctx.beginPath();
    for (let i = 0; i <= currentTimeIndex && i < positions.length; i++) {
      const p = positions[i];
      const cx = margin + (p.x - minX) * scale;
      const cy = margin + (p.y - minY) * scale;
      if (i === 0) {
        ctx.moveTo(cx, cy);
      } else {
        ctx.lineTo(cx, cy);
      }
    }
    ctx.stroke();
  }

  // ç¾åœ¨ã®è»Šä¸¡ä½ç½®ã‚’æç”»
  if (currentTimeIndex < positions.length) {
    const currentPos = positions[currentTimeIndex];
    const cx = margin + (currentPos.x - minX) * scale;
    const cy = margin + (currentPos.y - minY) * scale;
    
    // è·é›¢ã‚µãƒ¼ã‚¯ãƒ«ã‚’æç”»
    drawDistanceCircles(ctx, cx, cy, scale);
    
    // è»Šä¸¡ã‚’æç”»
    drawVehicle(ctx, cx, cy, currentPos.theta, scale / mapZoom);
  }

  ctx.restore();
  
  // å¤‰æ›ã‚’é©ç”¨ã—ãªã„è¦ç´ ï¼ˆå‡¡ä¾‹ã€ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã€ã‚³ãƒ³ãƒ‘ã‚¹ã€ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒœã‚¿ãƒ³ã€æ³¨é‡ˆï¼‰
  drawLegend(ctx, canvas, activeSensors);
  drawScaleInfo(ctx, canvas, scale);
  drawCompass(ctx, canvas);
  drawMedianFilterButton(ctx, canvas);
  
  // æ³¨é‡ˆã‚’æç”»ï¼ˆå¤‰æ›ã®å¤–ã§ã€æ‰‹å‹•ã§åº§æ¨™å¤‰æ›ï¼‰
  drawAnnotations(ctx, minX, minY, scale, margin, centerX, centerY);
}

// ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒœã‚¿ãƒ³æç”»
function drawMedianFilterButton(ctx, canvas) {
  const btnX = canvas.width - 80;
  const btnY = 150;  // ã‚³ãƒ³ãƒ‘ã‚¹ã®ä¸‹
  const btnWidth = 120;
  const btnHeight = 30;
  
  ctx.save();
  
  // ãƒœã‚¿ãƒ³èƒŒæ™¯
  if (medianFilterEnabled) {
    ctx.fillStyle = 'rgba(78,205,196,0.9)';
  } else {
    ctx.fillStyle = 'rgba(60,60,60,0.9)';
  }
  ctx.strokeStyle = medianFilterEnabled ? 'rgba(78,205,196,1)' : 'rgba(100,100,100,1)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(btnX - btnWidth/2, btnY - btnHeight/2, btnWidth, btnHeight, 5);
  ctx.fill();
  ctx.stroke();
  
  // ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
  ctx.fillStyle = medianFilterEnabled ? '#fff' : '#aaa';
  ctx.font = 'bold 12px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(medianFilterEnabled ? 'âœ“ Filter ON' : 'Filter OFF', btnX, btnY);
  
  ctx.restore();
  
  // ãƒœã‚¿ãƒ³ã®ä½ç½®ã‚’ä¿å­˜ï¼ˆã‚¯ãƒªãƒƒã‚¯åˆ¤å®šç”¨ï¼‰
  if (!canvas.medianBtnBounds) {
    canvas.medianBtnBounds = {};
  }
  canvas.medianBtnBounds.x = btnX - btnWidth/2;
  canvas.medianBtnBounds.y = btnY - btnHeight/2;
  canvas.medianBtnBounds.width = btnWidth;
  canvas.medianBtnBounds.height = btnHeight;
}

// ã‚³ãƒ³ãƒ‘ã‚¹æç”»
function drawCompass(ctx, canvas) {
  const compassX = canvas.width - 80;
  const compassY = 80;
  const compassRadius = 40;
  
  ctx.save();
  
  // èƒŒæ™¯å††
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.beginPath();
  ctx.arc(compassX, compassY, compassRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // å¤–æ 
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // å›è»¢ã‚’é©ç”¨
  ctx.translate(compassX, compassY);
  ctx.rotate(mapRotation);
  
  // åŒ—ã‚’æŒ‡ã™çŸ¢å°ï¼ˆèµ¤ï¼‰
  ctx.fillStyle = '#ff4444';
  ctx.beginPath();
  ctx.moveTo(0, -compassRadius * 0.7);
  ctx.lineTo(-compassRadius * 0.2, 0);
  ctx.lineTo(0, -compassRadius * 0.3);
  ctx.lineTo(compassRadius * 0.2, 0);
  ctx.closePath();
  ctx.fill();
  
  // å—ã‚’æŒ‡ã™çŸ¢å°ï¼ˆç™½ï¼‰
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(0, compassRadius * 0.7);
  ctx.lineTo(-compassRadius * 0.2, 0);
  ctx.lineTo(0, compassRadius * 0.3);
  ctx.lineTo(compassRadius * 0.2, 0);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
  
  // Næ–‡å­—ï¼ˆå¸¸ã«ä¸Šå‘ãï¼‰
  ctx.fillStyle = '#ff4444';
  ctx.font = 'bold 16px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('N', compassX, compassY - compassRadius - 15);
}

// ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±æç”»
function drawScaleInfo(ctx, canvas, scale) {
  const infoX = 20;
  const infoY = 20;
  
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(infoX - 10, infoY - 10, 220, 130);
  
  ctx.fillStyle = '#4ecdc4';
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'left';
  ctx.fillText('ğŸ“ ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±', infoX, infoY + 15);
  
  ctx.fillStyle = '#fff';
  ctx.font = '12px Arial';
  ctx.fillText(`è»Šä¸¡: ${VEHICLE_LENGTH}Ã—${VEHICLE_WIDTH}mm`, infoX, infoY + 40);
  ctx.fillText(`ã‚³ãƒ¼ã‚¹å¹…: ç´„${COURSE_WIDTH}mm`, infoX, infoY + 60);
  ctx.fillText(`è¡¨ç¤ºå€ç‡: Ã—${(scale * mapZoom).toFixed(3)}`, infoX, infoY + 80);
  ctx.fillText(`ã‚ºãƒ¼ãƒ : ${mapZoom.toFixed(1)}x`, infoX, infoY + 100);
  
  const barLength = 100 * scale * mapZoom;
  ctx.strokeStyle = '#4ecdc4';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(infoX, infoY + 115);
  ctx.lineTo(infoX + barLength, infoY + 115);
  ctx.stroke();
  
  ctx.fillStyle = '#4ecdc4';
  ctx.font = '11px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('100mm', infoX + barLength / 2, infoY + 110);
}

// å‡¡ä¾‹æç”»
function drawLegend(ctx, canvas, activeSensors) {
  const legendX = canvas.width - 180;
  const legendY = 170;  // ã‚³ãƒ³ãƒ‘ã‚¹ã®ä¸‹ã«é…ç½®
  const lineHeight = 25;
  
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(legendX - 10, legendY - 10, 170, activeSensors.length * lineHeight + 50);
  
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'left';
  ctx.fillText('ã‚»ãƒ³ã‚µãƒ¼å‡¡ä¾‹', legendX, legendY + 15);
  
  ctx.font = '12px Arial';
  activeSensors.forEach((name, i) => {
    const color = sensorColors[name];
    const y = legendY + 40 + i * lineHeight;
    
    ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
    ctx.beginPath();
    ctx.arc(legendX + 10, y, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    const angle = sensorAngles[name] || 0;
    ctx.fillText(`${name} (${angle}Â°)`, legendX + 25, y + 4);
  });
}

// è·é›¢ã‚µãƒ¼ã‚¯ãƒ«æç”»
function drawDistanceCircles(ctx, x, y, scale) {
  const distances = [500, 1000, 1500, 2000, 2500, 3000];
  
  ctx.save();
  distances.forEach((dist, index) => {
    const radius = dist * scale;
    ctx.strokeStyle = `rgba(255,255,255,${0.3 - index * 0.07})`;
    ctx.lineWidth = 1 / mapZoom;
    ctx.setLineDash([5 / mapZoom, 5 / mapZoom]);
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // è·é›¢ãƒ©ãƒ™ãƒ«
    ctx.fillStyle = `rgba(255,255,255,${0.5 - index * 0.1})`;
    ctx.font = `${10 / mapZoom}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(`${dist}mm`, x, y - radius - 3 / mapZoom);
  });
  ctx.setLineDash([]);
  ctx.restore();
}

// ãƒãƒ¼ã‚«ãƒ¼æç”»ï¼ˆã²ã—å½¢ãƒ—ãƒ­ãƒƒãƒˆï¼‰
function drawMarkers(ctx, minX, minY, scale, margin) {
  ctx.save();
  
  // å„ãƒã‚¤ãƒ³ãƒˆã§ã©ã®ãƒ«ãƒ¼ãƒ«ãŒè©²å½“ã™ã‚‹ã‹ã‚’é›†è¨ˆ
  const markerAtPoint = {};
  
  ['rule1', 'rule2', 'rule3'].forEach(rule => {
    if (markerSettings[rule].enabled) {
      markersByRule[rule].forEach(idx => {
        if (!markerAtPoint[idx]) {
          markerAtPoint[idx] = [];
        }
        markerAtPoint[idx].push(rule);
      });
    }
  });
  
  // å„ãƒã‚¤ãƒ³ãƒˆã«ã²ã—å½¢ã‚’æç”»
  Object.keys(markerAtPoint).forEach(idx => {
    const i = parseInt(idx);
    if (i >= positions.length) return;
    
    const pos = positions[i];
    const cx = margin + (pos.x - minX) * scale;
    const cy = margin + (pos.y - minY) * scale;
    
    const rules = markerAtPoint[idx];
    const count = rules.length;
    
    // ã²ã—å½¢ã®ã‚µã‚¤ã‚ºï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã‚’ä½¿ç”¨ï¼‰
    const diamondSize = markerSize / mapZoom;
    
    // è¤‡æ•°ãƒ«ãƒ¼ãƒ«è©²å½“æ™‚ã®é…ç½®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    const offsetDistance = diamondSize * 1.8;
    const positions_offsets = getMarkerOffsets(count, offsetDistance);
    
    rules.forEach((rule, ruleIdx) => {
      const color = markerSettings[rule].color;
      const offset = positions_offsets[ruleIdx];
      
      const dx = cx + offset.x;
      const dy = cy + offset.y;
      
      // ã²ã—å½¢ã‚’æç”»
      ctx.save();
      ctx.translate(dx, dy);
      
      // å¡—ã‚Šã¤ã¶ã—
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(0, -diamondSize);  // ä¸Š
      ctx.lineTo(diamondSize, 0);   // å³
      ctx.lineTo(0, diamondSize);   // ä¸‹
      ctx.lineTo(-diamondSize, 0);  // å·¦
      ctx.closePath();
      ctx.fill();
      
      // è¼ªéƒ­
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.lineWidth = 2 / mapZoom;
      ctx.globalAlpha = 1.0;
      ctx.stroke();
      
      ctx.restore();
    });
  });
  
  ctx.restore();
}

// ãƒãƒ¼ã‚«ãƒ¼ã®é…ç½®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
function getMarkerOffsets(count, distance) {
  const offsets = [];
  
  if (count === 1) {
    // 1ã¤ï¼šä¸­å¿ƒ
    offsets.push({ x: 0, y: 0 });
  } else if (count === 2) {
    // 2ã¤ï¼šä¸Šä¸‹ã«é…ç½®
    offsets.push({ x: 0, y: -distance });
    offsets.push({ x: 0, y: distance });
  } else if (count === 3) {
    // 3ã¤ï¼šä¸‰è§’å½¢ã«é…ç½®ï¼ˆä¸Šã€å·¦ä¸‹ã€å³ä¸‹ï¼‰
    const angle1 = -Math.PI / 2;  // ä¸Š
    const angle2 = Math.PI / 6;   // å³ä¸‹
    const angle3 = Math.PI * 5 / 6; // å·¦ä¸‹
    
    offsets.push({ 
      x: Math.cos(angle1) * distance, 
      y: Math.sin(angle1) * distance 
    });
    offsets.push({ 
      x: Math.cos(angle2) * distance, 
      y: Math.sin(angle2) * distance 
    });
    offsets.push({ 
      x: Math.cos(angle3) * distance, 
      y: Math.sin(angle3) * distance 
    });
  }
  
  return offsets;
}

// æ³¨é‡ˆæç”»
function drawAnnotations(ctx, minX, minY, scale, margin, centerX, centerY) {
  if (annotations.length === 0) return;
  
  annotations.forEach(annotation => {
    // è»Šä¸¡ä½ç½®ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã«å¤‰æ›ï¼ˆå¤‰æ›å‰ï¼‰
    const baseX = margin + (annotation.vehicleX - minX) * scale;
    const baseY = margin + (annotation.vehicleY - minY) * scale;
    
    // æ‰‹å‹•ã§å¤‰æ›ã‚’é©ç”¨ï¼ˆã‚ºãƒ¼ãƒ /å›è»¢/ãƒ‘ãƒ³ï¼‰
    // 1. ä¸­å¿ƒã‚’åŸç‚¹ã¨ã™ã‚‹åº§æ¨™ç³»ã«å¤‰æ›
    let tx = baseX - centerX;
    let ty = baseY - centerY;
    
    // 2. å›è»¢ã‚’é©ç”¨
    const rotatedX = tx * Math.cos(mapRotation) - ty * Math.sin(mapRotation);
    const rotatedY = tx * Math.sin(mapRotation) + ty * Math.cos(mapRotation);
    
    // 3. ã‚ºãƒ¼ãƒ ã‚’é©ç”¨
    const zoomedX = rotatedX * mapZoom;
    const zoomedY = rotatedY * mapZoom;
    
    // 4. ãƒ‘ãƒ³ã¨ã‚»ãƒ³ã‚¿ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨
    const vehicleCanvasX = zoomedX + centerX + mapOffsetX;
    const vehicleCanvasY = zoomedY + centerY + mapOffsetY;
    
    // æ³¨é‡ˆãƒœãƒƒã‚¯ã‚¹ã®ä½ç½®ï¼ˆã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨ï¼‰
    const boxX = vehicleCanvasX + annotation.offsetX;
    const boxY = vehicleCanvasY + annotation.offsetY;
    
    ctx.save();
    
    // çŸ¢å°ã‚’æç”»ï¼ˆè»Šä¸¡ä½ç½®ã‹ã‚‰æ³¨é‡ˆãƒœãƒƒã‚¯ã‚¹ã¸ï¼‰
    ctx.strokeStyle = 'rgba(255,215,0,0.8)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    ctx.moveTo(vehicleCanvasX, vehicleCanvasY);
    ctx.lineTo(boxX, boxY + annotation.height / 2);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // çŸ¢å°ã®å…ˆç«¯
    const arrowSize = 8;
    const angle = Math.atan2(boxY + annotation.height / 2 - vehicleCanvasY, boxX - vehicleCanvasX);
    ctx.fillStyle = 'rgba(255,215,0,0.8)';
    ctx.beginPath();
    ctx.moveTo(vehicleCanvasX, vehicleCanvasY);
    ctx.lineTo(
      vehicleCanvasX + arrowSize * Math.cos(angle - Math.PI / 6),
      vehicleCanvasY + arrowSize * Math.sin(angle - Math.PI / 6)
    );
    ctx.lineTo(
      vehicleCanvasX + arrowSize * Math.cos(angle + Math.PI / 6),
      vehicleCanvasY + arrowSize * Math.sin(angle + Math.PI / 6)
    );
    ctx.closePath();
    ctx.fill();
    
    // æ³¨é‡ˆãƒœãƒƒã‚¯ã‚¹ã®èƒŒæ™¯
    const isSelected = selectedAnnotation === annotation;
    ctx.fillStyle = `rgba(50, 50, 50, ${annotation.opacity})`;
    if (isSelected) {
      ctx.strokeStyle = 'rgba(255,215,0,1)';
      ctx.lineWidth = 3;
    } else {
      ctx.strokeStyle = 'rgba(255,215,0,0.6)';
      ctx.lineWidth = 2;
    }
    
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, annotation.width, annotation.height, 8);
    ctx.fill();
    ctx.stroke();
    
    // ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»
    ctx.fillStyle = '#ffffff';
    ctx.font = '14px Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    
    // ãƒ†ã‚­ã‚¹ãƒˆã‚’æ”¹è¡Œã¨å˜èªã§åˆ†å‰²ã—ã¦æç”»
    const paragraphs = annotation.text.split('\n');
    let lines = [];
    const maxWidth = annotation.width - 20;
    
    paragraphs.forEach(paragraph => {
      if (!paragraph.trim()) {
        lines.push(''); // ç©ºè¡Œã‚’ä¿æŒ
        return;
      }
      
      const words = paragraph.split(' ');
      let currentLine = '';
      
      words.forEach(word => {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && currentLine) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      });
      if (currentLine) lines.push(currentLine);
    });
    
    // æœ€å¤§5è¡Œã¾ã§è¡¨ç¤º
    const lineHeight = 18;
    lines.slice(0, 5).forEach((line, i) => {
      ctx.fillText(line, boxX + 10, boxY + 10 + i * lineHeight);
    });
    
    // é¸æŠä¸­ã®æ³¨é‡ˆã«ã¯æ“ä½œãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤º
    if (isSelected) {
      ctx.fillStyle = 'rgba(255,215,0,0.8)';
      ctx.font = '10px Arial';
      ctx.fillText('E:ç·¨é›† D:å‰Šé™¤ â†‘â†“:é€æ˜åº¦', boxX + 10, boxY + annotation.height - 15);
    }
    
    // æ³¨é‡ˆã®æƒ…å ±ã‚’ä¿å­˜ï¼ˆã‚¯ãƒªãƒƒã‚¯åˆ¤å®šç”¨ï¼‰
    annotation._canvasBounds = {
      x: boxX,
      y: boxY,
      width: annotation.width,
      height: annotation.height
    };
    
    ctx.restore();
  });
}

// è»Šä¸¡æç”»
function drawVehicle(ctx, x, y, theta, scale) {
  const length = VEHICLE_LENGTH * scale * vehicleSizeMultiplier;
  const width = VEHICLE_WIDTH * scale * vehicleSizeMultiplier;
  
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(theta);
  
  ctx.beginPath();
  ctx.moveTo(length * 0.4, 0);
  ctx.lineTo(length * 0.1, -width * 0.5);
  ctx.lineTo(-length * 0.4, -width * 0.5);
  ctx.lineTo(-length * 0.4, width * 0.5);
  ctx.lineTo(length * 0.1, width * 0.5);
  ctx.closePath();
  
  ctx.fillStyle = 'rgba(0,255,100,0.7)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.9)';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(length * 0.1, 0);
  ctx.lineTo(length * 0.4, 0);
  ctx.strokeStyle = 'rgba(255,255,0,1)';
  ctx.lineWidth = 3;
  ctx.stroke();
  
  ctx.restore();
}

// ç·šå½¢è£œé–“
function interpolateMap(mapArray, value) {
  if (!mapArray.length) return 0;
  
  mapArray.sort((a,b)=>a.key-b.key);
  if (value <= mapArray[0].key) return mapArray[0].value;
  if (value >= mapArray[mapArray.length-1].key) return mapArray[mapArray.length-1].value;
  for(let i=0;i<mapArray.length-1;i++){
    if(value>=mapArray[i].key && value<=mapArray[i+1].key){
      const v0=mapArray[i].value,v1=mapArray[i+1].value;
      const t=(value-mapArray[i].key)/(mapArray[i+1].key-mapArray[i].key);
      return v0+t*(v1-v0);
    }
  }
  return 0;
}

// åˆ¶å¾¡ã‚°ãƒ©ãƒ•æç”»
function drawControlGraph() {
  if (!controlCtx || !csvData.length || !headers.length) return;
  
  const strIdx = headers.indexOf('Str');
  const thrIdx = headers.indexOf('Thr');
  
  if (strIdx < 0 || thrIdx < 0) return;
  
  const canvas = controlGraph;
  const ctx = controlCtx;
  const width = canvas.width;
  const height = canvas.height;
  const marginLeft = 45;
  const marginRight = 45;
  const marginTop = 20;
  const marginBottom = 25;
  const graphWidth = width - marginLeft - marginRight;
  const graphHeight = height - marginTop - marginBottom;
  
  // ã‚¯ãƒªã‚¢
  ctx.clearRect(0, 0, width, height);
  
  // èƒŒæ™¯
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(marginLeft, marginTop, graphWidth, graphHeight);
  
  // ã‚°ãƒªãƒƒãƒ‰
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 5; i++) {
    const y = marginTop + (i / 5) * graphHeight;
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + graphWidth, y);
    ctx.stroke();
  }
  
  // è»¸ç·š
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;
  ctx.strokeRect(marginLeft, marginTop, graphWidth, graphHeight);
  
  // Str (èˆµè§’) ã®ç¯„å›²: -100 ~ 100
  // Thr (é§†å‹•) ã®ç¯„å›²: 0 ~ 100
  const strMin = -100;
  const strMax = 100;
  const thrMin = 0;
  const thrMax = 100;
  
  // Xè»¸ï¼šãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  const dataLength = csvData.length;
  
  // ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°é ˜åŸŸã‚’è¨­å®š
  ctx.save();
  ctx.beginPath();
  ctx.rect(marginLeft, marginTop, graphWidth, graphHeight);
  ctx.clip();
  
  // ã‚ºãƒ¼ãƒ ã¨ãƒ‘ãƒ³ã‚’é©ç”¨ã—ãŸå¤‰æ›
  const centerX = marginLeft + graphWidth / 2;
  const centerY = marginTop + graphHeight / 2;
  
  ctx.translate(centerX + controlGraphOffsetX, centerY + controlGraphOffsetY);
  ctx.scale(controlGraphZoomX, controlGraphZoomY);
  ctx.translate(-centerX, -centerY);
  
  // Str (é’è‰²) ã‚’æç”»
  ctx.strokeStyle = '#4ecdc4';
  ctx.lineWidth = 2 / Math.sqrt(controlGraphZoomX * controlGraphZoomY);
  ctx.beginPath();
  csvData.forEach((row, i) => {
    const str = parseFloat(row[strIdx]);
    const x = marginLeft + (i / (dataLength - 1)) * graphWidth;
    const y = marginTop + graphHeight - ((str - strMin) / (strMax - strMin)) * graphHeight;
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  });
  ctx.stroke();
  
  // Thr (èµ¤è‰²) ã‚’æç”»
  ctx.strokeStyle = '#ff6b6b';
  ctx.lineWidth = 2 / Math.sqrt(controlGraphZoomX * controlGraphZoomY);
  ctx.beginPath();
  csvData.forEach((row, i) => {
    const thr = parseFloat(row[thrIdx]);
    const x = marginLeft + (i / (dataLength - 1)) * graphWidth;
    const y = marginTop + graphHeight - ((thr - thrMin) / (thrMax - thrMin)) * graphHeight;
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  });
  ctx.stroke();
  
  // ç¾åœ¨ä½ç½®ã®ãƒãƒ¼ã‚«ãƒ¼ï¼ˆç¸¦ç·šã¨ç‚¹ï¼‰
  if (currentTimeIndex < dataLength) {
    const x = marginLeft + (currentTimeIndex / (dataLength - 1)) * graphWidth;
    
    // ç¸¦ç·š
    ctx.strokeStyle = 'rgba(255,255,0,0.6)';
    ctx.lineWidth = 2 / Math.sqrt(controlGraphZoomX * controlGraphZoomY);
    ctx.setLineDash([5 / controlGraphZoomX, 5 / controlGraphZoomX]);
    ctx.beginPath();
    ctx.moveTo(x, marginTop);
    ctx.lineTo(x, marginTop + graphHeight);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Str ã®ç‚¹
    const str = parseFloat(csvData[currentTimeIndex][strIdx]);
    const strY = marginTop + graphHeight - ((str - strMin) / (strMax - strMin)) * graphHeight;
    ctx.fillStyle = '#4ecdc4';
    ctx.beginPath();
    ctx.arc(x, strY, 5 / Math.sqrt(controlGraphZoomX * controlGraphZoomY), 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 2 / Math.sqrt(controlGraphZoomX * controlGraphZoomY);
    ctx.stroke();
    
    // Thr ã®ç‚¹
    const thr = parseFloat(csvData[currentTimeIndex][thrIdx]);
    const thrY = marginTop + graphHeight - ((thr - thrMin) / (thrMax - thrMin)) * graphHeight;
    ctx.fillStyle = '#ff6b6b';
    ctx.beginPath();
    ctx.arc(x, thrY, 5 / Math.sqrt(controlGraphZoomX * controlGraphZoomY), 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 2 / Math.sqrt(controlGraphZoomX * controlGraphZoomY);
    ctx.stroke();
  }
  
  ctx.restore();
  
  // è¡¨ç¤ºç¯„å›²ã‚’è¨ˆç®—ï¼ˆã‚ºãƒ¼ãƒ ã¨ãƒ‘ãƒ³ã‚’è€ƒæ…®ï¼‰
  // é€†å¤‰æ›è¡Œåˆ—ã‚’ä½¿ã£ã¦ç”»é¢åº§æ¨™ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿åº§æ¨™ã‚’è¨ˆç®—
  const getDataCoords = (screenX, screenY) => {
    const dx = screenX - centerX - controlGraphOffsetX;
    const dy = screenY - centerY - controlGraphOffsetY;
    const dataX = centerX + dx / controlGraphZoomX;
    const dataY = centerY + dy / controlGraphZoomY;
    return { x: dataX, y: dataY };
  };
  
  // è¡¨ç¤ºç¯„å›²ã®å·¦ä¸Šã¨å³ä¸‹ã®ãƒ‡ãƒ¼ã‚¿åº§æ¨™ã‚’å–å¾—
  const topLeft = getDataCoords(marginLeft, marginTop);
  const bottomRight = getDataCoords(marginLeft + graphWidth, marginTop + graphHeight);
  
  // ãƒ‡ãƒ¼ã‚¿å€¤ã®ç¯„å›²ã‚’è¨ˆç®—
  const visibleDataIndexMin = Math.max(0, ((topLeft.x - marginLeft) / graphWidth) * (dataLength - 1));
  const visibleDataIndexMax = Math.min(dataLength - 1, ((bottomRight.x - marginLeft) / graphWidth) * (dataLength - 1));
  
  const visibleStrMin = strMax - ((bottomRight.y - marginTop) / graphHeight) * (strMax - strMin);
  const visibleStrMax = strMax - ((topLeft.y - marginTop) / graphHeight) * (strMax - strMin);
  
  const visibleThrMin = thrMax - ((bottomRight.y - marginTop) / graphHeight) * (thrMax - thrMin);
  const visibleThrMax = thrMax - ((topLeft.y - marginTop) / graphHeight) * (thrMax - thrMin);
  
  // Yè»¸ãƒ©ãƒ™ãƒ« (å·¦å´: Str) - è¡¨ç¤ºç¯„å›²ã«åˆã‚ã›ã¦
  ctx.fillStyle = '#4ecdc4';
  ctx.font = 'bold 11px Arial';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 5; i++) {
    const value = visibleStrMin + (i / 5) * (visibleStrMax - visibleStrMin);
    const y = marginTop + graphHeight - (i / 5) * graphHeight;
    ctx.fillText(value.toFixed(0), marginLeft - 8, y + 4);
  }
  
  // Yè»¸ã‚¿ã‚¤ãƒˆãƒ« (å·¦å´)
  ctx.save();
  ctx.translate(12, marginTop + graphHeight / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.fillStyle = '#4ecdc4';
  ctx.font = 'bold 12px Arial';
  ctx.fillText('Str (èˆµè§’ %)', 0, 0);
  ctx.restore();
  
  // Yè»¸ãƒ©ãƒ™ãƒ« (å³å´: Thr) - è¡¨ç¤ºç¯„å›²ã«åˆã‚ã›ã¦
  ctx.fillStyle = '#ff6b6b';
  ctx.font = 'bold 11px Arial';
  ctx.textAlign = 'left';
  for (let i = 0; i <= 5; i++) {
    const value = visibleThrMin + (i / 5) * (visibleThrMax - visibleThrMin);
    const y = marginTop + graphHeight - (i / 5) * graphHeight;
    ctx.fillText(value.toFixed(0), marginLeft + graphWidth + 8, y + 4);
  }
  
  // Yè»¸ã‚¿ã‚¤ãƒˆãƒ« (å³å´)
  ctx.save();
  ctx.translate(width - 12, marginTop + graphHeight / 2);
  ctx.rotate(Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.fillStyle = '#ff6b6b';
  ctx.font = 'bold 12px Arial';
  ctx.fillText('Thr (é§†å‹• %)', 0, 0);
  ctx.restore();
  
  // Xè»¸ãƒ©ãƒ™ãƒ« - è¡¨ç¤ºç¯„å›²ã«åˆã‚ã›ã¦
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 5; i++) {
    const index = Math.floor(visibleDataIndexMin + (i / 5) * (visibleDataIndexMax - visibleDataIndexMin));
    const x = marginLeft + (i / 5) * graphWidth;
    ctx.fillText(index, x, height - 8);
  }
  
  // Xè»¸ã‚¿ã‚¤ãƒˆãƒ«
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.font = 'bold 11px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹', marginLeft + graphWidth / 2, height - 2);
}

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•æç”»
function drawSensorGraph() {
  if (!sensorCtx || !csvData || csvData.length === 0) return;
  
  // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãŒæœ‰åŠ¹ãªå ´åˆã¯ãƒ•ã‚£ãƒ«ã‚¿æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
  const dataSource = (medianFilterEnabled && filteredData.length > 0) ? filteredData : csvData;
  
  const canvas = sensorGraph;
  const ctx = sensorCtx;
  const width = canvas.width;
  const height = canvas.height;
  
  if (!width || !height) return;
  
  // é¸æŠã•ã‚ŒãŸã‚»ãƒ³ã‚µã‚’å–å¾—
  const selectedSensors = Array.from(document.querySelectorAll('.sensor-select-checkbox input:checked'))
    .map(cb => cb.value);
  
  const sensorColors = {
    'RrLH': '#ff3296',
    'FrLH': '#64c8ff',
    'Fr': '#32ff32',
    'FrRH': '#ffc832',
    'RrRH': '#ff6432'
  };
  
  const marginLeft = 60;
  const marginRight = 30;
  const marginTop = 30;
  const marginBottom = 40;
  const graphWidth = width - marginLeft - marginRight;
  const graphHeight = height - marginTop - marginBottom;
  
  const dataLength = dataSource.length;
  
  // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, width, height);
  
  // ã‚»ãƒ³ã‚µãŒãªã„å ´åˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  if (selectedSensors.length === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ã‚»ãƒ³ã‚µã‚’é¸æŠã—ã¦ãã ã•ã„', width / 2, height / 2);
    return;
  }
  
  // å„ã‚»ãƒ³ã‚µã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
  const sensorIndices = {};
  selectedSensors.forEach(sensor => {
    const idx = headers.indexOf(sensor);
    if (idx !== -1) {
      sensorIndices[sensor] = idx;
    }
  });
  
  // å…¨ã‚»ãƒ³ã‚µã®ãƒ‡ãƒ¼ã‚¿ç¯„å›²ã‚’è¨ˆç®—ï¼ˆã™ã¹ã¦åŒã˜Yè»¸ï¼‰
  let allMin = Infinity;
  let allMax = -Infinity;
  
  Object.values(sensorIndices).forEach(idx => {
    dataSource.forEach(row => {
      const value = parseFloat(row[idx]);
      if (!isNaN(value)) {
        allMin = Math.min(allMin, value);
        allMax = Math.max(allMax, value);
      }
    });
  });
  
  if (!isFinite(allMin) || !isFinite(allMax)) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', width / 2, height / 2);
    return;
  }
  
  // ç¯„å›²ã«ä½™è£•ã‚’æŒãŸã›ã‚‹
  const range = allMax - allMin;
  allMin -= range * 0.1;
  allMax += range * 0.1;
  
  // ã‚°ãƒªãƒƒãƒ‰ç·šã‚’æç”»
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 5; i++) {
    const y = marginTop + (i / 5) * graphHeight;
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + graphWidth, y);
    ctx.stroke();
  }
  
  // è»¸ã‚’æç”»
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;
  ctx.strokeRect(marginLeft, marginTop, graphWidth, graphHeight);
  
  // ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°é ˜åŸŸã‚’è¨­å®š
  ctx.save();
  ctx.beginPath();
  ctx.rect(marginLeft, marginTop, graphWidth, graphHeight);
  ctx.clip();
  
  // ã‚ºãƒ¼ãƒ ã¨ãƒ‘ãƒ³ã‚’é©ç”¨
  const centerX = marginLeft + graphWidth / 2;
  const centerY = marginTop + graphHeight / 2;
  
  ctx.translate(centerX + sensorGraphOffsetX, centerY + sensorGraphOffsetY);
  ctx.scale(sensorGraphZoomX, sensorGraphZoomY);
  ctx.translate(-centerX, -centerY);
  
  // å„ã‚»ãƒ³ã‚µã®ãƒ©ã‚¤ãƒ³ã‚’æç”»
  selectedSensors.forEach(sensor => {
    const idx = sensorIndices[sensor];
    if (idx === undefined) return;
    
    const color = sensorColors[sensor];
    ctx.strokeStyle = color;
    ctx.lineWidth = 2 / Math.sqrt(sensorGraphZoomX * sensorGraphZoomY);
    ctx.beginPath();
    
    dataSource.forEach((row, i) => {
      const value = parseFloat(row[idx]);
      if (isNaN(value)) return;
      
      const x = marginLeft + (i / (dataLength - 1)) * graphWidth;
      const y = marginTop + graphHeight - ((value - allMin) / (allMax - allMin)) * graphHeight;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    ctx.stroke();
  });
  
  // ç¾åœ¨ä½ç½®ã®ãƒãƒ¼ã‚«ãƒ¼
  if (currentTimeIndex < dataLength) {
    const x = marginLeft + (currentTimeIndex / (dataLength - 1)) * graphWidth;
    
    // ç¸¦ç·š
    ctx.strokeStyle = 'rgba(255,255,0,0.6)';
    ctx.lineWidth = 2 / Math.sqrt(sensorGraphZoomX * sensorGraphZoomY);
    ctx.setLineDash([5 / sensorGraphZoomX, 5 / sensorGraphZoomX]);
    ctx.beginPath();
    ctx.moveTo(x, marginTop);
    ctx.lineTo(x, marginTop + graphHeight);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // å„ã‚»ãƒ³ã‚µã®ç¾åœ¨ä½ç½®ã®ç‚¹
    selectedSensors.forEach(sensor => {
      const idx = sensorIndices[sensor];
      if (idx === undefined) return;
      
      const value = parseFloat(dataSource[currentTimeIndex][idx]);
      if (isNaN(value)) return;
      
      const y = marginTop + graphHeight - ((value - allMin) / (allMax - allMin)) * graphHeight;
      const color = sensorColors[sensor];
      
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, 5 / Math.sqrt(sensorGraphZoomX * sensorGraphZoomY), 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 2 / Math.sqrt(sensorGraphZoomX * sensorGraphZoomY);
      ctx.stroke();
    });
  }
  
  ctx.restore();
  
  // è¡¨ç¤ºç¯„å›²ã‚’è¨ˆç®—
  const getDataCoords = (screenX, screenY) => {
    const dx = screenX - centerX - sensorGraphOffsetX;
    const dy = screenY - centerY - sensorGraphOffsetY;
    const dataX = centerX + dx / sensorGraphZoomX;
    const dataY = centerY + dy / sensorGraphZoomY;
    return { x: dataX, y: dataY };
  };
  
  const topLeft = getDataCoords(marginLeft, marginTop);
  const bottomRight = getDataCoords(marginLeft + graphWidth, marginTop + graphHeight);
  
  const visibleDataIndexMin = Math.max(0, ((topLeft.x - marginLeft) / graphWidth) * (dataLength - 1));
  const visibleDataIndexMax = Math.min(dataLength - 1, ((bottomRight.x - marginLeft) / graphWidth) * (dataLength - 1));
  
  const visibleMin = allMax - ((bottomRight.y - marginTop) / graphHeight) * (allMax - allMin);
  const visibleMax = allMax - ((topLeft.y - marginTop) / graphHeight) * (allMax - allMin);
  
  // Yè»¸ãƒ©ãƒ™ãƒ«
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.font = 'bold 11px Arial';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 5; i++) {
    const value = visibleMin + (i / 5) * (visibleMax - visibleMin);
    const y = marginTop + graphHeight - (i / 5) * graphHeight;
    ctx.fillText(value.toFixed(0), marginLeft - 8, y + 4);
  }
  
  // Yè»¸ã‚¿ã‚¤ãƒˆãƒ«
  ctx.save();
  ctx.translate(15, marginTop + graphHeight / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.font = 'bold 12px Arial';
  ctx.fillText('ã‚»ãƒ³ã‚µå€¤ (mm)', 0, 0);
  ctx.restore();
  
  // Xè»¸ãƒ©ãƒ™ãƒ«
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 5; i++) {
    const index = Math.floor(visibleDataIndexMin + (i / 5) * (visibleDataIndexMax - visibleDataIndexMin));
    const x = marginLeft + (i / 5) * graphWidth;
    ctx.fillText(index, x, height - 8);
  }
  
  // Xè»¸ã‚¿ã‚¤ãƒˆãƒ«
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.font = 'bold 11px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹', marginLeft + graphWidth / 2, height - 2);
  
  // å‡¡ä¾‹
  const legendX = marginLeft + 10;
  const legendY = marginTop + 10;
  const legendLineHeight = 18;
  
  ctx.font = '11px Arial';
  selectedSensors.forEach((sensor, i) => {
    const color = sensorColors[sensor];
    const y = legendY + i * legendLineHeight;
    
    // è‰²ã®ãƒœãƒƒã‚¯ã‚¹
    ctx.fillStyle = color;
    ctx.fillRect(legendX, y - 8, 12, 12);
    
    // ã‚»ãƒ³ã‚µå
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.textAlign = 'left';
    ctx.fillText(sensor, legendX + 18, y + 2);
  });
}
</script>
</body>
</html>

