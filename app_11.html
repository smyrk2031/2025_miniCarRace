<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ãƒŸãƒ‹ã‚«ãƒ¼SLAM Pro - é«˜åº¦æ“ä½œç‰ˆ</title>
<style>
* { box-sizing: border-box; }
body { 
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
  margin: 0; 
  padding: 0; 
  background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
  color: #fff;
  overflow-x: hidden;
}

.container {
  display: flex;
  height: 100vh;
}

.sidebar {
  width: 500px;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(10px);
  padding: 20px;
  overflow-y: auto;
  border-right: 2px solid rgba(255,255,255,0.1);
}

.main-content {
  flex: 1;
  padding: 20px;
  display: flex;
  flex-direction: column;
}

.table-sidebar {
  width: 400px;
  min-width: 200px;
  max-width: 800px;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(10px);
  border-left: 2px solid rgba(255,255,255,0.1);
  display: flex;
  flex-direction: column;
  position: relative;
  transition: width 0.3s ease;
}

.table-sidebar.closed {
  width: 0;
  min-width: 0;
  padding: 0;
  overflow: hidden;
}

.table-header {
  padding: 15px;
  background: rgba(255,255,255,0.1);
  border-bottom: 2px solid rgba(255,255,255,0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.table-header h3 {
  margin: 0;
  color: #4ecdc4;
  font-size: 1.1em;
}

.table-toggle-btn {
  position: absolute;
  left: -30px;
  top: 50%;
  transform: translateY(-50%);
  width: 30px;
  height: 60px;
  background: rgba(78,205,196,0.8);
  border: none;
  border-radius: 5px 0 0 5px;
  color: white;
  font-size: 18px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  z-index: 10;
}

.table-toggle-btn:hover {
  background: rgba(78,205,196,1);
  left: -32px;
}

.table-resize-handle {
  position: absolute;
  left: 0;
  top: 0;
  width: 5px;
  height: 100%;
  cursor: ew-resize;
  background: transparent;
  transition: background 0.3s ease;
}

.table-resize-handle:hover {
  background: rgba(78,205,196,0.5);
}

.table-container {
  flex: 1;
  overflow: auto;
  padding: 10px;
}

.data-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
  color: #fff;
}

.data-table thead {
  position: sticky;
  top: 0;
  background: rgba(0,0,0,0.95);
  z-index: 2;
}

.data-table th {
  padding: 8px 4px;
  text-align: left;
  border-bottom: 2px solid rgba(78,205,196,0.5);
  font-weight: bold;
  white-space: nowrap;
  background: rgba(0,0,0,0.95);
}

.data-table td {
  padding: 6px 4px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  white-space: nowrap;
}

.data-table tr:hover {
  background: rgba(255,255,255,0.05);
}

.data-table tr.current-row {
  background: rgba(0,255,100,0.3) !important;
  font-weight: bold;
}

.data-table tr.current-row td {
  border-top: 2px solid rgba(0,255,100,0.8);
  border-bottom: 2px solid rgba(0,255,100,0.8);
}

.header {
  text-align: center;
  margin-bottom: 25px;
  padding: 18px;
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
  backdrop-filter: blur(10px);
}

.header h1 {
  margin: 0;
  font-size: 2em;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.header p {
  margin: 8px 0 0 0;
  opacity: 0.8;
  font-size: 1em;
}

.control-panel {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 18px;
  margin-bottom: 18px;
  border: 1px solid rgba(255,255,255,0.1);
}

.control-group {
  margin-bottom: 20px;
}

.control-group h3 {
  margin: 0 0 12px 0;
  color: #4ecdc4;
  font-size: 1.1em;
  border-bottom: 2px solid rgba(78,205,196,0.3);
  padding-bottom: 6px;
  cursor: pointer;
  user-select: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
}

.control-group h3:hover {
  color: #5fddce;
  background: rgba(78,205,196,0.1);
  padding-left: 8px;
  border-radius: 8px;
}

.control-group h3::after {
  content: 'â–¼';
  font-size: 0.8em;
  transition: transform 0.3s ease;
}

.control-group h3.collapsed::after {
  transform: rotate(-90deg);
}

.control-group-content {
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.3s ease;
  max-height: 2000px;
  opacity: 1;
}

.control-group-content.collapsed {
  max-height: 0;
  opacity: 0;
}

.file-input {
  width: 100%;
  padding: 10px;
  border: 2px dashed rgba(255,255,255,0.3);
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.file-input:hover {
  border-color: #4ecdc4;
  background: rgba(78,205,196,0.1);
}

.sensor-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.sensor-checkbox {
  display: flex;
  align-items: center;
  padding: 6px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
  transition: all 0.3s ease;
  font-size: 13px;
}

.sensor-checkbox:hover {
  background: rgba(255,255,255,0.1);
}

.sensor-checkbox input {
  margin-right: 6px;
  transform: scale(1.1);
}

.angle-controls {
  margin-top: 15px;
}

.angle-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  margin-bottom: 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
}

.angle-item label {
  font-size: 12px;
  min-width: 80px;
}

.angle-item input[type="number"] {
  width: 70px;
  padding: 4px 8px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 4px;
  color: #fff;
  font-size: 13px;
  text-align: center;
}

.angle-item input[type="range"] {
  flex: 1;
  margin: 0 10px;
}

.interactive-graph {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 15px;
  border: 1px solid rgba(255,255,255,0.1);
  margin-bottom: 15px;
}

.graph-container {
  position: relative;
  width: 100%;
  height: 240px;
  background: rgba(0,0,0,0.3);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.2);
  margin: 12px 0;
  cursor: crosshair;
}

.graph-canvas {
  width: 100%;
  height: 100%;
  border-radius: 10px;
}

.graph-title {
  font-size: 1em;
  font-weight: bold;
  margin-bottom: 8px;
  color: #ff6b6b;
}

.graph-title.steering {
  color: #4ecdc4;
}

.graph-range-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-top: 8px;
  margin-bottom: 8px;
  padding: 10px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
}

.range-input-group {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
}

.range-input-group label {
  font-weight: bold;
  min-width: 40px;
}

.range-input-group input {
  width: 60px;
  padding: 4px 6px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 4px;
  color: #fff;
  font-size: 12px;
  text-align: center;
}

.graph-controls {
  display: flex;
  gap: 6px;
  margin-top: 8px;
  flex-wrap: wrap;
}

.btn {
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  border: none;
  padding: 5px 10px;
  border-radius: 12px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 11px;
}

.btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.btn:active {
  transform: translateY(0);
}

.btn.secondary {
  background: linear-gradient(45deg, #667eea, #764ba2);
}

.btn.danger {
  background: linear-gradient(45deg, #ff416c, #ff4b2b);
}

.canvas-wrapper {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: rgba(0,0,0,0.3);
  border-radius: 20px;
  padding: 20px;
  border: 2px solid rgba(255,255,255,0.1);
}

.canvas-container {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
}

#trackCanvas {
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 15px;
  background: #111;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  cursor: grab;
}

#trackCanvas.dragging {
  cursor: grabbing;
}

.time-control-panel {
  margin-top: 15px;
  padding: 12px 15px;
  background: rgba(255,255,255,0.05);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.1);
}

.time-control-panel h3 {
  display: none;
}

.time-slider-container {
  position: relative;
  padding: 8px 0;
  margin-bottom: 22px;
}

.time-slider {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: rgba(255,255,255,0.2);
  outline: none;
  -webkit-appearance: none;
  cursor: pointer;
}

.time-ticks {
  position: absolute;
  width: 100%;
  height: 18px;
  top: 18px;
  left: 0;
  display: flex;
  justify-content: space-between;
  pointer-events: none;
}

.time-tick {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.time-tick-line {
  width: 1px;
  height: 6px;
  background: rgba(78,205,196,0.5);
  margin-bottom: 2px;
}

.time-tick-label {
  font-size: 9px;
  color: rgba(255,255,255,0.6);
  white-space: nowrap;
}

.time-slider::-webkit-slider-thumb {
  appearance: none;
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  cursor: pointer;
  box-shadow: 0 0 10px rgba(78,205,196,0.8);
}

.time-slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  cursor: pointer;
  border: none;
  box-shadow: 0 0 10px rgba(78,205,196,0.8);
}

.time-info {
  display: none;
}

.time-display {
  text-align: center;
  margin-bottom: 8px;
  padding: 5px 10px;
  background: rgba(78,205,196,0.15);
  border-radius: 6px;
  font-size: 0.9em;
  font-weight: bold;
}

.playback-controls {
  display: flex;
  justify-content: center;
  gap: 6px;
  margin-top: 8px;
}

.play-btn {
  background: linear-gradient(45deg, #00d2ff, #3a47d5);
  border: none;
  padding: 6px 12px;
  border-radius: 15px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  font-size: 11px;
  transition: all 0.3s ease;
}

.play-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 5px 15px rgba(0,210,255,0.4);
}

.stats-panel {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 12px;
  margin-top: 15px;
  border: 1px solid rgba(255,255,255,0.1);
}

.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.stat-item {
  text-align: center;
  padding: 6px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
}

.stat-value {
  font-size: 1.2em;
  font-weight: bold;
  color: #4ecdc4;
}

.stat-label {
  font-size: 0.8em;
  opacity: 0.8;
  margin-top: 3px;
}

.map-quality-panel {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 12px;
  margin-top: 15px;
  border: 1px solid rgba(255,255,255,0.1);
}

.map-quality-panel h3, .interactive-graph h3, .stats-panel h3 {
  cursor: pointer;
  user-select: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
  padding: 6px;
  border-radius: 8px;
}

.map-quality-panel h3:hover, .interactive-graph h3:hover, .stats-panel h3:hover {
  background: rgba(78,205,196,0.1);
}

.map-quality-panel h3::after, .interactive-graph h3::after, .stats-panel h3::after {
  content: 'â–¼';
  font-size: 0.8em;
  transition: transform 0.3s ease;
}

.map-quality-panel h3.collapsed::after, .interactive-graph h3.collapsed::after, .stats-panel h3.collapsed::after {
  transform: rotate(-90deg);
}

.panel-content {
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.3s ease;
  max-height: 3000px;
  opacity: 1;
}

.panel-content.collapsed {
  max-height: 0;
  opacity: 0;
}

.quality-slider {
  width: 100%;
  margin: 8px 0;
}

.quality-label {
  display: flex;
  justify-content: space-between;
  font-size: 0.85em;
  opacity: 0.8;
}

.map-control-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-top: 12px;
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ */
@media (max-width: 1400px) {
  .container {
    flex-direction: column;
  }
  
  .sidebar {
    width: 100%;
    height: auto;
    max-height: 60vh;
  }
  
  .main-content {
    height: 40vh;
  }
}

/* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.control-panel, .interactive-graph, .stats-panel {
  animation: fadeIn 0.6s ease-out;
}

/* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º */
.sidebar::-webkit-scrollbar {
  width: 8px;
}

.sidebar::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.1);
  border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb {
  background: rgba(78,205,196,0.6);
  border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
  background: rgba(78,205,196,0.8);
}
</style>
</head>
<body>

<div class="container">
  <div class="sidebar">
    <div class="header">
      <h1>ğŸš— ãƒŸãƒ‹ã‚«ãƒ¼SLAM Pro</h1>
      <p>é«˜åº¦æ“ä½œç‰ˆ - Zoomãƒ»Rotationãƒ»Dragå¯¾å¿œ</p>
      <p style="font-size: 0.85em; opacity: 0.7; margin-top: 3px;">Simultaneous Localization And Mapping</p>
    </div>

    <div class="control-panel">
      <div class="control-group">
        <h3>ğŸ“ ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«</h3>
        <div class="control-group-content">
        <input type="file" id="csvFile" accept=".csv" class="file-input">
        </div>
      </div>

      <div class="control-group">
        <h3>ğŸ” æœ‰åŠ¹ã‚»ãƒ³ã‚µ</h3>
        <div class="control-group-content">
        <div class="sensor-controls">
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(255,50,150,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="RrLH" checked>
            <span style="color: #ff3296;">â—</span> RrLH
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(100,200,255,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="FrLH" checked>
            <span style="color: #64c8ff;">â—</span> FrLH
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(50,255,50,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="Fr" checked>
            <span style="color: #32ff32;">â—</span> Fr
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(255,200,50,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="FrRH" checked>
            <span style="color: #ffc832;">â—</span> FrRH
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(255,100,50,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="RrRH" checked>
            <span style="color: #ff6432;">â—</span> RrRH
          </label>
          </div>
        </div>
      </div>

      <div class="control-group">
        <h3>ğŸ“ ã‚»ãƒ³ã‚µãƒ¼å–ä»˜è§’åº¦ï¼ˆè»Šä¸¡å‰æ–¹ã‚’0åº¦ã€å³å›ã‚Šï¼‰</h3>
        <div class="control-group-content">
        <div class="angle-controls">
          <div class="angle-item">
            <label><span style="color: #32ff32;">â—</span> Fr (æ­£é¢)</label>
            <input type="range" min="0" max="360" value="0" oninput="updateSensorAngle('Fr', this.value)">
            <input type="number" id="angleFr" min="0" max="360" value="0" onchange="updateSensorAngle('Fr', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #ffc832;">â—</span> FrRH (å³å‰)</label>
            <input type="range" min="0" max="360" value="35" oninput="updateSensorAngle('FrRH', this.value)">
            <input type="number" id="angleFrRH" min="0" max="360" value="35" onchange="updateSensorAngle('FrRH', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #ff6432;">â—</span> RrRH (å³å¾Œ)</label>
            <input type="range" min="0" max="360" value="90" oninput="updateSensorAngle('RrRH', this.value)">
            <input type="number" id="angleRrRH" min="0" max="360" value="90" onchange="updateSensorAngle('RrRH', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #ff3296;">â—</span> RrLH (å·¦å¾Œ)</label>
            <input type="range" min="0" max="360" value="270" oninput="updateSensorAngle('RrLH', this.value)">
            <input type="number" id="angleRrLH" min="0" max="360" value="270" onchange="updateSensorAngle('RrLH', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #64c8ff;">â—</span> FrLH (å·¦å‰)</label>
            <input type="range" min="0" max="360" value="325" oninput="updateSensorAngle('FrLH', this.value)">
            <input type="number" id="angleFrLH" min="0" max="360" value="325" onchange="updateSensorAngle('FrLH', this.value)">Â°
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="interactive-graph">
      <h3>âš™ï¸ ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒãƒƒãƒ—èª¿æ•´</h3>
      
      <div>
        <div class="graph-title">ğŸš— è»Šé€Ÿãƒãƒƒãƒ—</div>
        <div class="graph-range-controls">
          <div class="range-input-group">
            <label>Xè»¸ Min:</label>
            <input type="number" id="speedXMin" value="0" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Xè»¸ Max:</label>
            <input type="number" id="speedXMax" value="100" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Min:</label>
            <input type="number" id="speedYMin" value="0" step="0.5" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Max:</label>
            <input type="number" id="speedYMax" value="5" step="0.5" onchange="updateGraphRange()">
          </div>
        </div>
        <div class="graph-container" id="speedGraphContainer">
          <canvas class="graph-canvas" id="speedGraph"></canvas>
        </div>
        <div class="graph-controls">
          <button class="btn" onclick="addSpeedPoint()">+</button>
          <button class="btn secondary" onclick="resetSpeedMap()">ğŸ”„</button>
        </div>
      </div>

      <div style="margin-top: 15px;">
        <div class="graph-title steering">ğŸ¯ æ“èˆµãƒãƒƒãƒ—</div>
        <div class="graph-range-controls">
          <div class="range-input-group">
            <label>Xè»¸ Min:</label>
            <input type="number" id="steeringXMin" value="-100" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Xè»¸ Max:</label>
            <input type="number" id="steeringXMax" value="100" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Min:</label>
            <input type="number" id="steeringYMin" value="-45" step="5" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Max:</label>
            <input type="number" id="steeringYMax" value="45" step="5" onchange="updateGraphRange()">
          </div>
        </div>
        <div class="graph-container" id="steeringGraphContainer">
          <canvas class="graph-canvas" id="steeringGraph"></canvas>
        </div>
        <div class="graph-controls">
          <button class="btn" onclick="addSteeringPoint()">+</button>
          <button class="btn secondary" onclick="resetSteeringMap()">ğŸ”„</button>
        </div>
      </div>

      <div style="margin-top: 12px; text-align: center;">
        <button class="btn" onclick="exportMaps()">ğŸ’¾ ä¿å­˜</button>
        <button class="btn" onclick="importMaps()">ğŸ“ èª­è¾¼</button>
      </div>
    </div>

    <div class="map-quality-panel">
      <h3>ğŸ¨ ãƒãƒƒãƒ—è¡¨ç¤ºè¨­å®š</h3>
      <div class="quality-label">
        <span>ã‚»ãƒ³ã‚µç‚¹å¯†åº¦</span>
        <span id="densityValue">10</span>
      </div>
      <input type="range" class="quality-slider" id="densitySlider" min="1" max="100" value="10" oninput="updateDensity(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>ã‚»ãƒ³ã‚µç‚¹ã‚µã‚¤ã‚º</span>
        <span id="sizeValue">4px</span>
      </div>
      <input type="range" class="quality-slider" id="sizeSlider" min="1" max="10" value="4" oninput="updatePointSize(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>ç·šã®å¤ªã•</span>
        <span id="lineWidthValue">1px</span>
      </div>
      <input type="range" class="quality-slider" id="lineWidthSlider" min="0.5" max="3" step="0.5" value="1" oninput="updateLineWidth(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>éå»ãƒ—ãƒ­ãƒƒãƒˆè¡¨ç¤ºæ•°</span>
        <span id="pastPlotsValue">5</span>
      </div>
      <input type="range" class="quality-slider" id="pastPlotsSlider" min="0" max="20" value="5" oninput="updatePastPlots(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>æœªæ¥ãƒ—ãƒ­ãƒƒãƒˆè¡¨ç¤ºæ•° (0=å…¨åŒºé–“)</span>
        <span id="futurePlotsValue">5</span>
      </div>
      <input type="range" class="quality-slider" id="futurePlotsSlider" min="0" max="20" value="5" oninput="updateFuturePlots(this.value)">
    </div>
    
    <div class="map-quality-panel">
      <h3>ğŸ—ºï¸ ãƒãƒƒãƒ—æ“ä½œè¨­å®š</h3>
      <div class="quality-label">
        <span>ã‚ºãƒ¼ãƒ </span>
        <span id="zoomValue">1.0x</span>
      </div>
      <input type="range" class="quality-slider" id="zoomSlider" min="0.5" max="5" step="0.1" value="1" oninput="updateZoom(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>å›è»¢è§’åº¦</span>
        <span id="rotationValue">0Â°</span>
      </div>
      <input type="range" class="quality-slider" id="rotationSlider" min="0" max="360" step="1" value="0" oninput="updateRotation(this.value)">
      
      <div class="map-control-buttons">
        <button class="btn secondary" onclick="resetView()">ğŸ”„ ãƒ“ãƒ¥ãƒ¼ãƒªã‚»ãƒƒãƒˆ</button>
        <button class="btn secondary" onclick="resetRotation()">ğŸ§­ æ–¹è§’ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
    </div>

    <div class="stats-panel">
      <h3>ğŸ“Š çµ±è¨ˆæƒ…å ±</h3>
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-value" id="totalPoints">0</div>
          <div class="stat-label">ç·ãƒ‡ãƒ¼ã‚¿æ•°</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="trackLength">0m</div>
          <div class="stat-label">è»Œè·¡é•·</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="maxSpeed">0m/s</div>
          <div class="stat-label">æœ€å¤§é€Ÿåº¦</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="avgSpeed">0m/s</div>
          <div class="stat-label">å¹³å‡é€Ÿåº¦</div>
        </div>
      </div>
    </div>
  </div>

  <div class="main-content">
    <div class="canvas-wrapper">
      <div class="canvas-container">
        <canvas id="trackCanvas" width="900" height="700"></canvas>
      </div>
      
      <div class="time-control-panel">
        <h3>â±ï¸ ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³åˆ¶å¾¡</h3>
        <div class="time-display" id="timeDisplay">æ™‚åˆ»: --:--:--.---</div>
        <div class="time-slider-container">
          <input type="range" class="time-slider" id="timeSlider" min="0" max="100" value="100">
          <div class="time-ticks" id="timeTicks"></div>
        </div>
        <div class="time-info">
          <span id="startTime">é–‹å§‹: --:--:--.---</span>
          <span id="endTime">çµ‚äº†: --:--:--.---</span>
        </div>
        <div class="playback-controls">
          <button class="play-btn" id="playBtn" onclick="togglePlayback()">â–¶ å†ç”Ÿ</button>
          <button class="play-btn" onclick="resetPlayback()">â® æœ€åˆã‹ã‚‰</button>
          <button class="play-btn" onclick="jumpToEnd()">â­ æœ€å¾Œã¸</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
  <div class="table-sidebar" id="tableSidebar">
    <button class="table-toggle-btn" id="tableToggleBtn" onclick="toggleTableSidebar()">â—€</button>
    <div class="table-resize-handle" id="tableResizeHandle"></div>
    <div class="table-header">
      <h3>ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«</h3>
    </div>
    <div class="table-container" id="tableContainer">
      <table class="data-table" id="dataTable">
        <thead>
          <tr id="tableHeaderRow"></tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let csvData = [];
let headers = [];
let positions = [];
let currentTimeIndex = 0;
let isPlaying = false;
let playbackInterval = null;

// è»Šä¸¡ã¨ã‚³ãƒ¼ã‚¹ã®ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆmmå˜ä½ï¼‰
const VEHICLE_LENGTH = 250;  // mm
const VEHICLE_WIDTH = 150;   // mm
const COURSE_WIDTH = 1000;   // mm

// è¡¨ç¤ºè¨­å®š
let sensorDensity = 10;
let sensorPointSize = 4;
let sensorLineWidth = 1;
let pastPlotsCount = 5;
let futurePlotsCount = 5;  // æ–°è¦ï¼šæœªæ¥ãƒ—ãƒ­ãƒƒãƒˆè¡¨ç¤ºæ•°
let vehicleSizeMultiplier = 1.8;  // è»Šä¸¡ã‚µã‚¤ã‚ºå€ç‡ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§1.8å€ï¼‰

// ãƒãƒƒãƒ—æ“ä½œè¨­å®š
let mapZoom = 1.0;
let mapOffsetX = 0;
let mapOffsetY = 0;
let mapRotation = 0;  // ãƒ©ã‚¸ã‚¢ãƒ³
let isDraggingMap = false;
let dragStartX = 0;
let dragStartY = 0;
let isDraggingVehicle = false;
let isDraggingCompass = false;
let compassX = 0;
let compassY = 0;

// ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼è¨­å®š
let isTableOpen = true;
let isResizingTable = false;
let tableStartX = 0;
let tableStartWidth = 0;

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’ä¿å­˜
let canvasScaleInfo = {
  minX: 0,
  minY: 0,
  scale: 1,
  margin: 80,
  centerX: 0,
  centerY: 0
};

// ã‚»ãƒ³ã‚µãƒ¼å–ä»˜è§’åº¦ï¼ˆåº¦ï¼‰- è»Šä¸¡å‰æ–¹ã‚’0åº¦ã¨ã—ã¦å³å›ã‚Š
let sensorAngles = {
  'Fr': 0,
  'FrRH': 35,
  'RrRH': 90,
  'RrLH': 270,
  'FrLH': 325
};

// ã‚°ãƒ©ãƒ•ç¯„å›²è¨­å®š
let graphRanges = {
  speed: { xMin: 0, xMax: 100, yMin: 0, yMax: 5 },
  steering: { xMin: -100, xMax: 100, yMin: -45, yMax: 45 }
};

let speedMap = [
  {key: 0, value: 0}, {key: 10, value: 0.2}, {key: 20, value: 0.4},
  {key: 30, value: 1}, {key: 40, value: 1.5}, {key: 50, value: 2},
  {key: 60, value: 2.5}, {key: 70, value: 3}, {key: 80, value: 3.5},
  {key: 90, value: 4}, {key: 100, value: 5}
];
let steeringMap = [
  {key: -100, value: -45}, {key: -50, value: -22.5},
  {key: 0, value: 0}, {key: 50, value: 22.5}, {key: 100, value: 45}
];

// ã‚»ãƒ³ã‚µãƒ¼ã”ã¨ã®è‰²å®šç¾©
const sensorColors = {
  'RrLH': {r: 255, g: 50, b: 150},   // ãƒ”ãƒ³ã‚¯
  'FrLH': {r: 100, g: 200, b: 255},  // æ°´è‰²
  'Fr': {r: 50, g: 255, b: 50},      // ç·‘
  'FrRH': {r: 255, g: 200, b: 50},   // é»„è‰²
  'RrRH': {r: 255, g: 100, b: 50}    // ã‚ªãƒ¬ãƒ³ã‚¸
};

// ã‚°ãƒ©ãƒ•é–¢é€£å¤‰æ•°
let speedGraph, steeringGraph;
let speedCtx, steeringCtx;
let isDragging = false;
let dragPoint = null;
let dragGraph = null;

// åˆæœŸåŒ–
document.addEventListener('DOMContentLoaded', function() {
  initializeGraphs();
  setupEventListeners();
  setupAccordion();
  setupTableSidebar();
  drawAllGraphs();
});

// ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
function setupTableSidebar() {
  const resizeHandle = document.getElementById('tableResizeHandle');
  const tableSidebar = document.getElementById('tableSidebar');
  
  // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã®ã‚¤ãƒ™ãƒ³ãƒˆ
  resizeHandle.addEventListener('mousedown', (e) => {
    isResizingTable = true;
    tableStartX = e.clientX;
    tableStartWidth = tableSidebar.offsetWidth;
    e.preventDefault();
  });
  
  document.addEventListener('mousemove', (e) => {
    if (isResizingTable) {
      const deltaX = tableStartX - e.clientX;
      const newWidth = Math.max(200, Math.min(800, tableStartWidth + deltaX));
      tableSidebar.style.width = newWidth + 'px';
    }
  });
  
  document.addEventListener('mouseup', () => {
    isResizingTable = false;
  });
}

// ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ãƒˆã‚°ãƒ«
function toggleTableSidebar() {
  const tableSidebar = document.getElementById('tableSidebar');
  const toggleBtn = document.getElementById('tableToggleBtn');
  isTableOpen = !isTableOpen;
  
  if (isTableOpen) {
    tableSidebar.classList.remove('closed');
    toggleBtn.textContent = 'â—€';
  } else {
    tableSidebar.classList.add('closed');
    toggleBtn.textContent = 'â–¶';
  }
}

// ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤ºã‚’æ›´æ–°
function updateTableDisplay() {
  if (!csvData.length) return;
  
  const headerRow = document.getElementById('tableHeaderRow');
  const tableBody = document.getElementById('tableBody');
  
  // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ä½œæˆ
  headerRow.innerHTML = '';
  headers.forEach(header => {
    const th = document.createElement('th');
    th.textContent = header;
    headerRow.appendChild(th);
  });
  
  // ãƒ‡ãƒ¼ã‚¿è¡Œã‚’ä½œæˆ
  tableBody.innerHTML = '';
  csvData.forEach((row, index) => {
    const tr = document.createElement('tr');
    tr.id = 'tableRow' + index;
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tableBody.appendChild(tr);
  });
  
  // ç¾åœ¨ã®è¡Œã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
  scrollToCurrentRow();
}

// ç¾åœ¨ã®è¡Œã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
function scrollToCurrentRow() {
  if (!csvData.length) return;
  
  const tableContainer = document.getElementById('tableContainer');
  const currentRow = document.getElementById('tableRow' + currentTimeIndex);
  
  // ã™ã¹ã¦ã®è¡Œã‹ã‚‰ current-row ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
  document.querySelectorAll('.data-table tr.current-row').forEach(row => {
    row.classList.remove('current-row');
  });
  
  if (currentRow) {
    currentRow.classList.add('current-row');
    
    // ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä¸­å¤®ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
    const containerHeight = tableContainer.clientHeight;
    const rowTop = currentRow.offsetTop;
    const rowHeight = currentRow.offsetHeight;
    const scrollTop = rowTop - (containerHeight / 2) + (rowHeight / 2);
    
    tableContainer.scrollTop = scrollTop;
  }
}

// ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³æ©Ÿèƒ½ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
function setupAccordion() {
  // control-groupã®ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³
  const controlHeaders = document.querySelectorAll('.control-group h3');
  controlHeaders.forEach(header => {
    header.addEventListener('click', function() {
      this.classList.toggle('collapsed');
      const content = this.nextElementSibling;
      content.classList.toggle('collapsed');
    });
  });
  
  // ãã®ä»–ã®ãƒ‘ãƒãƒ«ã®ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³
  const panelHeaders = document.querySelectorAll('.interactive-graph > h3, .map-quality-panel > h3, .stats-panel > h3');
  panelHeaders.forEach(header => {
    // h3ã®æ¬¡ã®è¦ç´ ä»¥é™ã‚’ã™ã¹ã¦panel-contentã§å›²ã‚€
    const panel = header.parentElement;
    const wrapper = document.createElement('div');
    wrapper.className = 'panel-content';
    
    // h3ã®æ¬¡ã®è¦ç´ ã‹ã‚‰å…¨ã¦ç§»å‹•
    let next = header.nextElementSibling;
    while (next) {
      const current = next;
      next = next.nextElementSibling;
      wrapper.appendChild(current);
    }
    
    panel.appendChild(wrapper);
    
    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
    header.addEventListener('click', function() {
      this.classList.toggle('collapsed');
      wrapper.classList.toggle('collapsed');
    });
  });
}

// ã‚°ãƒ©ãƒ•ç¯„å›²æ›´æ–°
function updateGraphRange() {
  graphRanges.speed.xMin = parseFloat(document.getElementById('speedXMin').value);
  graphRanges.speed.xMax = parseFloat(document.getElementById('speedXMax').value);
  graphRanges.speed.yMin = parseFloat(document.getElementById('speedYMin').value);
  graphRanges.speed.yMax = parseFloat(document.getElementById('speedYMax').value);
  
  graphRanges.steering.xMin = parseFloat(document.getElementById('steeringXMin').value);
  graphRanges.steering.xMax = parseFloat(document.getElementById('steeringXMax').value);
  graphRanges.steering.yMin = parseFloat(document.getElementById('steeringYMin').value);
  graphRanges.steering.yMax = parseFloat(document.getElementById('steeringYMax').value);
  
  drawAllGraphs();
}

// ã‚»ãƒ³ã‚µãƒ¼è§’åº¦æ›´æ–°
function updateSensorAngle(sensor, value) {
  sensorAngles[sensor] = parseFloat(value);
  document.getElementById(`angle${sensor}`).value = value;
  document.querySelector(`#angle${sensor}`).previousElementSibling.value = value;
  
  if (positions.length > 0) {
    drawTrack();
  }
}

// å¯†åº¦ã¨ã‚µã‚¤ã‚ºèª¿æ•´
function updateDensity(value) {
  sensorDensity = parseInt(value);
  document.getElementById('densityValue').textContent = value;
  drawTrack();
}

function updatePointSize(value) {
  sensorPointSize = parseInt(value);
  document.getElementById('sizeValue').textContent = value + 'px';
  drawTrack();
}

function updateLineWidth(value) {
  sensorLineWidth = parseFloat(value);
  document.getElementById('lineWidthValue').textContent = value + 'px';
  drawTrack();
}

function updatePastPlots(value) {
  pastPlotsCount = parseInt(value);
  document.getElementById('pastPlotsValue').textContent = value;
  drawTrack();
}

function updateFuturePlots(value) {
  futurePlotsCount = parseInt(value);
  document.getElementById('futurePlotsValue').textContent = value + (value === 0 ? ' (å…¨åŒºé–“)' : '');
  drawTrack();
}

// ãƒãƒƒãƒ—æ“ä½œé–¢æ•°
function updateZoom(value) {
  mapZoom = parseFloat(value);
  document.getElementById('zoomValue').textContent = value + 'x';
  drawTrack();
}

function updateRotation(value) {
  mapRotation = parseFloat(value) * Math.PI / 180;
  document.getElementById('rotationValue').textContent = value + 'Â°';
  drawTrack();
}

function resetView() {
  mapZoom = 1.0;
  mapOffsetX = 0;
  mapOffsetY = 0;
  mapRotation = 0;
  document.getElementById('zoomSlider').value = 1.0;
  document.getElementById('zoomValue').textContent = '1.0x';
  document.getElementById('rotationSlider').value = 0;
  document.getElementById('rotationValue').textContent = '0Â°';
  drawTrack();
}

function resetRotation() {
  mapRotation = 0;
  document.getElementById('rotationSlider').value = 0;
  document.getElementById('rotationValue').textContent = '0Â°';
  drawTrack();
}

// ã‚°ãƒ©ãƒ•åˆæœŸåŒ–
function initializeGraphs() {
  speedGraph = document.getElementById('speedGraph');
  steeringGraph = document.getElementById('steeringGraph');
  speedCtx = speedGraph.getContext('2d');
  steeringCtx = steeringGraph.getContext('2d');
  
  const container = document.getElementById('speedGraphContainer');
  const rect = container.getBoundingClientRect();
  speedGraph.width = rect.width;
  speedGraph.height = 240;
  steeringGraph.width = rect.width;
  steeringGraph.height = 240;
  
  setupGraphEvents();
}

// ã‚°ãƒ©ãƒ•ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
function setupGraphEvents() {
  speedGraph.addEventListener('mousedown', (e) => handleGraphMouseDown(e, 'speed'));
  speedGraph.addEventListener('mousemove', (e) => handleGraphMouseMove(e, 'speed'));
  speedGraph.addEventListener('mouseup', (e) => handleGraphMouseUp(e, 'speed'));
  speedGraph.addEventListener('dblclick', (e) => handleGraphDoubleClick(e, 'speed'));
  
  steeringGraph.addEventListener('mousedown', (e) => handleGraphMouseDown(e, 'steering'));
  steeringGraph.addEventListener('mousemove', (e) => handleGraphMouseMove(e, 'steering'));
  steeringGraph.addEventListener('mouseup', (e) => handleGraphMouseUp(e, 'steering'));
  steeringGraph.addEventListener('dblclick', (e) => handleGraphDoubleClick(e, 'steering'));
}

// ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
function setupEventListeners() {
  document.getElementById('csvFile').addEventListener('change', handleCSVUpload);
  document.querySelectorAll('.sensorCheckbox').forEach(cb => {
    cb.addEventListener('change', drawTrack);
  });
  
  const timeSlider = document.getElementById('timeSlider');
  timeSlider.addEventListener('input', function() {
    currentTimeIndex = parseInt(this.value);
    updateTimeDisplay();
    drawTrack();
  });
  
  // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
  const trackCanvas = document.getElementById('trackCanvas');
  trackCanvas.addEventListener('mousedown', handleCanvasMouseDown);
  trackCanvas.addEventListener('mousemove', handleCanvasMouseMove);
  trackCanvas.addEventListener('mouseup', handleCanvasMouseUp);
  trackCanvas.addEventListener('wheel', handleCanvasWheel);
  trackCanvas.addEventListener('mouseleave', handleCanvasMouseUp);
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³å‡¦ç†
function handleCanvasMouseDown(e) {
  if (!positions.length) return;
  
  const canvas = e.target;
  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;
  
  // ã‚³ãƒ³ãƒ‘ã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ç¢ºèª
  const compassRadius = 40;
  const compassCenterX = canvas.width - 80;
  const compassCenterY = 80;
  const distToCompass = Math.sqrt((clickX - compassCenterX) ** 2 + (clickY - compassCenterY) ** 2);
  
  if (distToCompass <= compassRadius) {
    isDraggingCompass = true;
    compassX = compassCenterX;
    compassY = compassCenterY;
    canvas.classList.add('dragging');
    return;
  }
  
  // å†ç”Ÿä¸­ã¯ä½•ã‚‚ã—ãªã„
  if (isPlaying) return;
  
  // è‡ªè»Šãƒ—ãƒ­ãƒƒãƒˆã¾ãŸã¯è»Œè·¡ãƒ©ã‚¤ãƒ³è¿‘ãã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ç¢ºèª
  const clickThreshold = 20; // ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã®é–¾å€¤ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
  let nearVehicleOrTrack = false;
  
  // ç¾åœ¨ã®è»Šä¸¡ä½ç½®ã¨ã®è·é›¢ã‚’ãƒã‚§ãƒƒã‚¯
  if (currentTimeIndex < positions.length) {
    const currentPos = positions[currentTimeIndex];
    const transformedPos = applyTransform(currentPos.x, currentPos.y);
    const distToVehicle = Math.sqrt((clickX - transformedPos.x) ** 2 + (clickY - transformedPos.y) ** 2);
    
    if (distToVehicle <= clickThreshold * 2) {
      nearVehicleOrTrack = true;
    }
  }
  
  // è»Œè·¡ãƒ©ã‚¤ãƒ³ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
  if (!nearVehicleOrTrack) {
    for (let i = 0; i < Math.min(currentTimeIndex, positions.length - 1); i++) {
      const p1 = positions[i];
      const p2 = positions[i + 1];
      const tp1 = applyTransform(p1.x, p1.y);
      const tp2 = applyTransform(p2.x, p2.y);
      
      const distToLine = pointToLineDistance(clickX, clickY, tp1.x, tp1.y, tp2.x, tp2.y);
      
      if (distToLine <= clickThreshold) {
        nearVehicleOrTrack = true;
        break;
      }
    }
  }
  
  if (nearVehicleOrTrack) {
    // è‡ªè»Šãƒ—ãƒ­ãƒƒãƒˆã¾ãŸã¯ãƒ©ã‚¤ãƒ³ä¸Šï¼šè»Šä¸¡ãƒ‰ãƒ©ãƒƒã‚°
    isDraggingVehicle = true;
    updateVehiclePositionFromMouse(clickX, clickY);
  } else {
    // ãã‚Œä»¥å¤–ï¼šãƒãƒƒãƒ—ãƒ‰ãƒ©ãƒƒã‚°
    isDraggingMap = true;
    dragStartX = clickX;
    dragStartY = clickY;
    canvas.classList.add('dragging');
  }
}

// ç‚¹ã‹ã‚‰ç·šåˆ†ã¸ã®æœ€çŸ­è·é›¢ã‚’è¨ˆç®—
function pointToLineDistance(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  
  let xx, yy;
  
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }
  
  const dx = px - xx;
  const dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒã‚¦ã‚¹ç§»å‹•å‡¦ç†
function handleCanvasMouseMove(e) {
  if (!positions.length && !isDraggingCompass) return;
  
  const canvas = e.target;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  if (isDraggingCompass) {
    // ã‚³ãƒ³ãƒ‘ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ï¼šãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰ã®è§’åº¦ã‚’è¨ˆç®—
    const dx = mouseX - compassX;
    const dy = mouseY - compassY;
    const angle = Math.atan2(dy, dx);
    // atan2ã¯-Ï€ã‹ã‚‰Ï€ãªã®ã§ã€0ã‹ã‚‰2Ï€ã«å¤‰æ›ã—ã¦ã‹ã‚‰åº¦ã«å¤‰æ›
    let degrees = ((angle * 180 / Math.PI) + 90 + 360) % 360;
    mapRotation = degrees * Math.PI / 180;
    document.getElementById('rotationSlider').value = degrees;
    document.getElementById('rotationValue').textContent = degrees.toFixed(0) + 'Â°';
    drawTrack();
  } else if (isDraggingMap) {
    const deltaX = mouseX - dragStartX;
    const deltaY = mouseY - dragStartY;
    mapOffsetX += deltaX;
    mapOffsetY += deltaY;
    dragStartX = mouseX;
    dragStartY = mouseY;
    drawTrack();
  } else if (isDraggingVehicle && !isPlaying) {
    updateVehiclePositionFromMouse(mouseX, mouseY);
  }
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—å‡¦ç†
function handleCanvasMouseUp(e) {
  const canvas = document.getElementById('trackCanvas');
  isDraggingMap = false;
  isDraggingVehicle = false;
  isDraggingCompass = false;
  canvas.classList.remove('dragging');
}

// ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ 
function handleCanvasWheel(e) {
  e.preventDefault();
  const delta = -Math.sign(e.deltaY) * 0.1;
  mapZoom = Math.max(0.5, Math.min(5, mapZoom + delta));
  document.getElementById('zoomSlider').value = mapZoom;
  document.getElementById('zoomValue').textContent = mapZoom.toFixed(1) + 'x';
  drawTrack();
}

// ãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰æœ€ã‚‚è¿‘ã„è»Šä¸¡ä½ç½®ã‚’æ›´æ–°ï¼ˆã‚ºãƒ¼ãƒ å¯¾å¿œç‰ˆï¼‰
function updateVehiclePositionFromMouse(mouseX, mouseY) {
  if (!positions.length) return;
  
  let minDistance = Infinity;
  let nearestIndex = 0;
  
  // ã™ã¹ã¦ã®ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã¯é‡ã„ã®ã§ã€ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¦é«˜é€ŸåŒ–
  const step = Math.max(1, Math.floor(positions.length / 500));
    
  for (let i = 0; i < positions.length; i += step) {
    const transformedPos = applyTransform(positions[i].x, positions[i].y);
    const distance = Math.sqrt((mouseX - transformedPos.x) ** 2 + (mouseY - transformedPos.y) ** 2);
    
    if (distance < minDistance) {
      minDistance = distance;
      nearestIndex = i;
    }
  }
  
  // å‘¨è¾ºã‚’ç´°ã‹ããƒã‚§ãƒƒã‚¯
  const searchRange = Math.min(50, positions.length);
  const startIdx = Math.max(0, nearestIndex - searchRange);
  const endIdx = Math.min(positions.length - 1, nearestIndex + searchRange);
  
  for (let i = startIdx; i <= endIdx; i++) {
    const transformedPos = applyTransform(positions[i].x, positions[i].y);
    const distance = Math.sqrt((mouseX - transformedPos.x) ** 2 + (mouseY - transformedPos.y) ** 2);
    
    if (distance < minDistance) {
      minDistance = distance;
      nearestIndex = i;
    }
  }
  
  currentTimeIndex = nearestIndex;
  document.getElementById('timeSlider').value = currentTimeIndex;
  updateTimeDisplay();
  drawTrack();
}

// åº§æ¨™å¤‰æ›ï¼ˆã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³ãƒ»å›è»¢ã‚’é©ç”¨ï¼‰
function applyTransform(x, y) {
  const { minX, minY, scale, margin, centerX, centerY } = canvasScaleInfo;
  
  // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‹ã‚‰ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã¸ã®åŸºæœ¬å¤‰æ›
  let cx = margin + (x - minX) * scale;
  let cy = margin + (y - minY) * scale;
  
  // ä¸­å¿ƒã‚’åŸç‚¹ã¨ã™ã‚‹åº§æ¨™ç³»ã«å¤‰æ›
  cx -= centerX;
  cy -= centerY;
  
  // å›è»¢ã‚’é©ç”¨
  const rotatedX = cx * Math.cos(mapRotation) - cy * Math.sin(mapRotation);
  const rotatedY = cx * Math.sin(mapRotation) + cy * Math.cos(mapRotation);
  
  // ã‚ºãƒ¼ãƒ ã‚’é©ç”¨
  const zoomedX = rotatedX * mapZoom;
  const zoomedY = rotatedY * mapZoom;
  
  // ãƒ‘ãƒ³ã¨ã‚»ãƒ³ã‚¿ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨
  const finalX = zoomedX + centerX + mapOffsetX;
  const finalY = zoomedY + centerY + mapOffsetY;
  
  return { x: finalX, y: finalY };
}

// CSVã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†
function handleCSVUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(event) {
    const text = event.target.result;
    const lines = text.trim().split(/\r?\n/);
    headers = lines[0].split(',');
    csvData = lines.slice(1).map(line => line.split(','));
    
    calculatePositions();
    setupTimeSlider();
    updateStats();
    updateTableDisplay();
    drawTrack();
  };
  reader.readAsText(file);
}

// ä½ç½®è¨ˆç®—
function calculatePositions() {
  positions = [];
  let x = 0, y = 0, theta = 0;
  const scale = 1;
  
  csvData.forEach((row, i) => {
    const thr = parseFloat(row[headers.indexOf('Thr')]);
    const str = parseFloat(row[headers.indexOf('Str')]);
    const dt = i > 0 ? (parseFloat(row[0]) - parseFloat(csvData[i-1][0])) : 0.04;
    const speed = interpolateMap(speedMap, thr) * 1000;
    const angle = interpolateMap(steeringMap, str) * Math.PI/180;

    theta += angle * dt;
    x += speed * dt * scale * Math.cos(theta);
    y += speed * dt * scale * Math.sin(theta);

    positions.push({x, y, theta, row});
  });
}

// UNIXæ™‚åˆ»ã‚’æ™‚:åˆ†:ç§’.ãƒŸãƒªç§’å½¢å¼ã«å¤‰æ›
function formatUnixTime(unixTime) {
  const date = new Date(unixTime * 1000);
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  const milliseconds = String(date.getMilliseconds()).padStart(3, '0');
  return `${hours}:${minutes}:${seconds}.${milliseconds}`;
}

// ã‚¿ã‚¤ãƒ ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼è¨­å®š
function setupTimeSlider() {
  const timeSlider = document.getElementById('timeSlider');
  timeSlider.max = csvData.length - 1;
  timeSlider.value = csvData.length - 1;
  currentTimeIndex = csvData.length - 1;
  
  if (csvData.length > 0) {
    const startUnixTime = parseFloat(csvData[0][0]);
    const endUnixTime = parseFloat(csvData[csvData.length - 1][0]);
    
    const startTime = formatUnixTime(startUnixTime);
    const endTime = formatUnixTime(endUnixTime);
    
    document.getElementById('startTime').textContent = `é–‹å§‹: ${startTime}`;
    document.getElementById('endTime').textContent = `çµ‚äº†: ${endTime}`;
    
    generateTimeTicks();
  }
  
  updateTimeDisplay();
}

// æ™‚åˆ»ãƒ†ã‚£ãƒƒã‚¯ã‚’ç”Ÿæˆ
function generateTimeTicks() {
  const ticksContainer = document.getElementById('timeTicks');
  ticksContainer.innerHTML = '';
  
  const numTicks = 11;
  
  for (let i = 0; i < numTicks; i++) {
    const percentage = i / (numTicks - 1);
    const dataIndex = Math.floor(percentage * (csvData.length - 1));
    const unixTime = parseFloat(csvData[dataIndex][0]);
    const formattedTime = formatUnixTime(unixTime);
    
    const tickDiv = document.createElement('div');
    tickDiv.className = 'time-tick';
    
    const tickLine = document.createElement('div');
    tickLine.className = 'time-tick-line';
    
    const tickLabel = document.createElement('div');
    tickLabel.className = 'time-tick-label';
    tickLabel.textContent = formattedTime;
    
    tickDiv.appendChild(tickLine);
    tickDiv.appendChild(tickLabel);
    ticksContainer.appendChild(tickDiv);
  }
}

// æ™‚åˆ»è¡¨ç¤ºæ›´æ–°
function updateTimeDisplay() {
  if (csvData.length > 0 && currentTimeIndex < csvData.length) {
    const unixTime = parseFloat(csvData[currentTimeIndex][0]);
    const formattedTime = formatUnixTime(unixTime);
    document.getElementById('timeDisplay').textContent = `æ™‚åˆ»: ${formattedTime}`;
    scrollToCurrentRow();
  }
}

// å†ç”Ÿåˆ¶å¾¡
function togglePlayback() {
  isPlaying = !isPlaying;
  const playBtn = document.getElementById('playBtn');
  
  if (isPlaying) {
    playBtn.textContent = 'â¸ ä¸€æ™‚åœæ­¢';
    playbackInterval = setInterval(() => {
      currentTimeIndex++;
      if (currentTimeIndex >= csvData.length - 1) {
        currentTimeIndex = csvData.length - 1;
        togglePlayback();
        return;
      }
      document.getElementById('timeSlider').value = currentTimeIndex;
      updateTimeDisplay();
      drawTrack();
    }, 50);
  } else {
    playBtn.textContent = 'â–¶ å†ç”Ÿ';
    if (playbackInterval) {
      clearInterval(playbackInterval);
      playbackInterval = null;
    }
  }
}

function resetPlayback() {
  currentTimeIndex = 0;
  document.getElementById('timeSlider').value = 0;
  updateTimeDisplay();
  drawTrack();
}

function jumpToEnd() {
  currentTimeIndex = csvData.length - 1;
  document.getElementById('timeSlider').value = currentTimeIndex;
  updateTimeDisplay();
  drawTrack();
}

// ãƒã‚¦ã‚¹å‡¦ç†
function handleGraphMouseDown(e, graphType) {
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const point = findNearestPoint(x, y, graphType);
  if (point && getDistance(x, y, point.canvasX, point.canvasY) < 15) {
    isDragging = true;
    dragPoint = point;
    dragGraph = graphType;
    e.target.style.cursor = 'grabbing';
  }
}

function handleGraphMouseMove(e, graphType) {
  if (!isDragging || dragGraph !== graphType) return;
  
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const dataValue = canvasToData(x, y, graphType);
  if (dataValue) {
    dragPoint.key = dataValue.x;
    dragPoint.value = dataValue.y;
    
    if (graphType === 'speed') {
      speedMap.sort((a, b) => a.key - b.key);
    } else {
      steeringMap.sort((a, b) => a.key - b.key);
    }
    
    drawAllGraphs();
    calculatePositions();
    drawTrack();
  }
}

function handleGraphMouseUp(e, graphType) {
  if (isDragging && dragGraph === graphType) {
    isDragging = false;
    dragPoint = null;
    dragGraph = null;
    e.target.style.cursor = 'crosshair';
  }
}

function handleGraphDoubleClick(e, graphType) {
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const dataValue = canvasToData(x, y, graphType);
  if (dataValue) {
    if (graphType === 'speed') {
      speedMap.push({key: dataValue.x, value: dataValue.y});
      speedMap.sort((a, b) => a.key - b.key);
    } else {
      steeringMap.push({key: dataValue.x, value: dataValue.y});
      steeringMap.sort((a, b) => a.key - b.key);
    }
    drawAllGraphs();
    calculatePositions();
    drawTrack();
  }
}

// åº§æ¨™å¤‰æ›ï¼ˆæ”¹å–„ç‰ˆ - ç¯„å›²è¨­å®šã‚’ä½¿ç”¨ï¼‰
function canvasToData(x, y, graphType) {
  const canvas = graphType === 'speed' ? speedGraph : steeringGraph;
  const margin = 50;
  const width = canvas.width - 2 * margin;
  const height = canvas.height - 2 * margin;
  
  const range = graphType === 'speed' ? graphRanges.speed : graphRanges.steering;
  
  const dataX = range.xMin + ((x - margin) / width) * (range.xMax - range.xMin);
  const dataY = range.yMax - ((y - margin) / height) * (range.yMax - range.yMin);
  
  return {
    x: Math.max(range.xMin, Math.min(range.xMax, dataX)),
    y: Math.max(range.yMin, Math.min(range.yMax, dataY))
  };
}

function dataToCanvas(x, y, graphType) {
  const canvas = graphType === 'speed' ? speedGraph : steeringGraph;
  const margin = 50;
  const width = canvas.width - 2 * margin;
  const height = canvas.height - 2 * margin;
  
  const range = graphType === 'speed' ? graphRanges.speed : graphRanges.steering;
  
  const canvasX = margin + ((x - range.xMin) / (range.xMax - range.xMin)) * width;
  const canvasY = margin + ((range.yMax - y) / (range.yMax - range.yMin)) * height;
  
  return {x: canvasX, y: canvasY};
}

function findNearestPoint(x, y, graphType) {
  const map = graphType === 'speed' ? speedMap : steeringMap;
  let nearest = null;
  let minDistance = Infinity;
  
  map.forEach(point => {
    const canvasPos = dataToCanvas(point.key, point.value, graphType);
    const distance = getDistance(x, y, canvasPos.x, canvasPos.y);
    if (distance < minDistance) {
      minDistance = distance;
      nearest = point;
    }
  });
  
  if (nearest) {
    const canvasPos = dataToCanvas(nearest.key, nearest.value, graphType);
    nearest.canvasX = canvasPos.x;
    nearest.canvasY = canvasPos.y;
  }
  
  return nearest;
}

function getDistance(x1, y1, x2, y2) {
  return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
}

// ã‚°ãƒ©ãƒ•æç”»
function drawAllGraphs() {
  drawGraph('speed');
  drawGraph('steering');
}

function drawGraph(graphType) {
  const canvas = graphType === 'speed' ? speedGraph : steeringGraph;
  const ctx = graphType === 'speed' ? speedCtx : steeringCtx;
  const map = graphType === 'speed' ? speedMap : steeringMap;
  const range = graphType === 'speed' ? graphRanges.speed : graphRanges.steering;
  
  const margin = 50;
  const width = canvas.width - 2 * margin;
  const height = canvas.height - 2 * margin;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // ã‚°ãƒªãƒƒãƒ‰æç”»
  drawGrid(ctx, canvas, graphType, margin, width, height, range);
  
  // è»¸ãƒ©ãƒ™ãƒ«æç”»
  drawAxisLabels(ctx, canvas, graphType, margin, width, height, range);
  
  // ãƒ‡ãƒ¼ã‚¿ç·šæç”»
  ctx.strokeStyle = graphType === 'speed' ? '#ff6b6b' : '#4ecdc4';
  ctx.lineWidth = 3;
  ctx.beginPath();
  
  map.forEach((point, index) => {
    const pos = dataToCanvas(point.key, point.value, graphType);
    if (index === 0) {
      ctx.moveTo(pos.x, pos.y);
    } else {
      ctx.lineTo(pos.x, pos.y);
    }
  });
  ctx.stroke();
  
  // ãƒ‡ãƒ¼ã‚¿ç‚¹æç”»
  map.forEach(point => {
    const pos = dataToCanvas(point.key, point.value, graphType);
    ctx.fillStyle = graphType === 'speed' ? '#ff6b6b' : '#4ecdc4';
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  });
}

function drawGrid(ctx, canvas, graphType, margin, width, height, range) {
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  
  // ç¸¦ç·š
  for (let i = 0; i <= 10; i++) {
    const x = margin + (i / 10) * width;
    ctx.beginPath();
    ctx.moveTo(x, margin);
    ctx.lineTo(x, margin + height);
    ctx.stroke();
  }
  
  // æ¨ªç·š
  for (let i = 0; i <= 10; i++) {
    const y = margin + (i / 10) * height;
    ctx.beginPath();
    ctx.moveTo(margin, y);
    ctx.lineTo(margin + width, y);
    ctx.stroke();
  }
  
  // æ ç·š
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 2;
  ctx.strokeRect(margin, margin, width, height);
}

function drawAxisLabels(ctx, canvas, graphType, margin, width, height, range) {
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = 'bold 13px Arial';
  
  // Xè»¸ãƒ©ãƒ™ãƒ«
  for (let i = 0; i <= 10; i += 2) {
    const x = margin + (i / 10) * width;
    const value = range.xMin + (i / 10) * (range.xMax - range.xMin);
    ctx.textAlign = 'center';
    ctx.fillText(value.toFixed(0), x, margin + height + 20);
  }
  
  // Yè»¸ãƒ©ãƒ™ãƒ«
  for (let i = 0; i <= 10; i += 2) {
    const y = margin + ((10 - i) / 10) * height;
    const value = range.yMin + (i / 10) * (range.yMax - range.yMin);
    ctx.textAlign = 'right';
    ctx.fillText(value.toFixed(1), margin - 10, y + 5);
  }
  
  // è»¸ã‚¿ã‚¤ãƒˆãƒ«
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(graphType === 'speed' ? 'Throttle (%)' : 'Steering (%)', margin + width / 2, canvas.height - 5);
  
  ctx.save();
  ctx.translate(15, margin + height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(graphType === 'speed' ? 'Speed (m/s)' : 'Angle (deg)', 0, 0);
  ctx.restore();
}

// ãƒã‚¤ãƒ³ãƒˆè¿½åŠ 
function addSpeedPoint() {
  const range = graphRanges.speed;
  const newKey = speedMap.length > 0 ? speedMap[speedMap.length - 1].key + 10 : (range.xMin + range.xMax) / 2;
  const newValue = speedMap.length > 0 ? speedMap[speedMap.length - 1].value + 0.5 : (range.yMin + range.yMax) / 2;
  speedMap.push({key: Math.min(newKey, range.xMax), value: Math.min(newValue, range.yMax)});
  speedMap.sort((a, b) => a.key - b.key);
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

function addSteeringPoint() {
  const range = graphRanges.steering;
  const newKey = steeringMap.length > 0 ? steeringMap[steeringMap.length - 1].key + 25 : 0;
  const newValue = steeringMap.length > 0 ? steeringMap[steeringMap.length - 1].value + 11.25 : 0;
  steeringMap.push({key: Math.min(newKey, range.xMax), value: Math.min(newValue, range.yMax)});
  steeringMap.sort((a, b) => a.key - b.key);
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

// ãƒãƒƒãƒ—ãƒªã‚»ãƒƒãƒˆ
function resetSpeedMap() {
  speedMap = [
    {key: 0, value: 0}, {key: 10, value: 0.2}, {key: 20, value: 0.4},
    {key: 30, value: 1}, {key: 40, value: 1.5}, {key: 50, value: 2},
    {key: 60, value: 2.5}, {key: 70, value: 3}, {key: 80, value: 3.5},
    {key: 90, value: 4}, {key: 100, value: 5}
  ];
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

function resetSteeringMap() {
  steeringMap = [
    {key: -100, value: -45}, {key: -50, value: -22.5},
    {key: 0, value: 0}, {key: 50, value: 22.5}, {key: 100, value: 45}
  ];
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

// ãƒãƒƒãƒ—ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
function exportMaps() {
  const maps = {speedMap, steeringMap, sensorAngles, graphRanges};
  const dataStr = JSON.stringify(maps, null, 2);
  const dataBlob = new Blob([dataStr], {type: 'application/json'});
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'minicar_maps_v4.json';
  link.click();
  URL.revokeObjectURL(url);
}

function importMaps() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
      try {
        const maps = JSON.parse(event.target.result);
        speedMap = maps.speedMap;
        steeringMap = maps.steeringMap;
        if (maps.sensorAngles) {
          sensorAngles = maps.sensorAngles;
          Object.keys(sensorAngles).forEach(sensor => {
            document.getElementById(`angle${sensor}`).value = sensorAngles[sensor];
            document.querySelector(`#angle${sensor}`).previousElementSibling.value = sensorAngles[sensor];
          });
        }
        if (maps.graphRanges) {
          graphRanges = maps.graphRanges;
          document.getElementById('speedXMin').value = graphRanges.speed.xMin;
          document.getElementById('speedXMax').value = graphRanges.speed.xMax;
          document.getElementById('speedYMin').value = graphRanges.speed.yMin;
          document.getElementById('speedYMax').value = graphRanges.speed.yMax;
          document.getElementById('steeringXMin').value = graphRanges.steering.xMin;
          document.getElementById('steeringXMax').value = graphRanges.steering.xMax;
          document.getElementById('steeringYMin').value = graphRanges.steering.yMin;
          document.getElementById('steeringYMax').value = graphRanges.steering.yMax;
        }
        drawAllGraphs();
        calculatePositions();
        drawTrack();
      } catch (error) {
        alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

// çµ±è¨ˆæƒ…å ±æ›´æ–°
function updateStats() {
  if (!csvData.length) return;
  
  document.getElementById('totalPoints').textContent = csvData.length;
  
  let totalDistance = 0;
  let maxSpeed = 0;
  let totalSpeed = 0;
  
  csvData.forEach((row, i) => {
    const thr = parseFloat(row[headers.indexOf('Thr')]);
    const speed = interpolateMap(speedMap, thr);
    const dt = i > 0 ? (parseFloat(row[0]) - parseFloat(csvData[i-1][0])) : 0.04;
    
    totalDistance += speed * dt;
    maxSpeed = Math.max(maxSpeed, speed);
    totalSpeed += speed;
  });
  
  document.getElementById('trackLength').textContent = totalDistance.toFixed(2) + 'm';
  document.getElementById('maxSpeed').textContent = maxSpeed.toFixed(2) + 'm/s';
  document.getElementById('avgSpeed').textContent = (totalSpeed / csvData.length).toFixed(2) + 'm/s';
}

// è»Œè·¡æç”»ï¼ˆæœ€é‡è¦é–¢æ•°ï¼‰
function drawTrack() {
  const canvas = document.getElementById('trackCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!positions.length) return;

  const activeSensors = Array.from(document.querySelectorAll('.sensorCheckbox:checked')).map(cb => cb.value);

  const xs = positions.map(p => p.x);
  const ys = positions.map(p => p.y);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  
  const margin = 80;
  const scaleX = (canvas.width - 2 * margin) / (maxX - minX + VEHICLE_LENGTH * 2);
  const scaleY = (canvas.height - 2 * margin) / (maxY - minY + VEHICLE_LENGTH * 2);
  const scale = Math.min(scaleX, scaleY);
  
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  // ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’ä¿å­˜ï¼ˆã‚¯ãƒªãƒƒã‚¯å‡¦ç†ã§ä½¿ç”¨ï¼‰
  canvasScaleInfo = { minX, minY, scale, margin, centerX, centerY };

  // å¤‰æ›ã‚’é©ç”¨ã—ã¦æç”»
  ctx.save();
  ctx.translate(centerX + mapOffsetX, centerY + mapOffsetY);
  ctx.rotate(mapRotation);
  ctx.scale(mapZoom, mapZoom);
  ctx.translate(-centerX, -centerY);

  // èƒŒæ™¯ã‚°ãƒªãƒƒãƒ‰
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1 / mapZoom;
  for(let i = 0; i <= 20; i++){
    const x = margin + i * (canvas.width - 2 * margin) / 20;
    ctx.beginPath();
    ctx.moveTo(x, margin);
    ctx.lineTo(x, canvas.height - margin);
    ctx.stroke();
    
    const y = margin + i * (canvas.height - 2 * margin) / 20;
    ctx.beginPath();
    ctx.moveTo(margin, y);
    ctx.lineTo(canvas.width - margin, y);
    ctx.stroke();
  }

  // å…¨æ™‚åˆ»ç¯„å›²ã®è»Œè·¡ç·šã‚’æç”»
  ctx.strokeStyle = 'rgba(0,200,255,0.5)';
  ctx.lineWidth = 2 / mapZoom;
  ctx.beginPath();
  positions.forEach((p, i) => {
    const cx = margin + (p.x - minX) * scale;
    const cy = margin + (p.y - minY) * scale;
    if (i === 0) {
      ctx.moveTo(cx, cy);
    } else {
      ctx.lineTo(cx, cy);
    }
  });
  ctx.stroke();

  // ã‚»ãƒ³ã‚µãƒ¼ã”ã¨ã«ç‚¹ã¨ç·šã‚’æç”»
  activeSensors.forEach(name => {
    const idx = headers.indexOf(name);
    if (idx < 0) return;
    
    const color = sensorColors[name];
    const sensorAngleRad = (sensorAngles[name] || 0) * Math.PI / 180;
    
    let sensorPoints = [];
    positions.forEach((p, i) => {
      if (i % sensorDensity !== 0) return;
      
      const cx = margin + (p.x - minX) * scale;
      const cy = margin + (p.y - minY) * scale;
      const distance = parseFloat(p.row[idx]);
      
      const totalAngle = p.theta + sensorAngleRad;
      const sx = cx + distance * scale * Math.cos(totalAngle);
      const sy = cy + distance * scale * Math.sin(totalAngle);
      
      sensorPoints.push({x: sx, y: sy, index: i});
    });
    
    // ç·šã‚’æç”»
    if (sensorPoints.length > 1) {
      ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`;
      ctx.lineWidth = sensorLineWidth / mapZoom;
      ctx.beginPath();
      sensorPoints.forEach((point, i) => {
        if (i === 0) {
          ctx.moveTo(point.x, point.y);
        } else {
          ctx.lineTo(point.x, point.y);
        }
      });
      ctx.stroke();
    }
    
    // ã‚»ãƒ³ã‚µãƒ¼ç‚¹ã‚’æç”»ï¼ˆæ™‚åˆ»ã«åŸºã¥ã„ã¦è¦–è¦šçš„ã«å¤‰åŒ–ï¼‰
    sensorPoints.forEach(point => {
      const timeDiff = point.index - currentTimeIndex;
      let pointSize = sensorPointSize / mapZoom;
      let pointColor = color;
      let alpha = 0.95;
      
      if (timeDiff < 0) {
        // éå»ã®ãƒ—ãƒ­ãƒƒãƒˆ
        const pastIndex = Math.abs(timeDiff);
        
        if (pastIndex <= pastPlotsCount * sensorDensity) {
          // éå»pastPlotsCountå€‹ã®ãƒ—ãƒ­ãƒƒãƒˆï¼šé †ã«å°ã•ãã™ã‚‹
          const ratio = 1 - (pastIndex / (pastPlotsCount * sensorDensity)) * 0.6;
          pointSize = (sensorPointSize / mapZoom) * ratio;
          alpha = 0.95 * ratio;
        } else {
          // ãã‚Œã‚ˆã‚Šéå»ï¼šå°ã•ãç°è‰²
          pointSize = (sensorPointSize / mapZoom) * 0.3;
          pointColor = {r: 128, g: 128, b: 128};
          alpha = 0.4;
        }
      } else if (timeDiff > 0) {
        // æœªæ¥ã®ãƒ—ãƒ­ãƒƒãƒˆ
        if (futurePlotsCount === 0) {
          // 0æŒ‡å®šã®å ´åˆã¯å…¨åŒºé–“é€šå¸¸ã‚µã‚¤ã‚º
          pointSize = sensorPointSize / mapZoom;
        alpha = 0.7;
        } else {
          const futureIndex = timeDiff;
          if (futureIndex <= futurePlotsCount * sensorDensity) {
            // æœªæ¥futurePlotsCountå€‹ã®ãƒ—ãƒ­ãƒƒãƒˆï¼šé€šå¸¸ã‚µã‚¤ã‚º
            pointSize = sensorPointSize / mapZoom;
            alpha = 0.7;
          } else {
            // ãã‚Œã‚ˆã‚Šæœªæ¥ï¼šå°ã•ãç°è‰²
            pointSize = (sensorPointSize / mapZoom) * 0.3;
            pointColor = {r: 128, g: 128, b: 128};
            alpha = 0.4;
          }
        }
      }
      
      // ãƒã‚¤ãƒ³ãƒˆæç”»
      const grd = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, pointSize);
      grd.addColorStop(0, `rgba(${pointColor.r}, ${pointColor.g}, ${pointColor.b}, ${alpha})`);
      grd.addColorStop(1, `rgba(${pointColor.r}, ${pointColor.g}, ${pointColor.b}, 0)`);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(point.x, point.y, pointSize, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // ç¾åœ¨æ™‚åˆ»ã®ã‚»ãƒ³ã‚µãƒ¼ç‚¹ã‚’ç‰¹ã«ç›®ç«‹ãŸã›ã‚‹
    const currentPoint = sensorPoints.find(p => p.index === currentTimeIndex);
    if (currentPoint) {
      // å¤–å´ã®å…‰ã‚‹è¼ª
      const outerGrd = ctx.createRadialGradient(currentPoint.x, currentPoint.y, 0, currentPoint.x, currentPoint.y, (sensorPointSize / mapZoom) * 3);
      outerGrd.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`);
      outerGrd.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`);
      outerGrd.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
      ctx.fillStyle = outerGrd;
      ctx.beginPath();
      ctx.arc(currentPoint.x, currentPoint.y, (sensorPointSize / mapZoom) * 3, 0, Math.PI * 2);
      ctx.fill();
      
      // ä¸­å¿ƒã®æ˜ã‚‹ã„ç‚¹
      ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
      ctx.beginPath();
      ctx.arc(currentPoint.x, currentPoint.y, (sensorPointSize / mapZoom) * 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // ç™½ã„ç¸å–ã‚Š
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
      ctx.lineWidth = 2 / mapZoom;
      ctx.stroke();
    }
  });

  // ç¾åœ¨ã¾ã§ã®è»Œè·¡ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  if (currentTimeIndex > 0) {
    ctx.strokeStyle = 'rgba(0,255,255,0.9)';
    ctx.lineWidth = 3 / mapZoom;
    ctx.beginPath();
    for (let i = 0; i <= currentTimeIndex && i < positions.length; i++) {
      const p = positions[i];
      const cx = margin + (p.x - minX) * scale;
      const cy = margin + (p.y - minY) * scale;
      if (i === 0) {
        ctx.moveTo(cx, cy);
      } else {
        ctx.lineTo(cx, cy);
      }
    }
    ctx.stroke();
  }

  // ç¾åœ¨ã®è»Šä¸¡ä½ç½®ã‚’æç”»
  if (currentTimeIndex < positions.length) {
    const currentPos = positions[currentTimeIndex];
    const cx = margin + (currentPos.x - minX) * scale;
    const cy = margin + (currentPos.y - minY) * scale;
    
    // è·é›¢ã‚µãƒ¼ã‚¯ãƒ«ã‚’æç”»
    drawDistanceCircles(ctx, cx, cy, scale);
    
    // è»Šä¸¡ã‚’æç”»
    drawVehicle(ctx, cx, cy, currentPos.theta, scale / mapZoom);
  }

  ctx.restore();
  
  // å¤‰æ›ã‚’é©ç”¨ã—ãªã„è¦ç´ ï¼ˆå‡¡ä¾‹ã€ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã€ã‚³ãƒ³ãƒ‘ã‚¹ï¼‰
  drawLegend(ctx, canvas, activeSensors);
  drawScaleInfo(ctx, canvas, scale);
  drawCompass(ctx, canvas);
}

// ã‚³ãƒ³ãƒ‘ã‚¹æç”»
function drawCompass(ctx, canvas) {
  const compassX = canvas.width - 80;
  const compassY = 80;
  const compassRadius = 40;
  
  ctx.save();
  
  // èƒŒæ™¯å††
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.beginPath();
  ctx.arc(compassX, compassY, compassRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // å¤–æ 
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // å›è»¢ã‚’é©ç”¨
  ctx.translate(compassX, compassY);
  ctx.rotate(mapRotation);
  
  // åŒ—ã‚’æŒ‡ã™çŸ¢å°ï¼ˆèµ¤ï¼‰
  ctx.fillStyle = '#ff4444';
  ctx.beginPath();
  ctx.moveTo(0, -compassRadius * 0.7);
  ctx.lineTo(-compassRadius * 0.2, 0);
  ctx.lineTo(0, -compassRadius * 0.3);
  ctx.lineTo(compassRadius * 0.2, 0);
  ctx.closePath();
  ctx.fill();
  
  // å—ã‚’æŒ‡ã™çŸ¢å°ï¼ˆç™½ï¼‰
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(0, compassRadius * 0.7);
  ctx.lineTo(-compassRadius * 0.2, 0);
  ctx.lineTo(0, compassRadius * 0.3);
  ctx.lineTo(compassRadius * 0.2, 0);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
  
  // Næ–‡å­—ï¼ˆå¸¸ã«ä¸Šå‘ãï¼‰
  ctx.fillStyle = '#ff4444';
  ctx.font = 'bold 16px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('N', compassX, compassY - compassRadius - 15);
}

// ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±æç”»
function drawScaleInfo(ctx, canvas, scale) {
  const infoX = 20;
  const infoY = 20;
  
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(infoX - 10, infoY - 10, 220, 130);
  
  ctx.fillStyle = '#4ecdc4';
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'left';
  ctx.fillText('ğŸ“ ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±', infoX, infoY + 15);
  
  ctx.fillStyle = '#fff';
  ctx.font = '12px Arial';
  ctx.fillText(`è»Šä¸¡: ${VEHICLE_LENGTH}Ã—${VEHICLE_WIDTH}mm`, infoX, infoY + 40);
  ctx.fillText(`ã‚³ãƒ¼ã‚¹å¹…: ç´„${COURSE_WIDTH}mm`, infoX, infoY + 60);
  ctx.fillText(`è¡¨ç¤ºå€ç‡: Ã—${(scale * mapZoom).toFixed(3)}`, infoX, infoY + 80);
  ctx.fillText(`ã‚ºãƒ¼ãƒ : ${mapZoom.toFixed(1)}x`, infoX, infoY + 100);
  
  const barLength = 100 * scale * mapZoom;
  ctx.strokeStyle = '#4ecdc4';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(infoX, infoY + 115);
  ctx.lineTo(infoX + barLength, infoY + 115);
  ctx.stroke();
  
  ctx.fillStyle = '#4ecdc4';
  ctx.font = '11px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('100mm', infoX + barLength / 2, infoY + 110);
}

// å‡¡ä¾‹æç”»
function drawLegend(ctx, canvas, activeSensors) {
  const legendX = canvas.width - 180;
  const legendY = 170;  // ã‚³ãƒ³ãƒ‘ã‚¹ã®ä¸‹ã«é…ç½®
  const lineHeight = 25;
  
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(legendX - 10, legendY - 10, 170, activeSensors.length * lineHeight + 50);
  
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'left';
  ctx.fillText('ã‚»ãƒ³ã‚µãƒ¼å‡¡ä¾‹', legendX, legendY + 15);
  
  ctx.font = '12px Arial';
  activeSensors.forEach((name, i) => {
    const color = sensorColors[name];
    const y = legendY + 40 + i * lineHeight;
    
    ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
    ctx.beginPath();
    ctx.arc(legendX + 10, y, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    const angle = sensorAngles[name] || 0;
    ctx.fillText(`${name} (${angle}Â°)`, legendX + 25, y + 4);
  });
}

// è·é›¢ã‚µãƒ¼ã‚¯ãƒ«æç”»
function drawDistanceCircles(ctx, x, y, scale) {
  const distances = [500, 1000, 1500, 2000, 2500, 3000];
  
  ctx.save();
  distances.forEach((dist, index) => {
    const radius = dist * scale;
    ctx.strokeStyle = `rgba(255,255,255,${0.3 - index * 0.07})`;
    ctx.lineWidth = 1 / mapZoom;
    ctx.setLineDash([5 / mapZoom, 5 / mapZoom]);
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // è·é›¢ãƒ©ãƒ™ãƒ«
    ctx.fillStyle = `rgba(255,255,255,${0.5 - index * 0.1})`;
    ctx.font = `${10 / mapZoom}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(`${dist}mm`, x, y - radius - 3 / mapZoom);
  });
  ctx.setLineDash([]);
  ctx.restore();
}

// è»Šä¸¡æç”»
function drawVehicle(ctx, x, y, theta, scale) {
  const length = VEHICLE_LENGTH * scale;
  const width = VEHICLE_WIDTH * scale;
  
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(theta);
  
  ctx.beginPath();
  ctx.moveTo(length * 0.4, 0);
  ctx.lineTo(length * 0.1, -width * 0.5);
  ctx.lineTo(-length * 0.4, -width * 0.5);
  ctx.lineTo(-length * 0.4, width * 0.5);
  ctx.lineTo(length * 0.1, width * 0.5);
  ctx.closePath();
  
  ctx.fillStyle = 'rgba(0,255,100,0.7)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.9)';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(length * 0.1, 0);
  ctx.lineTo(length * 0.4, 0);
  ctx.strokeStyle = 'rgba(255,255,0,1)';
  ctx.lineWidth = 3;
  ctx.stroke();
  
  ctx.restore();
}

// ç·šå½¢è£œé–“
function interpolateMap(mapArray, value) {
  if (!mapArray.length) return 0;
  
  mapArray.sort((a,b)=>a.key-b.key);
  if (value <= mapArray[0].key) return mapArray[0].value;
  if (value >= mapArray[mapArray.length-1].key) return mapArray[mapArray.length-1].value;
  for(let i=0;i<mapArray.length-1;i++){
    if(value>=mapArray[i].key && value<=mapArray[i+1].key){
      const v0=mapArray[i].value,v1=mapArray[i+1].value;
      const t=(value-mapArray[i].key)/(mapArray[i+1].key-mapArray[i].key);
      return v0+t*(v1-v0);
    }
  }
  return 0;
}
</script>
</body>
</html>
