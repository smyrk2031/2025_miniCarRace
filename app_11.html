<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ãƒŸãƒ‹ã‚«ãƒ¼SLAM Pro - é«˜åº¦æ“ä½œç‰ˆ</title>
<style>
* { box-sizing: border-box; }
body { 
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
  margin: 0; 
  padding: 0; 
  background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
  color: #fff;
  overflow-x: hidden;
}

.container {
  display: flex;
  height: 100vh;
}

.sidebar {
  width: 500px;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(10px);
  padding: 20px;
  overflow-y: auto;
  border-right: 2px solid rgba(255,255,255,0.1);
}

.main-content {
  flex: 1;
  padding: 20px;
  display: flex;
  flex-direction: column;
}

.table-sidebar {
  width: 400px;
  min-width: 200px;
  max-width: 800px;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(10px);
  border-left: 2px solid rgba(255,255,255,0.1);
  display: flex;
  flex-direction: column;
  position: relative;
  transition: width 0.3s ease;
}

.table-sidebar.closed {
  width: 0 !important;
  min-width: 0;
  padding: 0;
  border: none;
  overflow: hidden;
}

.table-header {
  padding: 15px;
  background: rgba(255,255,255,0.1);
  border-bottom: 2px solid rgba(255,255,255,0.1);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.table-header h3 {
  margin: 0;
  color: #4ecdc4;
  font-size: 1.1em;
}

.table-close-btn {
  background: rgba(255,100,100,0.6);
  border: none;
  border-radius: 5px;
  color: white;
  font-size: 16px;
  width: 30px;
  height: 30px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.table-close-btn:hover {
  background: rgba(255,100,100,0.9);
}

.table-toggle-btn {
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  width: 30px;
  height: 60px;
  background: rgba(78,205,196,0.8);
  border: none;
  border-radius: 5px 0 0 5px;
  color: white;
  font-size: 18px;
  cursor: pointer;
  display: none;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  z-index: 1000;
  pointer-events: auto;
}

.table-toggle-btn:hover {
  background: rgba(78,205,196,1);
  width: 32px;
}

body.table-closed .table-toggle-btn {
  display: flex;
}

.table-resize-handle {
  position: absolute;
  left: 0;
  top: 0;
  width: 5px;
  height: 100%;
  cursor: ew-resize;
  background: transparent;
  transition: background 0.3s ease;
}

.table-resize-handle:hover {
  background: rgba(78,205,196,0.5);
}

.table-container {
  flex: 1;
  overflow: auto;
  padding: 10px;
}

.data-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 12px;
  color: #fff;
}

.data-table thead {
  position: sticky;
  top: 0;
  background: rgba(0,0,0,0.95);
  z-index: 2;
}

.data-table th {
  padding: 8px 4px;
  text-align: left;
  border-bottom: 2px solid rgba(78,205,196,0.5);
  font-weight: bold;
  white-space: nowrap;
  background: rgba(0,0,0,0.95);
}

.data-table td {
  padding: 6px 4px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  white-space: nowrap;
}

.data-table tr:hover {
  background: rgba(255,255,255,0.05);
}

.data-table tr.current-row {
  background: rgba(0,255,100,0.3) !important;
  font-weight: bold;
}

.data-table tr.current-row td {
  border-top: 2px solid rgba(0,255,100,0.8);
  border-bottom: 2px solid rgba(0,255,100,0.8);
}

.header {
  text-align: center;
  margin-bottom: 25px;
  padding: 18px;
  background: rgba(255,255,255,0.1);
  border-radius: 15px;
  backdrop-filter: blur(10px);
}

.header h1 {
  margin: 0;
  font-size: 2em;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.header p {
  margin: 8px 0 0 0;
  opacity: 0.8;
  font-size: 1em;
}

.control-panel {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 18px;
  margin-bottom: 18px;
  border: 1px solid rgba(255,255,255,0.1);
}

.control-group {
  margin-bottom: 20px;
}

.control-group h3 {
  margin: 0 0 12px 0;
  color: #4ecdc4;
  font-size: 1.1em;
  border-bottom: 2px solid rgba(78,205,196,0.3);
  padding-bottom: 6px;
  cursor: pointer;
  user-select: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
}

.control-group h3:hover {
  color: #5fddce;
  background: rgba(78,205,196,0.1);
  padding-left: 8px;
  border-radius: 8px;
}

.control-group h3::after {
  content: 'â–¼';
  font-size: 0.8em;
  transition: transform 0.3s ease;
}

.control-group h3.collapsed::after {
  transform: rotate(-90deg);
}

.control-group-content {
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.3s ease;
  max-height: 2000px;
  opacity: 1;
}

.control-group-content.collapsed {
  max-height: 0;
  opacity: 0;
}

.file-input {
  width: 100%;
  padding: 10px;
  border: 2px dashed rgba(255,255,255,0.3);
  border-radius: 10px;
  background: rgba(255,255,255,0.05);
  color: #fff;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.file-input:hover {
  border-color: #4ecdc4;
  background: rgba(78,205,196,0.1);
}

.sensor-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.sensor-checkbox {
  display: flex;
  align-items: center;
  padding: 6px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
  transition: all 0.3s ease;
  font-size: 13px;
}

.sensor-checkbox:hover {
  background: rgba(255,255,255,0.1);
}

.sensor-checkbox input {
  margin-right: 6px;
  transform: scale(1.1);
}

.angle-controls {
  margin-top: 15px;
}

.angle-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px;
  margin-bottom: 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
}

.angle-item label {
  font-size: 12px;
  min-width: 80px;
}

.angle-item input[type="number"] {
  width: 70px;
  padding: 4px 8px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 4px;
  color: #fff;
  font-size: 13px;
  text-align: center;
}

.angle-item input[type="range"] {
  flex: 1;
  margin: 0 10px;
}

.interactive-graph {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 15px;
  border: 1px solid rgba(255,255,255,0.1);
  margin-bottom: 15px;
}

.graph-container {
  position: relative;
  width: 100%;
  height: 240px;
  background: rgba(0,0,0,0.3);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.2);
  margin: 12px 0;
  cursor: crosshair;
}

.graph-canvas {
  width: 100%;
  height: 100%;
  border-radius: 10px;
}

.graph-title {
  font-size: 1em;
  font-weight: bold;
  margin-bottom: 8px;
  color: #ff6b6b;
}

.graph-title.steering {
  color: #4ecdc4;
}

.graph-range-controls {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin-top: 8px;
  margin-bottom: 8px;
  padding: 10px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
}

.range-input-group {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
}

.range-input-group label {
  font-weight: bold;
  min-width: 40px;
}

.range-input-group input {
  width: 60px;
  padding: 4px 6px;
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 4px;
  color: #fff;
  font-size: 12px;
  text-align: center;
}

.graph-controls {
  display: flex;
  gap: 6px;
  margin-top: 8px;
  flex-wrap: wrap;
}

.btn {
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  border: none;
  padding: 5px 10px;
  border-radius: 12px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 11px;
}

.btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.btn:active {
  transform: translateY(0);
}

.btn.secondary {
  background: linear-gradient(45deg, #667eea, #764ba2);
}

.btn.danger {
  background: linear-gradient(45deg, #ff416c, #ff4b2b);
}

.canvas-wrapper {
  flex: 1;
  display: flex;
  flex-direction: column;
  background: rgba(0,0,0,0.3);
  border-radius: 20px;
  padding: 20px;
  border: 2px solid rgba(255,255,255,0.1);
}

.canvas-container {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
}

#trackCanvas {
  border: 2px solid rgba(255,255,255,0.3);
  border-radius: 15px;
  background: #111;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  cursor: grab;
}

#trackCanvas.dragging {
  cursor: grabbing;
}

.control-graph-panel {
  margin-top: 15px;
  padding: 10px 15px;
  background: rgba(255,255,255,0.05);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.1);
}

.control-graph-panel h3 {
  margin: 0 0 10px 0;
  color: #4ecdc4;
  font-size: 0.95em;
  text-align: center;
}

.control-graph-container {
  position: relative;
  width: 100%;
  height: 150px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.2);
  cursor: grab;
}

.control-graph-container.dragging {
  cursor: grabbing;
}

.control-graph-canvas {
  width: 100%;
  height: 100%;
  border-radius: 8px;
}

.control-graph-controls {
  display: flex;
  gap: 8px;
  margin-top: 8px;
  justify-content: center;
  align-items: center;
}

.control-graph-btn {
  background: rgba(78,205,196,0.6);
  border: none;
  padding: 4px 10px;
  border-radius: 10px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  font-size: 10px;
  transition: all 0.3s ease;
}

.control-graph-btn:hover {
  background: rgba(78,205,196,0.9);
  transform: translateY(-1px);
}

.zoom-mode-selector {
  display: flex;
  gap: 4px;
  background: rgba(0,0,0,0.3);
  padding: 4px;
  border-radius: 10px;
}

.zoom-mode-btn {
  background: rgba(255,255,255,0.1);
  border: none;
  padding: 4px 8px;
  border-radius: 6px;
  color: white;
  font-size: 10px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.zoom-mode-btn:hover {
  background: rgba(255,255,255,0.2);
}

.zoom-mode-btn.active {
  background: rgba(78,205,196,0.8);
  font-weight: bold;
}

.sensor-selection {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: center;
  padding: 8px;
  background: rgba(0,0,0,0.2);
  border-radius: 8px;
  margin-bottom: 8px;
}

.sensor-select-checkbox {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 0.85em;
}

.sensor-select-checkbox:hover {
  background: rgba(255,255,255,0.1);
}

.sensor-select-checkbox input[type="checkbox"] {
  cursor: pointer;
}

.map-control-item {
  display: flex;
  align-items: center;
  gap: 5px;
  margin-bottom: 6px;
  padding: 4px;
  background: rgba(0,0,0,0.2);
  border-radius: 4px;
}

.btn {
  padding: 8px 16px;
  border: none;
  border-radius: 8px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 0.9em;
}

.btn.primary {
  background: linear-gradient(135deg, #4ecdc4, #44a08d);
}

.btn.primary:hover {
  background: linear-gradient(135deg, #5fddce, #55b19d);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(78,205,196,0.4);
}

.btn.secondary {
  background: rgba(255,255,255,0.1);
}

.btn.secondary:hover {
  background: rgba(255,255,255,0.2);
  transform: translateY(-1px);
}

.tooltip-icon {
  display: inline-block;
  margin-left: 5px;
  width: 16px;
  height: 16px;
  background: rgba(255,255,255,0.1);
  border-radius: 50%;
  text-align: center;
  line-height: 16px;
  font-size: 12px;
  cursor: help;
  color: #4ecdc4;
  transition: all 0.3s ease;
}

.tooltip-icon:hover {
  background: rgba(78,205,196,0.3);
  transform: scale(1.2);
}

.accordion-section {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 0;
  margin-bottom: 18px;
  border: 1px solid rgba(255,255,255,0.1);
  overflow: hidden;
}

.accordion-title {
  margin: 0;
  padding: 15px 18px;
  color: #4ecdc4;
  font-size: 1.1em;
  cursor: pointer;
  user-select: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
  background: rgba(255,255,255,0.03);
}

.accordion-title:hover {
  background: rgba(78,205,196,0.1);
}

.accordion-icon {
  transition: transform 0.3s ease;
}

.accordion-content {
  padding: 18px;
  max-height: 2000px;
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
  opacity: 1;
}

.accordion-content.collapsed {
  max-height: 0;
  padding: 0 18px;
  opacity: 0;
}

.time-control-panel {
  margin-top: 0;
  margin-bottom: 15px;
  padding: 10px 15px;
  background: rgba(255,255,255,0.05);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.1);
}

.time-control-header {
  display: flex;
  align-items: center;
  gap: 15px;
  margin-bottom: 8px;
}

.time-control-panel h3 {
  margin: 0;
  color: #4ecdc4;
  font-size: 1em;
  flex-shrink: 0;
}

.time-slider-container {
  position: relative;
  padding: 8px 0;
  margin-bottom: 22px;
}

.time-slider {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: rgba(255,255,255,0.2);
  outline: none;
  -webkit-appearance: none;
  cursor: pointer;
}

.time-ticks {
  position: absolute;
  width: 100%;
  height: 18px;
  top: 18px;
  left: 0;
  display: flex;
  justify-content: space-between;
  pointer-events: none;
}

.time-tick {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
}

.time-tick-line {
  width: 1px;
  height: 6px;
  background: rgba(78,205,196,0.5);
  margin-bottom: 2px;
}

.time-tick-label {
  font-size: 9px;
  color: rgba(255,255,255,0.6);
  white-space: nowrap;
}

.time-slider::-webkit-slider-thumb {
  appearance: none;
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  cursor: pointer;
  box-shadow: 0 0 10px rgba(78,205,196,0.8);
}

.time-slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  cursor: pointer;
  border: none;
  box-shadow: 0 0 10px rgba(78,205,196,0.8);
}

.time-info {
  display: none;
}

.time-display {
  padding: 4px 12px;
  background: rgba(78,205,196,0.15);
  border-radius: 6px;
  font-size: 0.85em;
  font-weight: bold;
  white-space: nowrap;
  flex-shrink: 0;
}

.playback-controls {
  display: flex;
  gap: 6px;
  flex-shrink: 0;
}

.play-btn {
  background: linear-gradient(45deg, #00d2ff, #3a47d5);
  border: none;
  padding: 6px 12px;
  border-radius: 15px;
  color: white;
  font-weight: bold;
  cursor: pointer;
  font-size: 11px;
  transition: all 0.3s ease;
  white-space: nowrap;
}

.play-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 5px 15px rgba(0,210,255,0.4);
}

.stats-panel {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 12px;
  margin-top: 15px;
  border: 1px solid rgba(255,255,255,0.1);
}

.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.stat-item {
  text-align: center;
  padding: 6px;
  background: rgba(255,255,255,0.05);
  border-radius: 6px;
}

.stat-value {
  font-size: 1.2em;
  font-weight: bold;
  color: #4ecdc4;
}

.stat-label {
  font-size: 0.8em;
  opacity: 0.8;
  margin-top: 3px;
}

.map-quality-panel {
  background: rgba(255,255,255,0.05);
  border-radius: 15px;
  padding: 12px;
  margin-top: 15px;
  border: 1px solid rgba(255,255,255,0.1);
}

.map-quality-panel h3, .interactive-graph h3, .stats-panel h3 {
  cursor: pointer;
  user-select: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: all 0.3s ease;
  padding: 6px;
  border-radius: 8px;
}

.map-quality-panel h3:hover, .interactive-graph h3:hover, .stats-panel h3:hover {
  background: rgba(78,205,196,0.1);
}

.map-quality-panel h3::after, .interactive-graph h3::after, .stats-panel h3::after {
  content: 'â–¼';
  font-size: 0.8em;
  transition: transform 0.3s ease;
}

.map-quality-panel h3.collapsed::after, .interactive-graph h3.collapsed::after, .stats-panel h3.collapsed::after {
  transform: rotate(-90deg);
}

.panel-content {
  overflow: hidden;
  transition: max-height 0.3s ease, opacity 0.3s ease;
  max-height: 3000px;
  opacity: 1;
}

.panel-content.collapsed {
  max-height: 0;
  opacity: 0;
}

.quality-slider {
  width: 100%;
  margin: 8px 0;
}

.quality-label {
  display: flex;
  justify-content: space-between;
  font-size: 0.85em;
  opacity: 0.8;
}

.map-control-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-top: 12px;
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³ */
@media (max-width: 1400px) {
  .container {
    flex-direction: column;
  }
  
  .sidebar {
    width: 100%;
    height: auto;
    max-height: 60vh;
  }
  
  .main-content {
    height: 40vh;
  }
}

/* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.control-panel, .interactive-graph, .stats-panel {
  animation: fadeIn 0.6s ease-out;
}

/* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º */
.sidebar::-webkit-scrollbar {
  width: 8px;
}

.sidebar::-webkit-scrollbar-track {
  background: rgba(255,255,255,0.1);
  border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb {
  background: rgba(78,205,196,0.6);
  border-radius: 4px;
}

.sidebar::-webkit-scrollbar-thumb:hover {
  background: rgba(78,205,196,0.8);
}
</style>
</head>
<body>

<div class="container">
  <div class="sidebar">
    <div class="header">
      <h1>ğŸš— ãƒŸãƒ‹ã‚«ãƒ¼SLAM Pro</h1>
      <p>é«˜åº¦æ“ä½œç‰ˆ - Zoomãƒ»Rotationãƒ»Dragå¯¾å¿œ</p>
      <p style="font-size: 0.85em; opacity: 0.7; margin-top: 3px;">Simultaneous Localization And Mapping</p>
    </div>

    <div class="control-panel">
      <div class="control-group">
        <h3>ğŸ“ ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«</h3>
        <div class="control-group-content">
        <input type="file" id="csvFile" accept=".csv" class="file-input">
        </div>
      </div>

      <div class="control-group">
        <h3>ğŸ” æœ‰åŠ¹ã‚»ãƒ³ã‚µ</h3>
        <div class="control-group-content">
        <div class="sensor-controls">
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(255,50,150,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="RrLH" checked>
            <span style="color: #ff3296;">â—</span> RrLH
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(100,200,255,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="FrLH" checked>
            <span style="color: #64c8ff;">â—</span> FrLH
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(50,255,50,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="Fr" checked>
            <span style="color: #32ff32;">â—</span> Fr
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(255,200,50,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="FrRH" checked>
            <span style="color: #ffc832;">â—</span> FrRH
          </label>
          <label class="sensor-checkbox" style="background: linear-gradient(to right, rgba(255,100,50,0.2), rgba(255,255,255,0.05));">
            <input type="checkbox" class="sensorCheckbox" value="RrRH" checked>
            <span style="color: #ff6432;">â—</span> RrRH
          </label>
          </div>
        </div>
      </div>

      <div class="control-group">
        <h3>ğŸ“ ã‚»ãƒ³ã‚µãƒ¼å–ä»˜è§’åº¦ï¼ˆè»Šä¸¡å‰æ–¹ã‚’0åº¦ã€å³å›ã‚Šï¼‰</h3>
        <div class="control-group-content">
        <div class="angle-controls">
          <div class="angle-item">
            <label><span style="color: #32ff32;">â—</span> Fr (æ­£é¢)</label>
            <input type="range" min="0" max="360" value="0" oninput="updateSensorAngle('Fr', this.value)">
            <input type="number" id="angleFr" min="0" max="360" value="0" onchange="updateSensorAngle('Fr', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #ffc832;">â—</span> FrRH (å³å‰)</label>
            <input type="range" min="0" max="360" value="35" oninput="updateSensorAngle('FrRH', this.value)">
            <input type="number" id="angleFrRH" min="0" max="360" value="35" onchange="updateSensorAngle('FrRH', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #ff6432;">â—</span> RrRH (å³å¾Œ)</label>
            <input type="range" min="0" max="360" value="90" oninput="updateSensorAngle('RrRH', this.value)">
            <input type="number" id="angleRrRH" min="0" max="360" value="90" onchange="updateSensorAngle('RrRH', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #ff3296;">â—</span> RrLH (å·¦å¾Œ)</label>
            <input type="range" min="0" max="360" value="270" oninput="updateSensorAngle('RrLH', this.value)">
            <input type="number" id="angleRrLH" min="0" max="360" value="270" onchange="updateSensorAngle('RrLH', this.value)">Â°
          </div>
          <div class="angle-item">
            <label><span style="color: #64c8ff;">â—</span> FrLH (å·¦å‰)</label>
            <input type="range" min="0" max="360" value="325" oninput="updateSensorAngle('FrLH', this.value)">
            <input type="number" id="angleFrLH" min="0" max="360" value="325" onchange="updateSensorAngle('FrLH', this.value)">Â°
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="interactive-graph">
      <h3>âš™ï¸ ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒãƒƒãƒ—èª¿æ•´</h3>
      
      <div class="control-group" style="margin-bottom: 15px; padding: 10px; background: rgba(78,205,196,0.1); border-radius: 8px;">
        <label style="font-size: 0.9em; display: block; margin-bottom: 5px; color: #4ecdc4; font-weight: bold;">ğŸš— ãƒ›ã‚¤ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ (mm)</label>
        <div class="slider-container">
          <input type="range" min="50" max="500" step="10" value="150" oninput="updateWheelbase(this.value)" style="flex: 1;">
          <input type="number" id="wheelbaseValue" min="50" max="500" step="10" value="150" onchange="updateWheelbase(this.value)" style="width: 70px;">
        </div>
      </div>
      
      <div class="control-group" style="margin-bottom: 15px; padding: 10px; background: rgba(255,184,77,0.1); border-radius: 8px; border: 1px solid rgba(255,184,77,0.3);">
        <h4 style="margin: 0 0 10px 0; color: #ffb84d; font-size: 0.95em;">âš™ï¸ ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</h4>
        
        <label style="font-size: 0.85em; display: flex; align-items: center; margin-bottom: 3px;">
          ğŸ“ é€Ÿåº¦ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°
          <span class="tooltip-icon" title="é€Ÿåº¦ã®å…¨ä½“çš„ãªå€ç‡ã‚’èª¿æ•´ã—ã¾ã™ã€‚ã‚³ãƒ¼ã‚¹å…¨ä½“ãŒå¤§ãã™ãã‚‹/å°ã•ã™ãã‚‹å ´åˆã«èª¿æ•´ã—ã¦ãã ã•ã„ã€‚">â“˜</span>
        </label>
        <div class="slider-container" style="margin-bottom: 12px;">
          <input type="range" min="0.1" max="10" step="0.1" value="1.0" oninput="updateSpeedScale(this.value)" style="flex: 1;">
          <input type="number" id="speedScaleValue" min="0.1" max="10" step="0.1" value="1.0" onchange="updateSpeedScale(this.value)" style="width: 70px;">
        </div>
        
        <label style="font-size: 0.85em; display: flex; align-items: center; margin-bottom: 3px;">
          ğŸ¯ æ“èˆµã‚²ã‚¤ãƒ³
          <span class="tooltip-icon" title="æ›²ãŒã‚Šå…·åˆã®å¼·ã•ã‚’èª¿æ•´ã—ã¾ã™ã€‚ã‚«ãƒ¼ãƒ–ãŒç·©ã™ãã‚‹/ãã¤ã™ãã‚‹å ´åˆã«èª¿æ•´ã—ã¦ãã ã•ã„ã€‚">â“˜</span>
        </label>
        <div class="slider-container" style="margin-bottom: 12px;">
          <input type="range" min="0.1" max="5" step="0.1" value="1.0" oninput="updateSteeringGain(this.value)" style="flex: 1;">
          <input type="number" id="steeringGainValue" min="0.1" max="5" step="0.1" value="1.0" onchange="updateSteeringGain(this.value)" style="width: 70px;">
        </div>
        
        <label style="font-size: 0.85em; display: flex; align-items: center; margin-bottom: 3px;">
          â±ï¸ æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«
          <span class="tooltip-icon" title="æ™‚é–“ã®æµã‚Œã‚’èª¿æ•´ã—ã¾ã™ã€‚é€šå¸¸ã¯1.0ã®ã¾ã¾ã§å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚">â“˜</span>
        </label>
        <div class="slider-container" style="margin-bottom: 12px;">
          <input type="range" min="0.1" max="5" step="0.1" value="1.0" oninput="updateTimeScale(this.value)" style="flex: 1;">
          <input type="number" id="timeScaleValue" min="0.1" max="5" step="0.1" value="1.0" onchange="updateTimeScale(this.value)" style="width: 70px;">
        </div>
        
        <button class="btn primary" onclick="recalculatePositions()" style="width: 100%; font-size: 0.85em;">ğŸ’« ä½ç½®ã‚’å†è¨ˆç®—</button>
        <button class="btn secondary" onclick="resetCalibration()" style="width: 100%; font-size: 0.85em; margin-top: 5px;">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
      
      <div class="control-group" style="margin-bottom: 15px; padding: 10px; background: rgba(138,201,38,0.1); border-radius: 8px; border: 1px solid rgba(138,201,38,0.3);">
        <h4 style="margin: 0 0 10px 0; color: #8ac926; font-size: 0.95em;">ğŸ“ å®Ÿã‚³ãƒ¼ã‚¹å¯¸æ³•</h4>
        
        <label style="font-size: 0.85em; display: block; margin-bottom: 3px;">ç¸¦ç·šã®é•·ã• (m)</label>
        <input type="number" id="courseVertical" min="1" max="100" step="0.5" value="15" style="width: 100%; margin-bottom: 8px; padding: 4px;">
        
        <label style="font-size: 0.85em; display: block; margin-bottom: 3px;">æ¨ªç·šã®é•·ã• (m)</label>
        <input type="number" id="courseHorizontal" min="1" max="100" step="0.5" value="4" style="width: 100%; margin-bottom: 8px; padding: 4px;">
        
        <label style="font-size: 0.85em; display: block; margin-bottom: 3px;">é“å¹… (m)</label>
        <input type="number" id="courseWidth" min="0.5" max="10" step="0.1" value="1.5" style="width: 100%; margin-bottom: 8px; padding: 4px;">
        
        <button class="btn" onclick="showCourseReference()" style="width: 100%; font-size: 0.85em;">ğŸ“Š ã‚³ãƒ¼ã‚¹å‚ç…§ç·šã‚’è¡¨ç¤º</button>
      </div>
      
      <div>
        <div class="graph-title">ğŸš— è»Šé€Ÿãƒãƒƒãƒ— (Thr% â†’ m/s)</div>
        <div class="graph-range-controls">
          <div class="range-input-group">
            <label>Xè»¸ Min:</label>
            <input type="number" id="speedXMin" value="0" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Xè»¸ Max:</label>
            <input type="number" id="speedXMax" value="100" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Min:</label>
            <input type="number" id="speedYMin" value="0" step="0.5" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Max:</label>
            <input type="number" id="speedYMax" value="5" step="0.5" onchange="updateGraphRange()">
          </div>
        </div>
        <div class="graph-container" id="speedGraphContainer">
          <canvas class="graph-canvas" id="speedGraph"></canvas>
        </div>
        <div class="graph-controls">
          <button class="btn" onclick="addSpeedPoint()">+</button>
          <button class="btn secondary" onclick="resetSpeedMap()">ğŸ”„</button>
        </div>
      </div>

      <div style="margin-top: 15px;">
        <div class="graph-title steering">ğŸ¯ æ“èˆµãƒãƒƒãƒ— (Str% â†’ åº¦)</div>
        <div class="graph-range-controls">
          <div class="range-input-group">
            <label>Xè»¸ Min:</label>
            <input type="number" id="steeringXMin" value="-100" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Xè»¸ Max:</label>
            <input type="number" id="steeringXMax" value="100" step="10" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Min:</label>
            <input type="number" id="steeringYMin" value="-45" step="5" onchange="updateGraphRange()">
          </div>
          <div class="range-input-group">
            <label>Yè»¸ Max:</label>
            <input type="number" id="steeringYMax" value="45" step="5" onchange="updateGraphRange()">
          </div>
        </div>
        <div class="graph-container" id="steeringGraphContainer">
          <canvas class="graph-canvas" id="steeringGraph"></canvas>
        </div>
        <div class="graph-controls">
          <button class="btn" onclick="addSteeringPoint()">+</button>
          <button class="btn secondary" onclick="resetSteeringMap()">ğŸ”„</button>
        </div>
      </div>

      <div style="margin-top: 12px; text-align: center;">
        <button class="btn" onclick="exportMaps()">ğŸ’¾ ä¿å­˜</button>
        <button class="btn" onclick="importMaps()">ğŸ“ èª­è¾¼</button>
      </div>
    </div>

    <div class="map-quality-panel">
      <h3>ğŸ¨ ãƒãƒƒãƒ—è¡¨ç¤ºè¨­å®š</h3>
      <div class="quality-label">
        <span>ã‚»ãƒ³ã‚µç‚¹å¯†åº¦</span>
        <span id="densityValue">1</span>
      </div>
      <input type="range" class="quality-slider" id="densitySlider" min="1" max="100" value="1" oninput="updateDensity(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>ã‚»ãƒ³ã‚µç‚¹ã‚µã‚¤ã‚º</span>
        <span id="sizeValue">4px</span>
      </div>
      <input type="range" class="quality-slider" id="sizeSlider" min="1" max="10" value="4" oninput="updatePointSize(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>ç·šã®å¤ªã•</span>
        <span id="lineWidthValue">1px</span>
      </div>
      <input type="range" class="quality-slider" id="lineWidthSlider" min="0.5" max="3" step="0.5" value="1" oninput="updateLineWidth(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>éå»ãƒ—ãƒ­ãƒƒãƒˆè¡¨ç¤ºæ•°</span>
        <span id="pastPlotsValue">5</span>
      </div>
      <input type="range" class="quality-slider" id="pastPlotsSlider" min="0" max="20" value="5" oninput="updatePastPlots(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>æœªæ¥ãƒ—ãƒ­ãƒƒãƒˆè¡¨ç¤ºæ•° (0=å…¨åŒºé–“)</span>
        <span id="futurePlotsValue">5</span>
      </div>
      <input type="range" class="quality-slider" id="futurePlotsSlider" min="0" max="20" value="5" oninput="updateFuturePlots(this.value)">
    </div>
    
    <div class="map-quality-panel">
      <h3>ğŸ—ºï¸ ãƒãƒƒãƒ—æ“ä½œè¨­å®š</h3>
      <div class="quality-label">
        <span>ã‚ºãƒ¼ãƒ </span>
        <span id="zoomValue">1.0x</span>
      </div>
      <input type="range" class="quality-slider" id="zoomSlider" min="0.1" max="10" step="0.1" value="1" oninput="updateZoom(this.value)">
      
      <div class="quality-label" style="margin-top: 12px;">
        <span>å›è»¢è§’åº¦</span>
        <span id="rotationValue">0Â°</span>
      </div>
      <input type="range" class="quality-slider" id="rotationSlider" min="0" max="360" step="1" value="0" oninput="updateRotation(this.value)">
      
      <div class="map-control-buttons">
        <button class="btn secondary" onclick="resetView()">ğŸ”„ ãƒ“ãƒ¥ãƒ¼ãƒªã‚»ãƒƒãƒˆ</button>
        <button class="btn secondary" onclick="resetRotation()">ğŸ§­ æ–¹è§’ãƒªã‚»ãƒƒãƒˆ</button>
      </div>
    </div>

    <div class="stats-panel">
      <h3>ğŸ“Š çµ±è¨ˆæƒ…å ±</h3>
      <div class="stats-grid">
        <div class="stat-item">
          <div class="stat-value" id="totalPoints">0</div>
          <div class="stat-label">ç·ãƒ‡ãƒ¼ã‚¿æ•°</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="trackLength">0m</div>
          <div class="stat-label">è»Œè·¡é•·</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="maxSpeed">0m/s</div>
          <div class="stat-label">æœ€å¤§é€Ÿåº¦</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="avgSpeed">0m/s</div>
          <div class="stat-label">å¹³å‡é€Ÿåº¦</div>
        </div>
      </div>
    </div>
  </div>

  <div class="main-content">
    <div class="canvas-wrapper">
      <div class="time-control-panel">
        <div class="time-control-header">
          <h3>â±ï¸ ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³åˆ¶å¾¡</h3>
          <div class="time-display" id="timeDisplay">æ™‚åˆ»: --:--:--.---</div>
          <div class="playback-controls">
            <button class="play-btn" id="playBtn" onclick="togglePlayback()">â–¶ å†ç”Ÿ</button>
            <button class="play-btn" onclick="resetPlayback()">â® æœ€åˆã‹ã‚‰</button>
            <button class="play-btn" onclick="jumpToEnd()">â­ æœ€å¾Œã¸</button>
          </div>
        </div>
        <div class="time-slider-container">
          <input type="range" class="time-slider" id="timeSlider" min="0" max="100" value="100">
          <div class="time-ticks" id="timeTicks"></div>
        </div>
        <div class="time-info">
          <span id="startTime">é–‹å§‹: --:--:--.---</span>
          <span id="endTime">çµ‚äº†: --:--:--.---</span>
        </div>
      </div>
      
      <div class="canvas-container">
        <canvas id="trackCanvas" width="900" height="700"></canvas>
      </div>
      
      <div class="control-graph-panel">
        <h3>ğŸ® åˆ¶å¾¡å…¥åŠ›ã®æ™‚ç³»åˆ—å¤‰åŒ–</h3>
        <div class="control-graph-container" id="controlGraphContainer">
          <canvas class="control-graph-canvas" id="controlGraph"></canvas>
        </div>
        <div class="control-graph-controls">
          <div class="zoom-mode-selector">
            <button class="zoom-mode-btn active" id="zoomModeX" onclick="setControlGraphZoomMode('x')">Xè»¸</button>
            <button class="zoom-mode-btn" id="zoomModeY" onclick="setControlGraphZoomMode('y')">Yè»¸</button>
            <button class="zoom-mode-btn" id="zoomModeBoth" onclick="setControlGraphZoomMode('both')">ä¸¡è»¸</button>
          </div>
          <button class="control-graph-btn" onclick="zoomInControlGraph()">ğŸ”+ ã‚ºãƒ¼ãƒ ã‚¤ãƒ³</button>
          <button class="control-graph-btn" onclick="zoomOutControlGraph()">ğŸ”- ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ</button>
          <button class="control-graph-btn" onclick="resetControlGraphView()">ğŸ”„ å…¨ä½“è¡¨ç¤º</button>
        </div>
      </div>
      
      <div class="control-graph-panel">
        <h3>ğŸ“¡ è¶…éŸ³æ³¢ã‚»ãƒ³ã‚µå€¤ã®æ™‚ç³»åˆ—å¤‰åŒ–</h3>
        <div class="sensor-selection" id="sensorSelection">
          <label class="sensor-select-checkbox">
            <input type="checkbox" value="RrLH" checked onchange="drawSensorGraph()">
            <span style="color: #ff3296;">â— RrLH</span>
          </label>
          <label class="sensor-select-checkbox">
            <input type="checkbox" value="FrLH" checked onchange="drawSensorGraph()">
            <span style="color: #64c8ff;">â— FrLH</span>
          </label>
          <label class="sensor-select-checkbox">
            <input type="checkbox" value="Fr" checked onchange="drawSensorGraph()">
            <span style="color: #32ff32;">â— Fr</span>
          </label>
          <label class="sensor-select-checkbox">
            <input type="checkbox" value="FrRH" checked onchange="drawSensorGraph()">
            <span style="color: #ffc832;">â— FrRH</span>
          </label>
          <label class="sensor-select-checkbox">
            <input type="checkbox" value="RrRH" checked onchange="drawSensorGraph()">
            <span style="color: #ff6432;">â— RrRH</span>
          </label>
        </div>
        <div class="control-graph-container" id="sensorGraphContainer">
          <canvas class="control-graph-canvas" id="sensorGraph"></canvas>
        </div>
        <div class="control-graph-controls">
          <div class="zoom-mode-selector">
            <button class="zoom-mode-btn active" id="sensorZoomModeX" onclick="setSensorGraphZoomMode('x')">Xè»¸</button>
            <button class="zoom-mode-btn" id="sensorZoomModeY" onclick="setSensorGraphZoomMode('y')">Yè»¸</button>
            <button class="zoom-mode-btn" id="sensorZoomModeBoth" onclick="setSensorGraphZoomMode('both')">ä¸¡è»¸</button>
          </div>
          <button class="control-graph-btn" onclick="zoomInSensorGraph()">ğŸ”+ ã‚ºãƒ¼ãƒ ã‚¤ãƒ³</button>
          <button class="control-graph-btn" onclick="zoomOutSensorGraph()">ğŸ”- ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ</button>
          <button class="control-graph-btn" onclick="resetSensorGraphView()">ğŸ”„ å…¨ä½“è¡¨ç¤º</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
  <div class="table-sidebar" id="tableSidebar">
    <div class="table-resize-handle" id="tableResizeHandle"></div>
    <div class="table-header">
      <h3>ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«</h3>
      <button class="table-close-btn" onclick="toggleTableSidebar()">âœ•</button>
    </div>
    <div class="table-container" id="tableContainer">
      <table class="data-table" id="dataTable">
        <thead>
          <tr id="tableHeaderRow"></tr>
        </thead>
        <tbody id="tableBody"></tbody>
      </table>
    </div>
  </div>
</div>

<!-- ãƒ†ãƒ¼ãƒ–ãƒ«é–‹ããƒœã‚¿ãƒ³ï¼ˆbodyã®ç›´ä¸‹ï¼‰ -->
<button class="table-toggle-btn" id="tableToggleBtn" onclick="toggleTableSidebar()">â—€</button>

<script>
// ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
let csvData = [];
let headers = [];
let positions = [];
let currentTimeIndex = 0;
let isPlaying = false;
let playbackInterval = null;

// è»Šä¸¡ã¨ã‚³ãƒ¼ã‚¹ã®ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆmmå˜ä½ï¼‰
const VEHICLE_LENGTH = 250;  // mm
const VEHICLE_WIDTH = 150;   // mm
const COURSE_WIDTH = 1000;   // mm

// è¡¨ç¤ºè¨­å®š
let sensorDensity = 1;
let sensorPointSize = 4;
let sensorLineWidth = 1;
let pastPlotsCount = 5;
let futurePlotsCount = 5;  // æ–°è¦ï¼šæœªæ¥ãƒ—ãƒ­ãƒƒãƒˆè¡¨ç¤ºæ•°
let vehicleSizeMultiplier = 1.8;  // è»Šä¸¡ã‚µã‚¤ã‚ºå€ç‡ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§1.8å€ï¼‰

// è»Šä¸¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
let wheelbase = 0.15;  // ãƒ›ã‚¤ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹ï¼ˆmï¼‰ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 150mm

// ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
let speedScale = 1.0;     // é€Ÿåº¦ã‚¹ã‚±ãƒ¼ãƒ«ä¿‚æ•°
let steeringGain = 1.0;   // æ“èˆµã‚²ã‚¤ãƒ³
let timeScale = 1.0;      // æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«

// ã‚³ãƒ¼ã‚¹å¯¸æ³•ã®å‚ç…§ç·šã‚’è¡¨ç¤ºã™ã‚‹ãƒ•ãƒ©ã‚°
let showCourseRef = false;

// ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿
let medianFilterEnabled = false;
let filteredData = [];  // ãƒ•ã‚£ãƒ«ã‚¿æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿

// ãƒãƒƒãƒ—æ“ä½œè¨­å®š
let mapZoom = 1.0;
let mapOffsetX = 0;
let mapOffsetY = 0;
let mapRotation = 0;  // ãƒ©ã‚¸ã‚¢ãƒ³
let isDraggingMap = false;
let dragStartX = 0;
let dragStartY = 0;
let isDraggingVehicle = false;
let isDraggingCompass = false;
let compassX = 0;
let compassY = 0;

// ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼è¨­å®š
let isTableOpen = true;
let isResizingTable = false;
let tableStartX = 0;
let tableStartWidth = 0;

// åˆ¶å¾¡ã‚°ãƒ©ãƒ•æ“ä½œè¨­å®š
let controlGraphZoomX = 1.0;
let controlGraphZoomY = 1.0;
let controlGraphOffsetX = 0;
let controlGraphOffsetY = 0;
let isDraggingControlGraph = false;
let controlGraphDragStartX = 0;
let controlGraphDragStartY = 0;
let controlGraphZoomMode = 'x'; // 'x', 'y', 'both'

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•æ“ä½œè¨­å®š
let sensorGraph, sensorCtx;
let sensorGraphZoomX = 1.0;
let sensorGraphZoomY = 1.0;
let sensorGraphOffsetX = 0;
let sensorGraphOffsetY = 0;
let isDraggingSensorGraph = false;
let sensorGraphDragStartX = 0;
let sensorGraphDragStartY = 0;
let sensorGraphZoomMode = 'x'; // 'x', 'y', 'both'

// ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’ä¿å­˜
let canvasScaleInfo = {
  minX: 0,
  minY: 0,
  scale: 1,
  margin: 80,
  centerX: 0,
  centerY: 0
};

// ã‚»ãƒ³ã‚µãƒ¼å–ä»˜è§’åº¦ï¼ˆåº¦ï¼‰- è»Šä¸¡å‰æ–¹ã‚’0åº¦ã¨ã—ã¦å³å›ã‚Š
let sensorAngles = {
  'Fr': 0,
  'FrRH': 35,
  'RrRH': 90,
  'RrLH': 270,
  'FrLH': 325
};

// ã‚°ãƒ©ãƒ•ç¯„å›²è¨­å®š
let graphRanges = {
  speed: { xMin: 0, xMax: 100, yMin: 0, yMax: 5 },
  steering: { xMin: -100, xMax: 100, yMin: -45, yMax: 45 }
};

let speedMap = [
  {key: 0, value: 0}, {key: 10, value: 0.2}, {key: 20, value: 0.4},
  {key: 30, value: 1}, {key: 40, value: 1.5}, {key: 50, value: 2},
  {key: 60, value: 2.5}, {key: 70, value: 3}, {key: 80, value: 3.5},
  {key: 90, value: 4}, {key: 100, value: 5}
];
let steeringMap = [
  {key: -100, value: 45}, {key: -50, value: 22.5},
  {key: 0, value: 0}, {key: 50, value: -22.5}, {key: 100, value: -45}
];

// ã‚»ãƒ³ã‚µãƒ¼ã”ã¨ã®è‰²å®šç¾©
const sensorColors = {
  'RrLH': {r: 255, g: 50, b: 150},   // ãƒ”ãƒ³ã‚¯
  'FrLH': {r: 100, g: 200, b: 255},  // æ°´è‰²
  'Fr': {r: 50, g: 255, b: 50},      // ç·‘
  'FrRH': {r: 255, g: 200, b: 50},   // é»„è‰²
  'RrRH': {r: 255, g: 100, b: 50}    // ã‚ªãƒ¬ãƒ³ã‚¸
};

// ã‚°ãƒ©ãƒ•é–¢é€£å¤‰æ•°
let speedGraph, steeringGraph;
let speedCtx, steeringCtx;
let controlGraph, controlCtx;
let isDragging = false;
let dragPoint = null;
let dragGraph = null;

// åˆæœŸåŒ–
document.addEventListener('DOMContentLoaded', function() {
  initializeGraphs();
  initializeControlGraph();
  initializeSensorGraph();
  setupEventListeners();
  setupAccordion();
  setupTableSidebar();
  setupControlGraphEvents();
  setupSensorGraphEvents();
  drawAllGraphs();
});

// ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
function setupTableSidebar() {
  const resizeHandle = document.getElementById('tableResizeHandle');
  const tableSidebar = document.getElementById('tableSidebar');
  
  // ãƒªã‚µã‚¤ã‚ºãƒãƒ³ãƒ‰ãƒ«ã®ã‚¤ãƒ™ãƒ³ãƒˆ
  resizeHandle.addEventListener('mousedown', (e) => {
    isResizingTable = true;
    tableStartX = e.clientX;
    tableStartWidth = tableSidebar.offsetWidth;
    e.preventDefault();
  });
  
  document.addEventListener('mousemove', (e) => {
    if (isResizingTable) {
      const deltaX = tableStartX - e.clientX;
      const newWidth = Math.max(200, Math.min(800, tableStartWidth + deltaX));
      tableSidebar.style.width = newWidth + 'px';
    }
  });
  
  document.addEventListener('mouseup', () => {
    isResizingTable = false;
  });
}

// ãƒ†ãƒ¼ãƒ–ãƒ«ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ãƒˆã‚°ãƒ«
function toggleTableSidebar() {
  const tableSidebar = document.getElementById('tableSidebar');
  const toggleBtn = document.getElementById('tableToggleBtn');
  isTableOpen = !isTableOpen;
  
  if (isTableOpen) {
    tableSidebar.classList.remove('closed');
    document.body.classList.remove('table-closed');
    toggleBtn.textContent = 'â—€';
  } else {
    tableSidebar.classList.add('closed');
    document.body.classList.add('table-closed');
    toggleBtn.textContent = 'â—€';
  }
}

// ãƒ†ãƒ¼ãƒ–ãƒ«è¡¨ç¤ºã‚’æ›´æ–°
function updateTableDisplay() {
  if (!csvData.length) return;
  
  const headerRow = document.getElementById('tableHeaderRow');
  const tableBody = document.getElementById('tableBody');
  
  // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ä½œæˆ
  headerRow.innerHTML = '';
  headers.forEach(header => {
    const th = document.createElement('th');
    th.textContent = header;
    headerRow.appendChild(th);
  });
  
  // ãƒ‡ãƒ¼ã‚¿è¡Œã‚’ä½œæˆ
  tableBody.innerHTML = '';
  csvData.forEach((row, index) => {
    const tr = document.createElement('tr');
    tr.id = 'tableRow' + index;
    row.forEach(cell => {
      const td = document.createElement('td');
      td.textContent = cell;
      tr.appendChild(td);
    });
    tableBody.appendChild(tr);
  });
  
  // ç¾åœ¨ã®è¡Œã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
  scrollToCurrentRow();
}

// ç¾åœ¨ã®è¡Œã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
function scrollToCurrentRow() {
  if (!csvData.length) return;
  
  const tableContainer = document.getElementById('tableContainer');
  const currentRow = document.getElementById('tableRow' + currentTimeIndex);
  
  // ã™ã¹ã¦ã®è¡Œã‹ã‚‰ current-row ã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
  document.querySelectorAll('.data-table tr.current-row').forEach(row => {
    row.classList.remove('current-row');
  });
  
  if (currentRow) {
    currentRow.classList.add('current-row');
    
    // ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä¸­å¤®ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
    const containerHeight = tableContainer.clientHeight;
    const rowTop = currentRow.offsetTop;
    const rowHeight = currentRow.offsetHeight;
    const scrollTop = rowTop - (containerHeight / 2) + (rowHeight / 2);
    
    tableContainer.scrollTop = scrollTop;
  }
}

// ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³æ©Ÿèƒ½ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
function toggleAccordion(header) {
  const content = header.nextElementSibling;
  const icon = header.querySelector('.accordion-icon');
  
  content.classList.toggle('collapsed');
  
  if (content.classList.contains('collapsed')) {
    icon.textContent = 'â–¶';
  } else {
    icon.textContent = 'â–¼';
  }
}

function setupAccordion() {
  // control-groupã®ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³
  const controlHeaders = document.querySelectorAll('.control-group h3');
  controlHeaders.forEach(header => {
    header.addEventListener('click', function() {
      this.classList.toggle('collapsed');
      const content = this.nextElementSibling;
      content.classList.toggle('collapsed');
    });
  });
  
  // ãã®ä»–ã®ãƒ‘ãƒãƒ«ã®ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³
  const panelHeaders = document.querySelectorAll('.interactive-graph > h3, .map-quality-panel > h3, .stats-panel > h3');
  panelHeaders.forEach(header => {
    // h3ã®æ¬¡ã®è¦ç´ ä»¥é™ã‚’ã™ã¹ã¦panel-contentã§å›²ã‚€
    const panel = header.parentElement;
    const wrapper = document.createElement('div');
    wrapper.className = 'panel-content';
    
    // h3ã®æ¬¡ã®è¦ç´ ã‹ã‚‰å…¨ã¦ç§»å‹•
    let next = header.nextElementSibling;
    while (next) {
      const current = next;
      next = next.nextElementSibling;
      wrapper.appendChild(current);
    }
    
    panel.appendChild(wrapper);
    
    // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
    header.addEventListener('click', function() {
      this.classList.toggle('collapsed');
      wrapper.classList.toggle('collapsed');
    });
  });
}

// ã‚°ãƒ©ãƒ•ç¯„å›²æ›´æ–°
function updateGraphRange() {
  graphRanges.speed.xMin = parseFloat(document.getElementById('speedXMin').value);
  graphRanges.speed.xMax = parseFloat(document.getElementById('speedXMax').value);
  graphRanges.speed.yMin = parseFloat(document.getElementById('speedYMin').value);
  graphRanges.speed.yMax = parseFloat(document.getElementById('speedYMax').value);
  
  graphRanges.steering.xMin = parseFloat(document.getElementById('steeringXMin').value);
  graphRanges.steering.xMax = parseFloat(document.getElementById('steeringXMax').value);
  graphRanges.steering.yMin = parseFloat(document.getElementById('steeringYMin').value);
  graphRanges.steering.yMax = parseFloat(document.getElementById('steeringYMax').value);
  
  drawAllGraphs();
}

// ã‚»ãƒ³ã‚µãƒ¼è§’åº¦æ›´æ–°
function updateSensorAngle(sensor, value) {
  sensorAngles[sensor] = parseFloat(value);
  document.getElementById(`angle${sensor}`).value = value;
  document.querySelector(`#angle${sensor}`).previousElementSibling.value = value;
  
  if (positions.length > 0) {
    drawTrack();
  }
}

// è»Šä¸¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ›´æ–°
function updateWheelbase(value) {
  wheelbase = parseFloat(value) / 1000;  // mmã‹ã‚‰mã«å¤‰æ›
  const numberInput = document.getElementById('wheelbaseValue');
  const rangeInput = document.querySelector('input[type="range"][oninput*="updateWheelbase"]');
  if (numberInput) numberInput.value = value;
  if (rangeInput) rangeInput.value = value;
  console.log(`ãƒ›ã‚¤ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹æ›´æ–°: ${value}mm = ${wheelbase}m`);
}

function recalculatePositions() {
  if (csvData.length > 0) {
    calculatePositions();
    drawTrack();
  }
}

// ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°
function updateSpeedScale(value) {
  speedScale = parseFloat(value);
  const numberInput = document.getElementById('speedScaleValue');
  const rangeInput = document.querySelector('input[type="range"][oninput*="updateSpeedScale"]');
  if (numberInput) numberInput.value = value;
  if (rangeInput) rangeInput.value = value;
  console.log(`é€Ÿåº¦ã‚¹ã‚±ãƒ¼ãƒ«æ›´æ–°: ${speedScale}`);
}

function updateSteeringGain(value) {
  steeringGain = parseFloat(value);
  const numberInput = document.getElementById('steeringGainValue');
  const rangeInput = document.querySelector('input[type="range"][oninput*="updateSteeringGain"]');
  if (numberInput) numberInput.value = value;
  if (rangeInput) rangeInput.value = value;
  console.log(`æ“èˆµã‚²ã‚¤ãƒ³æ›´æ–°: ${steeringGain}`);
}

function updateTimeScale(value) {
  timeScale = parseFloat(value);
  const numberInput = document.getElementById('timeScaleValue');
  const rangeInput = document.querySelector('input[type="range"][oninput*="updateTimeScale"]');
  if (numberInput) numberInput.value = value;
  if (rangeInput) rangeInput.value = value;
  console.log(`æ™‚é–“ã‚¹ã‚±ãƒ¼ãƒ«æ›´æ–°: ${timeScale}`);
}

function resetCalibration() {
  speedScale = 1.0;
  steeringGain = 1.0;
  timeScale = 1.0;
  
  document.getElementById('speedScaleValue').value = 1.0;
  document.getElementById('steeringGainValue').value = 1.0;
  document.getElementById('timeScaleValue').value = 1.0;
  
  document.querySelectorAll('input[type="range"][oninput*="updateSpeedScale"]')[0].value = 1.0;
  document.querySelectorAll('input[type="range"][oninput*="updateSteeringGain"]')[0].value = 1.0;
  document.querySelectorAll('input[type="range"][oninput*="updateTimeScale"]')[0].value = 1.0;
  
  console.log('ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
  
  if (csvData.length > 0) {
    recalculatePositions();
  }
}

function showCourseReference() {
  showCourseRef = !showCourseRef;
  const btn = event.target;
  if (showCourseRef) {
    btn.textContent = 'âœ… å‚ç…§ç·šã‚’éè¡¨ç¤º';
    btn.style.background = 'linear-gradient(135deg, #8ac926, #6ba01e)';
  } else {
    btn.textContent = 'ğŸ“Š ã‚³ãƒ¼ã‚¹å‚ç…§ç·šã‚’è¡¨ç¤º';
    btn.style.background = '';
  }
  drawTrack();
}

function resetSpeedMap() {
  speedMap = [
    {key: 0, value: 0}, {key: 10, value: 0.2}, {key: 20, value: 0.4},
    {key: 30, value: 1}, {key: 40, value: 1.5}, {key: 50, value: 2},
    {key: 60, value: 2.5}, {key: 70, value: 3}, {key: 80, value: 3.5},
    {key: 90, value: 4}, {key: 100, value: 5}
  ];
  drawAllGraphs();
  if (csvData.length > 0) {
    recalculatePositions();
  }
}

function resetSteeringMap() {
  steeringMap = [
    {key: -100, value: 45}, {key: -50, value: 22.5},
    {key: 0, value: 0}, {key: 50, value: -22.5}, {key: 100, value: -45}
  ];
  drawAllGraphs();
  if (csvData.length > 0) {
    recalculatePositions();
  }
}

// ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿é–¢æ•°
function median(arr) {
  if (arr.length === 0) return 0;
  const sorted = [...arr].sort((a, b) => a - b);
  const mid = Math.floor(sorted.length / 2);
  return sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
}

function applyMedianFilter() {
  if (!csvData.length) return;
  
  const windowSize = 5; // 5ç‚¹ã®ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿
  filteredData = csvData.map((row, i) => {
    const newRow = [...row];
    
    // å„ã‚»ãƒ³ã‚µãƒ¼åˆ—ã«ãƒ•ã‚£ãƒ«ã‚¿ã‚’é©ç”¨
    headers.forEach((header, idx) => {
      if (header === 'RrLH' || header === 'FrLH' || header === 'Fr' || header === 'FrRH' || header === 'RrRH') {
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’åé›†
        const window = [];
        for (let j = Math.max(0, i - Math.floor(windowSize / 2)); j <= Math.min(csvData.length - 1, i + Math.floor(windowSize / 2)); j++) {
          const val = parseFloat(csvData[j][idx]);
          if (!isNaN(val)) {
            window.push(val);
          }
        }
        // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ã‚’è¨ˆç®—
        newRow[idx] = median(window);
      }
    });
    
    return newRow;
  });
  
  console.log(`ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿é©ç”¨: ${filteredData.length}ç‚¹å‡¦ç†`);
}

function toggleMedianFilter() {
  medianFilterEnabled = !medianFilterEnabled;
  
  if (medianFilterEnabled && filteredData.length === 0) {
    applyMedianFilter();
  }
  
  console.log(`ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿: ${medianFilterEnabled ? 'ON' : 'OFF'}`);
  
  // å†æç”»
  drawTrack();
  drawControlGraph();
  drawSensorGraph();
}

// å¯†åº¦ã¨ã‚µã‚¤ã‚ºèª¿æ•´
function updateDensity(value) {
  sensorDensity = parseInt(value);
  document.getElementById('densityValue').textContent = value;
  drawTrack();
}

function updatePointSize(value) {
  sensorPointSize = parseInt(value);
  document.getElementById('sizeValue').textContent = value + 'px';
  // ãƒ—ãƒ­ãƒƒãƒˆã‚µã‚¤ã‚ºã«å¿œã˜ã¦è»Šä¸¡ã‚µã‚¤ã‚ºã‚‚èª¿æ•´ï¼ˆåŸºæœ¬1.8å€ã€ãƒ—ãƒ­ãƒƒãƒˆã‚µã‚¤ã‚º4ã‚’åŸºæº–ã«æ¯”ä¾‹ï¼‰
  vehicleSizeMultiplier = 1.8 * (sensorPointSize / 4);
  drawTrack();
}

function updateLineWidth(value) {
  sensorLineWidth = parseFloat(value);
  document.getElementById('lineWidthValue').textContent = value + 'px';
  drawTrack();
}

function updatePastPlots(value) {
  pastPlotsCount = parseInt(value);
  document.getElementById('pastPlotsValue').textContent = value;
  drawTrack();
}

function updateFuturePlots(value) {
  futurePlotsCount = parseInt(value);
  document.getElementById('futurePlotsValue').textContent = value + (value === 0 ? ' (å…¨åŒºé–“)' : '');
  drawTrack();
}

// ãƒãƒƒãƒ—æ“ä½œé–¢æ•°
function updateZoom(value) {
  mapZoom = parseFloat(value);
  document.getElementById('zoomValue').textContent = value + 'x';
  drawTrack();
}

function updateRotation(value) {
  mapRotation = parseFloat(value) * Math.PI / 180;
  document.getElementById('rotationValue').textContent = value + 'Â°';
  drawTrack();
}

function resetView() {
  mapZoom = 1.0;
  mapOffsetX = 0;
  mapOffsetY = 0;
  mapRotation = 0;
  document.getElementById('zoomSlider').value = 1.0;
  document.getElementById('zoomValue').textContent = '1.0x';
  document.getElementById('rotationSlider').value = 0;
  document.getElementById('rotationValue').textContent = '0Â°';
  drawTrack();
}

function resetRotation() {
  mapRotation = 0;
  document.getElementById('rotationSlider').value = 0;
  document.getElementById('rotationValue').textContent = '0Â°';
  drawTrack();
}

// åˆ¶å¾¡ã‚°ãƒ©ãƒ•åˆæœŸåŒ–
function initializeControlGraph() {
  controlGraph = document.getElementById('controlGraph');
  if (controlGraph) {
    controlCtx = controlGraph.getContext('2d');
    const container = controlGraph.parentElement;
    const rect = container.getBoundingClientRect();
    controlGraph.width = rect.width;
    controlGraph.height = 150;
  }
}

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•åˆæœŸåŒ–
function initializeSensorGraph() {
  sensorGraph = document.getElementById('sensorGraph');
  if (sensorGraph) {
    sensorCtx = sensorGraph.getContext('2d');
    const container = sensorGraph.parentElement;
    const rect = container.getBoundingClientRect();
    sensorGraph.width = rect.width;
    sensorGraph.height = 200;
  }
}

// åˆ¶å¾¡ã‚°ãƒ©ãƒ•ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
function setupControlGraphEvents() {
  const container = document.getElementById('controlGraphContainer');
  if (!container) return;
  
  // ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³
  container.addEventListener('mousedown', (e) => {
    isDraggingControlGraph = true;
    controlGraphDragStartX = e.clientX;
    controlGraphDragStartY = e.clientY;
    container.classList.add('dragging');
  });
  
  // ãƒã‚¦ã‚¹ç§»å‹•
  container.addEventListener('mousemove', (e) => {
    if (!isDraggingControlGraph) return;
    
    const deltaX = e.clientX - controlGraphDragStartX;
    const deltaY = e.clientY - controlGraphDragStartY;
    
    controlGraphOffsetX += deltaX;
    controlGraphOffsetY += deltaY;
    
    controlGraphDragStartX = e.clientX;
    controlGraphDragStartY = e.clientY;
    
    drawControlGraph();
  });
  
  // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—
  const handleMouseUp = () => {
    isDraggingControlGraph = false;
    container.classList.remove('dragging');
  };
  
  container.addEventListener('mouseup', handleMouseUp);
  container.addEventListener('mouseleave', handleMouseUp);
  
  // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«
  container.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = -Math.sign(e.deltaY) * 0.1;
    
    if (controlGraphZoomMode === 'x') {
      controlGraphZoomX = Math.max(0.5, Math.min(10, controlGraphZoomX + delta));
    } else if (controlGraphZoomMode === 'y') {
      controlGraphZoomY = Math.max(0.5, Math.min(10, controlGraphZoomY + delta));
    } else {
      controlGraphZoomX = Math.max(0.5, Math.min(10, controlGraphZoomX + delta));
      controlGraphZoomY = Math.max(0.5, Math.min(10, controlGraphZoomY + delta));
    }
    drawControlGraph();
  });
}

// ã‚ºãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
function setControlGraphZoomMode(mode) {
  controlGraphZoomMode = mode;
  
  // ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’æ›´æ–°
  document.querySelectorAll('.zoom-mode-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  
  if (mode === 'x') {
    document.getElementById('zoomModeX').classList.add('active');
  } else if (mode === 'y') {
    document.getElementById('zoomModeY').classList.add('active');
  } else {
    document.getElementById('zoomModeBoth').classList.add('active');
  }
}

// åˆ¶å¾¡ã‚°ãƒ©ãƒ•ã®ã‚ºãƒ¼ãƒ ãƒ»ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½
function zoomInControlGraph() {
  const delta = 0.2;
  if (controlGraphZoomMode === 'x') {
    controlGraphZoomX = Math.min(10, controlGraphZoomX + delta);
  } else if (controlGraphZoomMode === 'y') {
    controlGraphZoomY = Math.min(10, controlGraphZoomY + delta);
  } else {
    controlGraphZoomX = Math.min(10, controlGraphZoomX + delta);
    controlGraphZoomY = Math.min(10, controlGraphZoomY + delta);
  }
  drawControlGraph();
}

function zoomOutControlGraph() {
  const delta = 0.2;
  if (controlGraphZoomMode === 'x') {
    controlGraphZoomX = Math.max(0.5, controlGraphZoomX - delta);
  } else if (controlGraphZoomMode === 'y') {
    controlGraphZoomY = Math.max(0.5, controlGraphZoomY - delta);
  } else {
    controlGraphZoomX = Math.max(0.5, controlGraphZoomX - delta);
    controlGraphZoomY = Math.max(0.5, controlGraphZoomY - delta);
  }
  drawControlGraph();
}

function resetControlGraphView() {
  controlGraphZoomX = 1.0;
  controlGraphZoomY = 1.0;
  controlGraphOffsetX = 0;
  controlGraphOffsetY = 0;
  drawControlGraph();
}

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•ã®ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
function setupSensorGraphEvents() {
  const container = document.getElementById('sensorGraphContainer');
  if (!container) return;
  
  // ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³
  container.addEventListener('mousedown', (e) => {
    isDraggingSensorGraph = true;
    sensorGraphDragStartX = e.clientX;
    sensorGraphDragStartY = e.clientY;
    container.classList.add('dragging');
  });
  
  // ãƒã‚¦ã‚¹ç§»å‹•
  container.addEventListener('mousemove', (e) => {
    if (!isDraggingSensorGraph) return;
    
    const deltaX = e.clientX - sensorGraphDragStartX;
    const deltaY = e.clientY - sensorGraphDragStartY;
    
    sensorGraphOffsetX += deltaX;
    sensorGraphOffsetY += deltaY;
    
    sensorGraphDragStartX = e.clientX;
    sensorGraphDragStartY = e.clientY;
    
    drawSensorGraph();
  });
  
  // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—
  const handleMouseUp = () => {
    if (isDraggingSensorGraph) {
      isDraggingSensorGraph = false;
      container.classList.remove('dragging');
    }
  };
  
  container.addEventListener('mouseup', handleMouseUp);
  container.addEventListener('mouseleave', handleMouseUp);
  
  // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«
  container.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = -Math.sign(e.deltaY) * 0.1;
    
    if (sensorGraphZoomMode === 'x') {
      sensorGraphZoomX = Math.max(0.5, Math.min(10, sensorGraphZoomX + delta));
    } else if (sensorGraphZoomMode === 'y') {
      sensorGraphZoomY = Math.max(0.5, Math.min(10, sensorGraphZoomY + delta));
    } else {
      sensorGraphZoomX = Math.max(0.5, Math.min(10, sensorGraphZoomX + delta));
      sensorGraphZoomY = Math.max(0.5, Math.min(10, sensorGraphZoomY + delta));
    }
    drawSensorGraph();
  });
}

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•ã®ã‚ºãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
function setSensorGraphZoomMode(mode) {
  sensorGraphZoomMode = mode;
  
  document.querySelectorAll('#sensorZoomModeX, #sensorZoomModeY, #sensorZoomModeBoth').forEach(btn => {
    btn.classList.remove('active');
  });
  
  if (mode === 'x') {
    document.getElementById('sensorZoomModeX').classList.add('active');
  } else if (mode === 'y') {
    document.getElementById('sensorZoomModeY').classList.add('active');
  } else {
    document.getElementById('sensorZoomModeBoth').classList.add('active');
  }
}

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•ã®ã‚ºãƒ¼ãƒ ãƒ»ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½
function zoomInSensorGraph() {
  const delta = 0.2;
  if (sensorGraphZoomMode === 'x') {
    sensorGraphZoomX = Math.min(10, sensorGraphZoomX + delta);
  } else if (sensorGraphZoomMode === 'y') {
    sensorGraphZoomY = Math.min(10, sensorGraphZoomY + delta);
  } else {
    sensorGraphZoomX = Math.min(10, sensorGraphZoomX + delta);
    sensorGraphZoomY = Math.min(10, sensorGraphZoomY + delta);
  }
  drawSensorGraph();
}

function zoomOutSensorGraph() {
  const delta = 0.2;
  if (sensorGraphZoomMode === 'x') {
    sensorGraphZoomX = Math.max(0.5, sensorGraphZoomX - delta);
  } else if (sensorGraphZoomMode === 'y') {
    sensorGraphZoomY = Math.max(0.5, sensorGraphZoomY - delta);
  } else {
    sensorGraphZoomX = Math.max(0.5, sensorGraphZoomX - delta);
    sensorGraphZoomY = Math.max(0.5, sensorGraphZoomY - delta);
  }
  drawSensorGraph();
}

function resetSensorGraphView() {
  sensorGraphZoomX = 1.0;
  sensorGraphZoomY = 1.0;
  sensorGraphOffsetX = 0;
  sensorGraphOffsetY = 0;
  drawSensorGraph();
}

// ã‚°ãƒ©ãƒ•åˆæœŸåŒ–
function initializeGraphs() {
  speedGraph = document.getElementById('speedGraph');
  steeringGraph = document.getElementById('steeringGraph');
  speedCtx = speedGraph.getContext('2d');
  steeringCtx = steeringGraph.getContext('2d');
  
  const container = document.getElementById('speedGraphContainer');
  const rect = container.getBoundingClientRect();
  speedGraph.width = rect.width;
  speedGraph.height = 240;
  steeringGraph.width = rect.width;
  steeringGraph.height = 240;
  
  setupGraphEvents();
}

// ã‚°ãƒ©ãƒ•ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
function setupGraphEvents() {
  speedGraph.addEventListener('mousedown', (e) => handleGraphMouseDown(e, 'speed'));
  speedGraph.addEventListener('mousemove', (e) => handleGraphMouseMove(e, 'speed'));
  speedGraph.addEventListener('mouseup', (e) => handleGraphMouseUp(e, 'speed'));
  speedGraph.addEventListener('dblclick', (e) => handleGraphDoubleClick(e, 'speed'));
  
  steeringGraph.addEventListener('mousedown', (e) => handleGraphMouseDown(e, 'steering'));
  steeringGraph.addEventListener('mousemove', (e) => handleGraphMouseMove(e, 'steering'));
  steeringGraph.addEventListener('mouseup', (e) => handleGraphMouseUp(e, 'steering'));
  steeringGraph.addEventListener('dblclick', (e) => handleGraphDoubleClick(e, 'steering'));
}

// ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
function setupEventListeners() {
  document.getElementById('csvFile').addEventListener('change', handleCSVUpload);
  document.querySelectorAll('.sensorCheckbox').forEach(cb => {
    cb.addEventListener('change', drawTrack);
  });
  
  const timeSlider = document.getElementById('timeSlider');
  timeSlider.addEventListener('input', function() {
    currentTimeIndex = parseInt(this.value);
    updateTimeDisplay();
    drawTrack();
  });
  
  // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
  const trackCanvas = document.getElementById('trackCanvas');
  trackCanvas.addEventListener('mousedown', handleCanvasMouseDown);
  trackCanvas.addEventListener('mousemove', handleCanvasMouseMove);
  trackCanvas.addEventListener('mouseup', handleCanvasMouseUp);
  trackCanvas.addEventListener('wheel', handleCanvasWheel);
  trackCanvas.addEventListener('mouseleave', handleCanvasMouseUp);
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³å‡¦ç†
function handleCanvasMouseDown(e) {
  if (!positions.length) return;
  
  const canvas = e.target;
  const rect = canvas.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const clickY = e.clientY - rect.top;
  
  // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ç¢ºèª
  if (canvas.medianBtnBounds) {
    const btn = canvas.medianBtnBounds;
    if (clickX >= btn.x && clickX <= btn.x + btn.width &&
        clickY >= btn.y && clickY <= btn.y + btn.height) {
      toggleMedianFilter();
      return;
    }
  }
  
  // ã‚³ãƒ³ãƒ‘ã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ç¢ºèª
  const compassRadius = 40;
  const compassCenterX = canvas.width - 80;
  const compassCenterY = 80;
  const distToCompass = Math.sqrt((clickX - compassCenterX) ** 2 + (clickY - compassCenterY) ** 2);
  
  if (distToCompass <= compassRadius) {
    isDraggingCompass = true;
    compassX = compassCenterX;
    compassY = compassCenterY;
    canvas.classList.add('dragging');
    return;
  }
  
  // å†ç”Ÿä¸­ã¯è»Šä¸¡ãƒ‰ãƒ©ãƒƒã‚°ã®ã¿ç„¡åŠ¹ã€ãƒ‘ãƒ³æ“ä½œã¯æœ‰åŠ¹
  if (isPlaying) {
    // å†ç”Ÿä¸­ã¯ãƒãƒƒãƒ—ãƒ‰ãƒ©ãƒƒã‚°ã®ã¿è¨±å¯
    isDraggingMap = true;
    dragStartX = clickX;
    dragStartY = clickY;
    canvas.classList.add('dragging');
    return;
  }
  
  // è‡ªè»Šãƒ—ãƒ­ãƒƒãƒˆã¾ãŸã¯è»Œè·¡ãƒ©ã‚¤ãƒ³è¿‘ãã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ç¢ºèª
  const clickThreshold = 20; // ã‚¯ãƒªãƒƒã‚¯åˆ¤å®šã®é–¾å€¤ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
  let nearVehicleOrTrack = false;
  
  // ç¾åœ¨ã®è»Šä¸¡ä½ç½®ã¨ã®è·é›¢ã‚’ãƒã‚§ãƒƒã‚¯
  if (currentTimeIndex < positions.length) {
    const currentPos = positions[currentTimeIndex];
    const transformedPos = applyTransform(currentPos.x, currentPos.y);
    const distToVehicle = Math.sqrt((clickX - transformedPos.x) ** 2 + (clickY - transformedPos.y) ** 2);
    
    if (distToVehicle <= clickThreshold * 2) {
      nearVehicleOrTrack = true;
    }
  }
  
  // è»Œè·¡ãƒ©ã‚¤ãƒ³ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
  if (!nearVehicleOrTrack) {
    for (let i = 0; i < Math.min(currentTimeIndex, positions.length - 1); i++) {
      const p1 = positions[i];
      const p2 = positions[i + 1];
      const tp1 = applyTransform(p1.x, p1.y);
      const tp2 = applyTransform(p2.x, p2.y);
      
      const distToLine = pointToLineDistance(clickX, clickY, tp1.x, tp1.y, tp2.x, tp2.y);
      
      if (distToLine <= clickThreshold) {
        nearVehicleOrTrack = true;
        break;
      }
    }
  }
  
  if (nearVehicleOrTrack) {
    // è‡ªè»Šãƒ—ãƒ­ãƒƒãƒˆã¾ãŸã¯ãƒ©ã‚¤ãƒ³ä¸Šï¼šè»Šä¸¡ãƒ‰ãƒ©ãƒƒã‚°
    isDraggingVehicle = true;
    updateVehiclePositionFromMouse(clickX, clickY);
  } else {
    // ãã‚Œä»¥å¤–ï¼šãƒãƒƒãƒ—ãƒ‰ãƒ©ãƒƒã‚°
    isDraggingMap = true;
    dragStartX = clickX;
    dragStartY = clickY;
    canvas.classList.add('dragging');
  }
}

// ç‚¹ã‹ã‚‰ç·šåˆ†ã¸ã®æœ€çŸ­è·é›¢ã‚’è¨ˆç®—
function pointToLineDistance(px, py, x1, y1, x2, y2) {
  const A = px - x1;
  const B = py - y1;
  const C = x2 - x1;
  const D = y2 - y1;
  
  const dot = A * C + B * D;
  const lenSq = C * C + D * D;
  let param = -1;
  
  if (lenSq !== 0) {
    param = dot / lenSq;
  }
  
  let xx, yy;
  
  if (param < 0) {
    xx = x1;
    yy = y1;
  } else if (param > 1) {
    xx = x2;
    yy = y2;
  } else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }
  
  const dx = px - xx;
  const dy = py - yy;
  return Math.sqrt(dx * dx + dy * dy);
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒã‚¦ã‚¹ç§»å‹•å‡¦ç†
function handleCanvasMouseMove(e) {
  if (!positions.length && !isDraggingCompass) return;
  
  const canvas = e.target;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  if (isDraggingCompass) {
    // ã‚³ãƒ³ãƒ‘ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ï¼šãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰ã®è§’åº¦ã‚’è¨ˆç®—
    const dx = mouseX - compassX;
    const dy = mouseY - compassY;
    const angle = Math.atan2(dy, dx);
    // atan2ã¯-Ï€ã‹ã‚‰Ï€ãªã®ã§ã€0ã‹ã‚‰2Ï€ã«å¤‰æ›ã—ã¦ã‹ã‚‰åº¦ã«å¤‰æ›
    let degrees = ((angle * 180 / Math.PI) + 90 + 360) % 360;
    mapRotation = degrees * Math.PI / 180;
    document.getElementById('rotationSlider').value = degrees;
    document.getElementById('rotationValue').textContent = degrees.toFixed(0) + 'Â°';
    drawTrack();
  } else if (isDraggingMap) {
    const deltaX = mouseX - dragStartX;
    const deltaY = mouseY - dragStartY;
    mapOffsetX += deltaX;
    mapOffsetY += deltaY;
    dragStartX = mouseX;
    dragStartY = mouseY;
    drawTrack();
  } else if (isDraggingVehicle && !isPlaying) {
    updateVehiclePositionFromMouse(mouseX, mouseY);
  }
}

// ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—å‡¦ç†
function handleCanvasMouseUp(e) {
  const canvas = document.getElementById('trackCanvas');
  isDraggingMap = false;
  isDraggingVehicle = false;
  isDraggingCompass = false;
  canvas.classList.remove('dragging');
}

// ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ 
function handleCanvasWheel(e) {
  e.preventDefault();
  const delta = -Math.sign(e.deltaY) * 0.1;
  mapZoom = Math.max(0.5, Math.min(5, mapZoom + delta));
  document.getElementById('zoomSlider').value = mapZoom;
  document.getElementById('zoomValue').textContent = mapZoom.toFixed(1) + 'x';
  drawTrack();
}

// ãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰æœ€ã‚‚è¿‘ã„è»Šä¸¡ä½ç½®ã‚’æ›´æ–°ï¼ˆã‚ºãƒ¼ãƒ å¯¾å¿œç‰ˆï¼‰
function updateVehiclePositionFromMouse(mouseX, mouseY) {
  if (!positions.length) return;
  
  let minDistance = Infinity;
  let nearestIndex = 0;
  
  // ã™ã¹ã¦ã®ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã®ã¯é‡ã„ã®ã§ã€ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã—ã¦é«˜é€ŸåŒ–
  const step = Math.max(1, Math.floor(positions.length / 500));
    
  for (let i = 0; i < positions.length; i += step) {
    const transformedPos = applyTransform(positions[i].x, positions[i].y);
    const distance = Math.sqrt((mouseX - transformedPos.x) ** 2 + (mouseY - transformedPos.y) ** 2);
    
    if (distance < minDistance) {
      minDistance = distance;
      nearestIndex = i;
    }
  }
  
  // å‘¨è¾ºã‚’ç´°ã‹ããƒã‚§ãƒƒã‚¯
  const searchRange = Math.min(50, positions.length);
  const startIdx = Math.max(0, nearestIndex - searchRange);
  const endIdx = Math.min(positions.length - 1, nearestIndex + searchRange);
  
  for (let i = startIdx; i <= endIdx; i++) {
    const transformedPos = applyTransform(positions[i].x, positions[i].y);
    const distance = Math.sqrt((mouseX - transformedPos.x) ** 2 + (mouseY - transformedPos.y) ** 2);
    
    if (distance < minDistance) {
      minDistance = distance;
      nearestIndex = i;
    }
  }
  
  currentTimeIndex = nearestIndex;
  document.getElementById('timeSlider').value = currentTimeIndex;
  updateTimeDisplay();
  drawTrack();
}

// åº§æ¨™å¤‰æ›ï¼ˆã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³ãƒ»å›è»¢ã‚’é©ç”¨ï¼‰
function applyTransform(x, y) {
  const { minX, minY, scale, margin, centerX, centerY } = canvasScaleInfo;
  
  // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‹ã‚‰ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã¸ã®åŸºæœ¬å¤‰æ›
  let cx = margin + (x - minX) * scale;
  let cy = margin + (y - minY) * scale;
  
  // ä¸­å¿ƒã‚’åŸç‚¹ã¨ã™ã‚‹åº§æ¨™ç³»ã«å¤‰æ›
  cx -= centerX;
  cy -= centerY;
  
  // å›è»¢ã‚’é©ç”¨
  const rotatedX = cx * Math.cos(mapRotation) - cy * Math.sin(mapRotation);
  const rotatedY = cx * Math.sin(mapRotation) + cy * Math.cos(mapRotation);
  
  // ã‚ºãƒ¼ãƒ ã‚’é©ç”¨
  const zoomedX = rotatedX * mapZoom;
  const zoomedY = rotatedY * mapZoom;
  
  // ãƒ‘ãƒ³ã¨ã‚»ãƒ³ã‚¿ãƒ¼ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨
  const finalX = zoomedX + centerX + mapOffsetX;
  const finalY = zoomedY + centerY + mapOffsetY;
  
  return { x: finalX, y: finalY };
}

// CSVã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†
function handleCSVUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(event) {
    const text = event.target.result;
    const lines = text.trim().split(/\r?\n/);
    headers = lines[0].split(',');
    csvData = lines.slice(1).map(line => line.split(','));
    
    // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
    filteredData = [];
    if (medianFilterEnabled) {
      applyMedianFilter();
    }
    
    calculatePositions();
    setupTimeSlider();
    updateStats();
    updateTableDisplay();
    drawControlGraph();
    drawSensorGraph();
    drawTrack();
  };
  reader.readAsText(file);
}

// ä½ç½®è¨ˆç®—
function calculatePositions() {
  positions = [];
  let x = 0, y = 0, theta = 0;
  const scale = 1;
  
  csvData.forEach((row, i) => {
    const thr = parseFloat(row[headers.indexOf('Thr')]);
    const str = parseFloat(row[headers.indexOf('Str')]);
    const dt = (i > 0 ? (parseFloat(row[0]) - parseFloat(csvData[i-1][0])) : 0.04) * timeScale;
    
    // é€Ÿåº¦ã¨ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è§’åº¦ã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä¿‚æ•°ã‚’é©ç”¨ï¼‰
    const speed = interpolateMap(speedMap, thr) * 1000 * speedScale;
    const angle = interpolateMap(steeringMap, str) * Math.PI/180 * steeringGain;

    // è§’åº¦ã‚’æ›´æ–°
    theta += angle * dt;
    
    // ä½ç½®ã‚’æ›´æ–°
    x += speed * dt * scale * Math.cos(theta);
    y += speed * dt * scale * Math.sin(theta);
    
    // ãƒ‡ãƒãƒƒã‚°: æœ€åˆã®æ•°è¡Œã‚’å‡ºåŠ›
    if (i < 5) {
      console.log(`[${i}] thr=${thr}, str=${str}, speed=${speed.toFixed(1)}mm/s, angle=${(angle*180/Math.PI).toFixed(1)}Â°, dt=${dt.toFixed(4)}s, theta=${theta.toFixed(3)}rad, x=${x.toFixed(1)}mm, y=${y.toFixed(1)}mm`);
    }

    positions.push({x, y, theta, row});
  });
  
  console.log(`ä½ç½®è¨ˆç®—å®Œäº†: ${positions.length}ç‚¹, æœ€çµ‚ä½ç½® x=${x.toFixed(1)}mm, y=${y.toFixed(1)}mm`);
  console.log(`ã‚­ãƒ£ãƒªãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³: é€Ÿåº¦=${speedScale}x, æ“èˆµ=${steeringGain}x, æ™‚é–“=${timeScale}x`);
}

// UNIXæ™‚åˆ»ã‚’æ™‚:åˆ†:ç§’.ãƒŸãƒªç§’å½¢å¼ã«å¤‰æ›
function formatUnixTime(unixTime) {
  const date = new Date(unixTime * 1000);
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');
  const milliseconds = String(date.getMilliseconds()).padStart(3, '0');
  return `${hours}:${minutes}:${seconds}.${milliseconds}`;
}

// ã‚¿ã‚¤ãƒ ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼è¨­å®š
function setupTimeSlider() {
  const timeSlider = document.getElementById('timeSlider');
  timeSlider.max = csvData.length - 1;
  timeSlider.value = csvData.length - 1;
  currentTimeIndex = csvData.length - 1;
  
  if (csvData.length > 0) {
    const startUnixTime = parseFloat(csvData[0][0]);
    const endUnixTime = parseFloat(csvData[csvData.length - 1][0]);
    
    const startTime = formatUnixTime(startUnixTime);
    const endTime = formatUnixTime(endUnixTime);
    
    document.getElementById('startTime').textContent = `é–‹å§‹: ${startTime}`;
    document.getElementById('endTime').textContent = `çµ‚äº†: ${endTime}`;
    
    generateTimeTicks();
  }
  
  updateTimeDisplay();
}

// æ™‚åˆ»ãƒ†ã‚£ãƒƒã‚¯ã‚’ç”Ÿæˆ
function generateTimeTicks() {
  const ticksContainer = document.getElementById('timeTicks');
  ticksContainer.innerHTML = '';
  
  const numTicks = 11;
  
  for (let i = 0; i < numTicks; i++) {
    const percentage = i / (numTicks - 1);
    const dataIndex = Math.floor(percentage * (csvData.length - 1));
    const unixTime = parseFloat(csvData[dataIndex][0]);
    const formattedTime = formatUnixTime(unixTime);
    
    const tickDiv = document.createElement('div');
    tickDiv.className = 'time-tick';
    
    const tickLine = document.createElement('div');
    tickLine.className = 'time-tick-line';
    
    const tickLabel = document.createElement('div');
    tickLabel.className = 'time-tick-label';
    tickLabel.textContent = formattedTime;
    
    tickDiv.appendChild(tickLine);
    tickDiv.appendChild(tickLabel);
    ticksContainer.appendChild(tickDiv);
  }
}

// æ™‚åˆ»è¡¨ç¤ºæ›´æ–°
function updateTimeDisplay() {
  if (csvData.length > 0 && currentTimeIndex < csvData.length) {
    const unixTime = parseFloat(csvData[currentTimeIndex][0]);
    const formattedTime = formatUnixTime(unixTime);
    document.getElementById('timeDisplay').textContent = `æ™‚åˆ»: ${formattedTime}`;
    scrollToCurrentRow();
    drawControlGraph();
    drawSensorGraph();
  }
}

// å†ç”Ÿåˆ¶å¾¡
function togglePlayback() {
  isPlaying = !isPlaying;
  const playBtn = document.getElementById('playBtn');
  
  if (isPlaying) {
    playBtn.textContent = 'â¸ ä¸€æ™‚åœæ­¢';
    playbackInterval = setInterval(() => {
      currentTimeIndex++;
      if (currentTimeIndex >= csvData.length - 1) {
        currentTimeIndex = csvData.length - 1;
        togglePlayback();
        return;
      }
      document.getElementById('timeSlider').value = currentTimeIndex;
      updateTimeDisplay();
      drawTrack();
    }, 50);
  } else {
    playBtn.textContent = 'â–¶ å†ç”Ÿ';
    if (playbackInterval) {
      clearInterval(playbackInterval);
      playbackInterval = null;
    }
  }
}

function resetPlayback() {
  currentTimeIndex = 0;
  document.getElementById('timeSlider').value = 0;
  updateTimeDisplay();
  drawTrack();
}

function jumpToEnd() {
  currentTimeIndex = csvData.length - 1;
  document.getElementById('timeSlider').value = currentTimeIndex;
  updateTimeDisplay();
  drawTrack();
}

// ãƒã‚¦ã‚¹å‡¦ç†
function handleGraphMouseDown(e, graphType) {
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const point = findNearestPoint(x, y, graphType);
  if (point && getDistance(x, y, point.canvasX, point.canvasY) < 15) {
    isDragging = true;
    dragPoint = point;
    dragGraph = graphType;
    e.target.style.cursor = 'grabbing';
  }
}

function handleGraphMouseMove(e, graphType) {
  if (!isDragging || dragGraph !== graphType) return;
  
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const dataValue = canvasToData(x, y, graphType);
  if (dataValue) {
    dragPoint.key = dataValue.x;
    dragPoint.value = dataValue.y;
    
    if (graphType === 'speed') {
      speedMap.sort((a, b) => a.key - b.key);
    } else {
      steeringMap.sort((a, b) => a.key - b.key);
    }
    
    drawAllGraphs();
    calculatePositions();
    drawTrack();
  }
}

function handleGraphMouseUp(e, graphType) {
  if (isDragging && dragGraph === graphType) {
    isDragging = false;
    dragPoint = null;
    dragGraph = null;
    e.target.style.cursor = 'crosshair';
  }
}

function handleGraphDoubleClick(e, graphType) {
  const rect = e.target.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  const dataValue = canvasToData(x, y, graphType);
  if (dataValue) {
    if (graphType === 'speed') {
      speedMap.push({key: dataValue.x, value: dataValue.y});
      speedMap.sort((a, b) => a.key - b.key);
    } else {
      steeringMap.push({key: dataValue.x, value: dataValue.y});
      steeringMap.sort((a, b) => a.key - b.key);
    }
    drawAllGraphs();
    calculatePositions();
    drawTrack();
  }
}

// åº§æ¨™å¤‰æ›ï¼ˆæ”¹å–„ç‰ˆ - ç¯„å›²è¨­å®šã‚’ä½¿ç”¨ï¼‰
function canvasToData(x, y, graphType) {
  const canvas = graphType === 'speed' ? speedGraph : steeringGraph;
  const margin = 50;
  const width = canvas.width - 2 * margin;
  const height = canvas.height - 2 * margin;
  
  const range = graphType === 'speed' ? graphRanges.speed : graphRanges.steering;
  
  const dataX = range.xMin + ((x - margin) / width) * (range.xMax - range.xMin);
  const dataY = range.yMax - ((y - margin) / height) * (range.yMax - range.yMin);
  
  return {
    x: Math.max(range.xMin, Math.min(range.xMax, dataX)),
    y: Math.max(range.yMin, Math.min(range.yMax, dataY))
  };
}

function dataToCanvas(x, y, graphType) {
  const canvas = graphType === 'speed' ? speedGraph : steeringGraph;
  const margin = 50;
  const width = canvas.width - 2 * margin;
  const height = canvas.height - 2 * margin;
  
  const range = graphType === 'speed' ? graphRanges.speed : graphRanges.steering;
  
  const canvasX = margin + ((x - range.xMin) / (range.xMax - range.xMin)) * width;
  const canvasY = margin + ((range.yMax - y) / (range.yMax - range.yMin)) * height;
  
  return {x: canvasX, y: canvasY};
}

function findNearestPoint(x, y, graphType) {
  const map = graphType === 'speed' ? speedMap : steeringMap;
  let nearest = null;
  let minDistance = Infinity;
  
  map.forEach(point => {
    const canvasPos = dataToCanvas(point.key, point.value, graphType);
    const distance = getDistance(x, y, canvasPos.x, canvasPos.y);
    if (distance < minDistance) {
      minDistance = distance;
      nearest = point;
    }
  });
  
  if (nearest) {
    const canvasPos = dataToCanvas(nearest.key, nearest.value, graphType);
    nearest.canvasX = canvasPos.x;
    nearest.canvasY = canvasPos.y;
  }
  
  return nearest;
}

function getDistance(x1, y1, x2, y2) {
  return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
}

// ã‚°ãƒ©ãƒ•æç”»
function drawAllGraphs() {
  drawGraph('speed');
  drawGraph('steering');
}

function drawGraph(graphType) {
  const canvas = graphType === 'speed' ? speedGraph : steeringGraph;
  const ctx = graphType === 'speed' ? speedCtx : steeringCtx;
  const map = graphType === 'speed' ? speedMap : steeringMap;
  const range = graphType === 'speed' ? graphRanges.speed : graphRanges.steering;
  
  const margin = 50;
  const width = canvas.width - 2 * margin;
  const height = canvas.height - 2 * margin;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // ã‚°ãƒªãƒƒãƒ‰æç”»
  drawGrid(ctx, canvas, graphType, margin, width, height, range);
  
  // è»¸ãƒ©ãƒ™ãƒ«æç”»
  drawAxisLabels(ctx, canvas, graphType, margin, width, height, range);
  
  // ãƒ‡ãƒ¼ã‚¿ç·šæç”»
  ctx.strokeStyle = graphType === 'speed' ? '#ff6b6b' : '#4ecdc4';
  ctx.lineWidth = 3;
  ctx.beginPath();
  
  map.forEach((point, index) => {
    const pos = dataToCanvas(point.key, point.value, graphType);
    if (index === 0) {
      ctx.moveTo(pos.x, pos.y);
    } else {
      ctx.lineTo(pos.x, pos.y);
    }
  });
  ctx.stroke();
  
  // ãƒ‡ãƒ¼ã‚¿ç‚¹æç”»
  map.forEach(point => {
    const pos = dataToCanvas(point.key, point.value, graphType);
    ctx.fillStyle = graphType === 'speed' ? '#ff6b6b' : '#4ecdc4';
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  });
}

function drawGrid(ctx, canvas, graphType, margin, width, height, range) {
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  
  // ç¸¦ç·š
  for (let i = 0; i <= 10; i++) {
    const x = margin + (i / 10) * width;
    ctx.beginPath();
    ctx.moveTo(x, margin);
    ctx.lineTo(x, margin + height);
    ctx.stroke();
  }
  
  // æ¨ªç·š
  for (let i = 0; i <= 10; i++) {
    const y = margin + (i / 10) * height;
    ctx.beginPath();
    ctx.moveTo(margin, y);
    ctx.lineTo(margin + width, y);
    ctx.stroke();
  }
  
  // æ ç·š
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 2;
  ctx.strokeRect(margin, margin, width, height);
}

function drawAxisLabels(ctx, canvas, graphType, margin, width, height, range) {
  ctx.fillStyle = 'rgba(255,255,255,0.9)';
  ctx.font = 'bold 13px Arial';
  
  // Xè»¸ãƒ©ãƒ™ãƒ«
  for (let i = 0; i <= 10; i += 2) {
    const x = margin + (i / 10) * width;
    const value = range.xMin + (i / 10) * (range.xMax - range.xMin);
    ctx.textAlign = 'center';
    ctx.fillText(value.toFixed(0), x, margin + height + 20);
  }
  
  // Yè»¸ãƒ©ãƒ™ãƒ«
  for (let i = 0; i <= 10; i += 2) {
    const y = margin + ((10 - i) / 10) * height;
    const value = range.yMin + (i / 10) * (range.yMax - range.yMin);
    ctx.textAlign = 'right';
    ctx.fillText(value.toFixed(1), margin - 10, y + 5);
  }
  
  // è»¸ã‚¿ã‚¤ãƒˆãƒ«
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(graphType === 'speed' ? 'Throttle (%)' : 'Steering (%)', margin + width / 2, canvas.height - 5);
  
  ctx.save();
  ctx.translate(15, margin + height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(graphType === 'speed' ? 'Speed (m/s)' : 'Angle (deg)', 0, 0);
  ctx.restore();
}

// ãƒã‚¤ãƒ³ãƒˆè¿½åŠ 
function addSpeedPoint() {
  const range = graphRanges.speed;
  const newKey = speedMap.length > 0 ? speedMap[speedMap.length - 1].key + 10 : (range.xMin + range.xMax) / 2;
  const newValue = speedMap.length > 0 ? speedMap[speedMap.length - 1].value + 0.5 : (range.yMin + range.yMax) / 2;
  speedMap.push({key: Math.min(newKey, range.xMax), value: Math.min(newValue, range.yMax)});
  speedMap.sort((a, b) => a.key - b.key);
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

function addSteeringPoint() {
  const range = graphRanges.steering;
  const newKey = steeringMap.length > 0 ? steeringMap[steeringMap.length - 1].key + 25 : 0;
  const newValue = steeringMap.length > 0 ? steeringMap[steeringMap.length - 1].value + 11.25 : 0;
  steeringMap.push({key: Math.min(newKey, range.xMax), value: Math.min(newValue, range.yMax)});
  steeringMap.sort((a, b) => a.key - b.key);
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

// ãƒãƒƒãƒ—ãƒªã‚»ãƒƒãƒˆ
function resetSpeedMap() {
  speedMap = [
    {key: 0, value: 0}, {key: 10, value: 0.2}, {key: 20, value: 0.4},
    {key: 30, value: 1}, {key: 40, value: 1.5}, {key: 50, value: 2},
    {key: 60, value: 2.5}, {key: 70, value: 3}, {key: 80, value: 3.5},
    {key: 90, value: 4}, {key: 100, value: 5}
  ];
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

function resetSteeringMap() {
  steeringMap = [
    {key: -100, value: 45}, {key: -50, value: 22.5},
    {key: 0, value: 0}, {key: 50, value: -22.5}, {key: 100, value: -45}
  ];
  drawAllGraphs();
  calculatePositions();
  drawTrack();
}

// ãƒãƒƒãƒ—ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
function exportMaps() {
  const maps = {speedMap, steeringMap, sensorAngles, graphRanges};
  const dataStr = JSON.stringify(maps, null, 2);
  const dataBlob = new Blob([dataStr], {type: 'application/json'});
  const url = URL.createObjectURL(dataBlob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'minicar_maps_v4.json';
  link.click();
  URL.revokeObjectURL(url);
}

function importMaps() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
      try {
        const maps = JSON.parse(event.target.result);
        speedMap = maps.speedMap;
        steeringMap = maps.steeringMap;
        if (maps.sensorAngles) {
          sensorAngles = maps.sensorAngles;
          Object.keys(sensorAngles).forEach(sensor => {
            document.getElementById(`angle${sensor}`).value = sensorAngles[sensor];
            document.querySelector(`#angle${sensor}`).previousElementSibling.value = sensorAngles[sensor];
          });
        }
        if (maps.graphRanges) {
          graphRanges = maps.graphRanges;
          document.getElementById('speedXMin').value = graphRanges.speed.xMin;
          document.getElementById('speedXMax').value = graphRanges.speed.xMax;
          document.getElementById('speedYMin').value = graphRanges.speed.yMin;
          document.getElementById('speedYMax').value = graphRanges.speed.yMax;
          document.getElementById('steeringXMin').value = graphRanges.steering.xMin;
          document.getElementById('steeringXMax').value = graphRanges.steering.xMax;
          document.getElementById('steeringYMin').value = graphRanges.steering.yMin;
          document.getElementById('steeringYMax').value = graphRanges.steering.yMax;
        }
        drawAllGraphs();
        calculatePositions();
        drawTrack();
      } catch (error) {
        alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
      }
    };
    reader.readAsText(file);
  };
  input.click();
}

// çµ±è¨ˆæƒ…å ±æ›´æ–°
function updateStats() {
  if (!csvData.length) return;
  
  document.getElementById('totalPoints').textContent = csvData.length;
  
  let totalDistance = 0;
  let maxSpeed = 0;
  let totalSpeed = 0;
  
  csvData.forEach((row, i) => {
    const thr = parseFloat(row[headers.indexOf('Thr')]);
    const speed = interpolateMap(speedMap, thr);
    const dt = i > 0 ? (parseFloat(row[0]) - parseFloat(csvData[i-1][0])) : 0.04;
    
    totalDistance += speed * dt;
    maxSpeed = Math.max(maxSpeed, speed);
    totalSpeed += speed;
  });
  
  document.getElementById('trackLength').textContent = totalDistance.toFixed(2) + 'm';
  document.getElementById('maxSpeed').textContent = maxSpeed.toFixed(2) + 'm/s';
  document.getElementById('avgSpeed').textContent = (totalSpeed / csvData.length).toFixed(2) + 'm/s';
}

// è»Œè·¡æç”»ï¼ˆæœ€é‡è¦é–¢æ•°ï¼‰
function drawTrack() {
  const canvas = document.getElementById('trackCanvas');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!positions.length) return;

  const activeSensors = Array.from(document.querySelectorAll('.sensorCheckbox:checked')).map(cb => cb.value);

  const xs = positions.map(p => p.x);
  const ys = positions.map(p => p.y);
  const minX = Math.min(...xs);
  const maxX = Math.max(...xs);
  const minY = Math.min(...ys);
  const maxY = Math.max(...ys);
  
  const margin = 80;
  const scaleX = (canvas.width - 2 * margin) / (maxX - minX + VEHICLE_LENGTH * 2);
  const scaleY = (canvas.height - 2 * margin) / (maxY - minY + VEHICLE_LENGTH * 2);
  const scale = Math.min(scaleX, scaleY);
  
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  
  // ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’ä¿å­˜ï¼ˆã‚¯ãƒªãƒƒã‚¯å‡¦ç†ã§ä½¿ç”¨ï¼‰
  canvasScaleInfo = { minX, minY, scale, margin, centerX, centerY };

  // å¤‰æ›ã‚’é©ç”¨ã—ã¦æç”»
  ctx.save();
  ctx.translate(centerX + mapOffsetX, centerY + mapOffsetY);
  ctx.rotate(mapRotation);
  ctx.scale(mapZoom, mapZoom);
  ctx.translate(-centerX, -centerY);

  // èƒŒæ™¯ã‚°ãƒªãƒƒãƒ‰
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1 / mapZoom;
  for(let i = 0; i <= 20; i++){
    const x = margin + i * (canvas.width - 2 * margin) / 20;
    ctx.beginPath();
    ctx.moveTo(x, margin);
    ctx.lineTo(x, canvas.height - margin);
    ctx.stroke();
    
    const y = margin + i * (canvas.height - 2 * margin) / 20;
    ctx.beginPath();
    ctx.moveTo(margin, y);
    ctx.lineTo(canvas.width - margin, y);
    ctx.stroke();
  }

  // ã‚³ãƒ¼ã‚¹å‚ç…§ç·šã‚’æç”»ï¼ˆå‡¹å‹ã‚³ãƒ¼ã‚¹ï¼‰
  if (showCourseRef) {
    const courseVertical = parseFloat(document.getElementById('courseVertical').value) * 1000; // m â†’ mm
    const courseHorizontal = parseFloat(document.getElementById('courseHorizontal').value) * 1000;
    const courseWidth = parseFloat(document.getElementById('courseWidth').value) * 1000;
    
    // ã‚³ãƒ¼ã‚¹ä¸­å¿ƒã‚’è¨ˆç®—
    const courseCenterX = centerX;
    const courseCenterY = centerY;
    
    // å‡¹å‹ã‚³ãƒ¼ã‚¹ã®å¤–å´ãƒ©ã‚¤ãƒ³ï¼ˆæ™‚è¨ˆå›ã‚Šï¼‰
    ctx.strokeStyle = 'rgba(138,201,38,0.7)';
    ctx.lineWidth = 3 / mapZoom;
    ctx.setLineDash([10 / mapZoom, 5 / mapZoom]);
    ctx.beginPath();
    
    const halfVert = courseVertical / 2;
    const halfHoriz = courseHorizontal / 2;
    
    // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’é©ç”¨
    const refScale = scale;
    
    // å¤–å´ã®çŸ©å½¢ï¼ˆå·¦ä¸Šã‹ã‚‰æ™‚è¨ˆå›ã‚Šï¼‰
    ctx.moveTo(courseCenterX - halfHoriz * refScale, courseCenterY - halfVert * refScale);
    ctx.lineTo(courseCenterX + halfHoriz * refScale, courseCenterY - halfVert * refScale);
    ctx.lineTo(courseCenterX + halfHoriz * refScale, courseCenterY + halfVert * refScale);
    ctx.lineTo(courseCenterX - halfHoriz * refScale, courseCenterY + halfVert * refScale);
    ctx.closePath();
    ctx.stroke();
    
    // å†…å´ãƒ©ã‚¤ãƒ³ï¼ˆé“å¹…åˆ†å†…å´ï¼‰
    ctx.strokeStyle = 'rgba(138,201,38,0.5)';
    ctx.beginPath();
    const innerOffset = courseWidth * refScale;
    ctx.moveTo(courseCenterX - halfHoriz * refScale + innerOffset, courseCenterY - halfVert * refScale + innerOffset);
    ctx.lineTo(courseCenterX + halfHoriz * refScale - innerOffset, courseCenterY - halfVert * refScale + innerOffset);
    ctx.lineTo(courseCenterX + halfHoriz * refScale - innerOffset, courseCenterY + halfVert * refScale - innerOffset);
    ctx.lineTo(courseCenterX - halfHoriz * refScale + innerOffset, courseCenterY + halfVert * refScale - innerOffset);
    ctx.closePath();
    ctx.stroke();
    
    ctx.setLineDash([]);
    
    // å¯¸æ³•è¡¨ç¤º
    ctx.fillStyle = 'rgba(138,201,38,0.9)';
    ctx.font = `${14 / mapZoom}px Arial`;
    ctx.fillText(`${courseVertical/1000}m`, courseCenterX + halfHoriz * refScale + 10 / mapZoom, courseCenterY);
    ctx.fillText(`${courseHorizontal/1000}m`, courseCenterX, courseCenterY - halfVert * refScale - 10 / mapZoom);
  }

  // å…¨æ™‚åˆ»ç¯„å›²ã®è»Œè·¡ç·šã‚’æç”»
  ctx.strokeStyle = 'rgba(0,200,255,0.5)';
  ctx.lineWidth = 2 / mapZoom;
  ctx.beginPath();
  positions.forEach((p, i) => {
    const cx = margin + (p.x - minX) * scale;
    const cy = margin + (p.y - minY) * scale;
    if (i === 0) {
      ctx.moveTo(cx, cy);
    } else {
      ctx.lineTo(cx, cy);
    }
  });
  ctx.stroke();

  // ã‚»ãƒ³ã‚µãƒ¼ã”ã¨ã«ç‚¹ã¨ç·šã‚’æç”»
  activeSensors.forEach(name => {
    const idx = headers.indexOf(name);
    if (idx < 0) return;
    
    const color = sensorColors[name];
    const sensorAngleRad = (sensorAngles[name] || 0) * Math.PI / 180;
    
    let sensorPoints = [];
    positions.forEach((p, i) => {
      if (i % sensorDensity !== 0) return;
      
      const cx = margin + (p.x - minX) * scale;
      const cy = margin + (p.y - minY) * scale;
      
      // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãŒæœ‰åŠ¹ãªå ´åˆã¯ãƒ•ã‚£ãƒ«ã‚¿æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
      const dataSource = (medianFilterEnabled && filteredData.length > 0) ? filteredData : csvData;
      const distance = parseFloat(dataSource[i][idx]);
      
      const totalAngle = p.theta + sensorAngleRad;
      const sx = cx + distance * scale * Math.cos(totalAngle);
      const sy = cy + distance * scale * Math.sin(totalAngle);
      
      sensorPoints.push({x: sx, y: sy, index: i});
    });
    
    // ç·šã‚’æç”»
    if (sensorPoints.length > 1) {
      ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`;
      ctx.lineWidth = sensorLineWidth / mapZoom;
      ctx.beginPath();
      sensorPoints.forEach((point, i) => {
        if (i === 0) {
          ctx.moveTo(point.x, point.y);
        } else {
          ctx.lineTo(point.x, point.y);
        }
      });
      ctx.stroke();
    }
    
    // ã‚»ãƒ³ã‚µãƒ¼ç‚¹ã‚’æç”»ï¼ˆæ™‚åˆ»ã«åŸºã¥ã„ã¦è¦–è¦šçš„ã«å¤‰åŒ–ï¼‰
    sensorPoints.forEach(point => {
      const timeDiff = point.index - currentTimeIndex;
      let pointSize = sensorPointSize / mapZoom;
      let pointColor = color;
      let alpha = 0.95;
      
      if (timeDiff < 0) {
        // éå»ã®ãƒ—ãƒ­ãƒƒãƒˆ
        const pastIndex = Math.abs(timeDiff);
        
        if (pastIndex <= pastPlotsCount * sensorDensity) {
          // éå»pastPlotsCountå€‹ã®ãƒ—ãƒ­ãƒƒãƒˆï¼šé †ã«å°ã•ãã™ã‚‹
          const ratio = 1 - (pastIndex / (pastPlotsCount * sensorDensity)) * 0.6;
          pointSize = (sensorPointSize / mapZoom) * ratio;
          alpha = 0.95 * ratio;
        } else {
          // ãã‚Œã‚ˆã‚Šéå»ï¼šå°ã•ãç°è‰²
          pointSize = (sensorPointSize / mapZoom) * 0.3;
          pointColor = {r: 128, g: 128, b: 128};
          alpha = 0.4;
        }
      } else if (timeDiff > 0) {
        // æœªæ¥ã®ãƒ—ãƒ­ãƒƒãƒˆ
        if (futurePlotsCount === 0) {
          // 0æŒ‡å®šã®å ´åˆã¯å…¨åŒºé–“é€šå¸¸ã‚µã‚¤ã‚º
          pointSize = sensorPointSize / mapZoom;
        alpha = 0.7;
        } else {
          const futureIndex = timeDiff;
          if (futureIndex <= futurePlotsCount * sensorDensity) {
            // æœªæ¥futurePlotsCountå€‹ã®ãƒ—ãƒ­ãƒƒãƒˆï¼šé€šå¸¸ã‚µã‚¤ã‚º
            pointSize = sensorPointSize / mapZoom;
            alpha = 0.7;
          } else {
            // ãã‚Œã‚ˆã‚Šæœªæ¥ï¼šå°ã•ãç°è‰²
            pointSize = (sensorPointSize / mapZoom) * 0.3;
            pointColor = {r: 128, g: 128, b: 128};
            alpha = 0.4;
          }
        }
      }
      
      // ãƒã‚¤ãƒ³ãƒˆæç”»
      const grd = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, pointSize);
      grd.addColorStop(0, `rgba(${pointColor.r}, ${pointColor.g}, ${pointColor.b}, ${alpha})`);
      grd.addColorStop(1, `rgba(${pointColor.r}, ${pointColor.g}, ${pointColor.b}, 0)`);
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(point.x, point.y, pointSize, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // ç¾åœ¨æ™‚åˆ»ã®ã‚»ãƒ³ã‚µãƒ¼ç‚¹ã‚’ç‰¹ã«ç›®ç«‹ãŸã›ã‚‹
    const currentPoint = sensorPoints.find(p => p.index === currentTimeIndex);
    if (currentPoint) {
      // å¤–å´ã®å…‰ã‚‹è¼ª
      const outerGrd = ctx.createRadialGradient(currentPoint.x, currentPoint.y, 0, currentPoint.x, currentPoint.y, (sensorPointSize / mapZoom) * 3);
      outerGrd.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`);
      outerGrd.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`);
      outerGrd.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
      ctx.fillStyle = outerGrd;
      ctx.beginPath();
      ctx.arc(currentPoint.x, currentPoint.y, (sensorPointSize / mapZoom) * 3, 0, Math.PI * 2);
      ctx.fill();
      
      // ä¸­å¿ƒã®æ˜ã‚‹ã„ç‚¹
      ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
      ctx.beginPath();
      ctx.arc(currentPoint.x, currentPoint.y, (sensorPointSize / mapZoom) * 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      // ç™½ã„ç¸å–ã‚Š
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
      ctx.lineWidth = 2 / mapZoom;
      ctx.stroke();
    }
  });

  // ç¾åœ¨ã¾ã§ã®è»Œè·¡ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  if (currentTimeIndex > 0) {
    ctx.strokeStyle = 'rgba(0,255,255,0.9)';
    ctx.lineWidth = 3 / mapZoom;
    ctx.beginPath();
    for (let i = 0; i <= currentTimeIndex && i < positions.length; i++) {
      const p = positions[i];
      const cx = margin + (p.x - minX) * scale;
      const cy = margin + (p.y - minY) * scale;
      if (i === 0) {
        ctx.moveTo(cx, cy);
      } else {
        ctx.lineTo(cx, cy);
      }
    }
    ctx.stroke();
  }

  // ç¾åœ¨ã®è»Šä¸¡ä½ç½®ã‚’æç”»
  if (currentTimeIndex < positions.length) {
    const currentPos = positions[currentTimeIndex];
    const cx = margin + (currentPos.x - minX) * scale;
    const cy = margin + (currentPos.y - minY) * scale;
    
    // è·é›¢ã‚µãƒ¼ã‚¯ãƒ«ã‚’æç”»
    drawDistanceCircles(ctx, cx, cy, scale);
    
    // è»Šä¸¡ã‚’æç”»
    drawVehicle(ctx, cx, cy, currentPos.theta, scale / mapZoom);
  }

  ctx.restore();
  
  // å¤‰æ›ã‚’é©ç”¨ã—ãªã„è¦ç´ ï¼ˆå‡¡ä¾‹ã€ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã€ã‚³ãƒ³ãƒ‘ã‚¹ã€ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒœã‚¿ãƒ³ï¼‰
  drawLegend(ctx, canvas, activeSensors);
  drawScaleInfo(ctx, canvas, scale);
  drawCompass(ctx, canvas);
  drawMedianFilterButton(ctx, canvas);
}

// ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãƒœã‚¿ãƒ³æç”»
function drawMedianFilterButton(ctx, canvas) {
  const btnX = canvas.width - 80;
  const btnY = 150;  // ã‚³ãƒ³ãƒ‘ã‚¹ã®ä¸‹
  const btnWidth = 120;
  const btnHeight = 30;
  
  ctx.save();
  
  // ãƒœã‚¿ãƒ³èƒŒæ™¯
  if (medianFilterEnabled) {
    ctx.fillStyle = 'rgba(78,205,196,0.9)';
  } else {
    ctx.fillStyle = 'rgba(60,60,60,0.9)';
  }
  ctx.strokeStyle = medianFilterEnabled ? 'rgba(78,205,196,1)' : 'rgba(100,100,100,1)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.roundRect(btnX - btnWidth/2, btnY - btnHeight/2, btnWidth, btnHeight, 5);
  ctx.fill();
  ctx.stroke();
  
  // ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
  ctx.fillStyle = medianFilterEnabled ? '#fff' : '#aaa';
  ctx.font = 'bold 12px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(medianFilterEnabled ? 'âœ“ Filter ON' : 'Filter OFF', btnX, btnY);
  
  ctx.restore();
  
  // ãƒœã‚¿ãƒ³ã®ä½ç½®ã‚’ä¿å­˜ï¼ˆã‚¯ãƒªãƒƒã‚¯åˆ¤å®šç”¨ï¼‰
  if (!canvas.medianBtnBounds) {
    canvas.medianBtnBounds = {};
  }
  canvas.medianBtnBounds.x = btnX - btnWidth/2;
  canvas.medianBtnBounds.y = btnY - btnHeight/2;
  canvas.medianBtnBounds.width = btnWidth;
  canvas.medianBtnBounds.height = btnHeight;
}

// ã‚³ãƒ³ãƒ‘ã‚¹æç”»
function drawCompass(ctx, canvas) {
  const compassX = canvas.width - 80;
  const compassY = 80;
  const compassRadius = 40;
  
  ctx.save();
  
  // èƒŒæ™¯å††
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.beginPath();
  ctx.arc(compassX, compassY, compassRadius, 0, Math.PI * 2);
  ctx.fill();
  
  // å¤–æ 
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // å›è»¢ã‚’é©ç”¨
  ctx.translate(compassX, compassY);
  ctx.rotate(mapRotation);
  
  // åŒ—ã‚’æŒ‡ã™çŸ¢å°ï¼ˆèµ¤ï¼‰
  ctx.fillStyle = '#ff4444';
  ctx.beginPath();
  ctx.moveTo(0, -compassRadius * 0.7);
  ctx.lineTo(-compassRadius * 0.2, 0);
  ctx.lineTo(0, -compassRadius * 0.3);
  ctx.lineTo(compassRadius * 0.2, 0);
  ctx.closePath();
  ctx.fill();
  
  // å—ã‚’æŒ‡ã™çŸ¢å°ï¼ˆç™½ï¼‰
  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.moveTo(0, compassRadius * 0.7);
  ctx.lineTo(-compassRadius * 0.2, 0);
  ctx.lineTo(0, compassRadius * 0.3);
  ctx.lineTo(compassRadius * 0.2, 0);
  ctx.closePath();
  ctx.fill();
  
  ctx.restore();
  
  // Næ–‡å­—ï¼ˆå¸¸ã«ä¸Šå‘ãï¼‰
  ctx.fillStyle = '#ff4444';
  ctx.font = 'bold 16px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText('N', compassX, compassY - compassRadius - 15);
}

// ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±æç”»
function drawScaleInfo(ctx, canvas, scale) {
  const infoX = 20;
  const infoY = 20;
  
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(infoX - 10, infoY - 10, 220, 130);
  
  ctx.fillStyle = '#4ecdc4';
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'left';
  ctx.fillText('ğŸ“ ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±', infoX, infoY + 15);
  
  ctx.fillStyle = '#fff';
  ctx.font = '12px Arial';
  ctx.fillText(`è»Šä¸¡: ${VEHICLE_LENGTH}Ã—${VEHICLE_WIDTH}mm`, infoX, infoY + 40);
  ctx.fillText(`ã‚³ãƒ¼ã‚¹å¹…: ç´„${COURSE_WIDTH}mm`, infoX, infoY + 60);
  ctx.fillText(`è¡¨ç¤ºå€ç‡: Ã—${(scale * mapZoom).toFixed(3)}`, infoX, infoY + 80);
  ctx.fillText(`ã‚ºãƒ¼ãƒ : ${mapZoom.toFixed(1)}x`, infoX, infoY + 100);
  
  const barLength = 100 * scale * mapZoom;
  ctx.strokeStyle = '#4ecdc4';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(infoX, infoY + 115);
  ctx.lineTo(infoX + barLength, infoY + 115);
  ctx.stroke();
  
  ctx.fillStyle = '#4ecdc4';
  ctx.font = '11px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('100mm', infoX + barLength / 2, infoY + 110);
}

// å‡¡ä¾‹æç”»
function drawLegend(ctx, canvas, activeSensors) {
  const legendX = canvas.width - 180;
  const legendY = 170;  // ã‚³ãƒ³ãƒ‘ã‚¹ã®ä¸‹ã«é…ç½®
  const lineHeight = 25;
  
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(legendX - 10, legendY - 10, 170, activeSensors.length * lineHeight + 50);
  
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'left';
  ctx.fillText('ã‚»ãƒ³ã‚µãƒ¼å‡¡ä¾‹', legendX, legendY + 15);
  
  ctx.font = '12px Arial';
  activeSensors.forEach((name, i) => {
    const color = sensorColors[name];
    const y = legendY + 40 + i * lineHeight;
    
    ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
    ctx.beginPath();
    ctx.arc(legendX + 10, y, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#fff';
    const angle = sensorAngles[name] || 0;
    ctx.fillText(`${name} (${angle}Â°)`, legendX + 25, y + 4);
  });
}

// è·é›¢ã‚µãƒ¼ã‚¯ãƒ«æç”»
function drawDistanceCircles(ctx, x, y, scale) {
  const distances = [500, 1000, 1500, 2000, 2500, 3000];
  
  ctx.save();
  distances.forEach((dist, index) => {
    const radius = dist * scale;
    ctx.strokeStyle = `rgba(255,255,255,${0.3 - index * 0.07})`;
    ctx.lineWidth = 1 / mapZoom;
    ctx.setLineDash([5 / mapZoom, 5 / mapZoom]);
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // è·é›¢ãƒ©ãƒ™ãƒ«
    ctx.fillStyle = `rgba(255,255,255,${0.5 - index * 0.1})`;
    ctx.font = `${10 / mapZoom}px Arial`;
    ctx.textAlign = 'center';
    ctx.fillText(`${dist}mm`, x, y - radius - 3 / mapZoom);
  });
  ctx.setLineDash([]);
  ctx.restore();
}

// è»Šä¸¡æç”»
function drawVehicle(ctx, x, y, theta, scale) {
  const length = VEHICLE_LENGTH * scale * vehicleSizeMultiplier;
  const width = VEHICLE_WIDTH * scale * vehicleSizeMultiplier;
  
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(theta);
  
  ctx.beginPath();
  ctx.moveTo(length * 0.4, 0);
  ctx.lineTo(length * 0.1, -width * 0.5);
  ctx.lineTo(-length * 0.4, -width * 0.5);
  ctx.lineTo(-length * 0.4, width * 0.5);
  ctx.lineTo(length * 0.1, width * 0.5);
  ctx.closePath();
  
  ctx.fillStyle = 'rgba(0,255,100,0.7)';
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.9)';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.beginPath();
  ctx.moveTo(length * 0.1, 0);
  ctx.lineTo(length * 0.4, 0);
  ctx.strokeStyle = 'rgba(255,255,0,1)';
  ctx.lineWidth = 3;
  ctx.stroke();
  
  ctx.restore();
}

// ç·šå½¢è£œé–“
function interpolateMap(mapArray, value) {
  if (!mapArray.length) return 0;
  
  mapArray.sort((a,b)=>a.key-b.key);
  if (value <= mapArray[0].key) return mapArray[0].value;
  if (value >= mapArray[mapArray.length-1].key) return mapArray[mapArray.length-1].value;
  for(let i=0;i<mapArray.length-1;i++){
    if(value>=mapArray[i].key && value<=mapArray[i+1].key){
      const v0=mapArray[i].value,v1=mapArray[i+1].value;
      const t=(value-mapArray[i].key)/(mapArray[i+1].key-mapArray[i].key);
      return v0+t*(v1-v0);
    }
  }
  return 0;
}

// åˆ¶å¾¡ã‚°ãƒ©ãƒ•æç”»
function drawControlGraph() {
  if (!controlCtx || !csvData.length || !headers.length) return;
  
  const strIdx = headers.indexOf('Str');
  const thrIdx = headers.indexOf('Thr');
  
  if (strIdx < 0 || thrIdx < 0) return;
  
  const canvas = controlGraph;
  const ctx = controlCtx;
  const width = canvas.width;
  const height = canvas.height;
  const marginLeft = 45;
  const marginRight = 45;
  const marginTop = 20;
  const marginBottom = 25;
  const graphWidth = width - marginLeft - marginRight;
  const graphHeight = height - marginTop - marginBottom;
  
  // ã‚¯ãƒªã‚¢
  ctx.clearRect(0, 0, width, height);
  
  // èƒŒæ™¯
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.fillRect(marginLeft, marginTop, graphWidth, graphHeight);
  
  // ã‚°ãƒªãƒƒãƒ‰
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 5; i++) {
    const y = marginTop + (i / 5) * graphHeight;
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + graphWidth, y);
    ctx.stroke();
  }
  
  // è»¸ç·š
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;
  ctx.strokeRect(marginLeft, marginTop, graphWidth, graphHeight);
  
  // Str (èˆµè§’) ã®ç¯„å›²: -100 ~ 100
  // Thr (é§†å‹•) ã®ç¯„å›²: 0 ~ 100
  const strMin = -100;
  const strMax = 100;
  const thrMin = 0;
  const thrMax = 100;
  
  // Xè»¸ï¼šãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  const dataLength = csvData.length;
  
  // ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°é ˜åŸŸã‚’è¨­å®š
  ctx.save();
  ctx.beginPath();
  ctx.rect(marginLeft, marginTop, graphWidth, graphHeight);
  ctx.clip();
  
  // ã‚ºãƒ¼ãƒ ã¨ãƒ‘ãƒ³ã‚’é©ç”¨ã—ãŸå¤‰æ›
  const centerX = marginLeft + graphWidth / 2;
  const centerY = marginTop + graphHeight / 2;
  
  ctx.translate(centerX + controlGraphOffsetX, centerY + controlGraphOffsetY);
  ctx.scale(controlGraphZoomX, controlGraphZoomY);
  ctx.translate(-centerX, -centerY);
  
  // Str (é’è‰²) ã‚’æç”»
  ctx.strokeStyle = '#4ecdc4';
  ctx.lineWidth = 2 / Math.sqrt(controlGraphZoomX * controlGraphZoomY);
  ctx.beginPath();
  csvData.forEach((row, i) => {
    const str = parseFloat(row[strIdx]);
    const x = marginLeft + (i / (dataLength - 1)) * graphWidth;
    const y = marginTop + graphHeight - ((str - strMin) / (strMax - strMin)) * graphHeight;
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  });
  ctx.stroke();
  
  // Thr (èµ¤è‰²) ã‚’æç”»
  ctx.strokeStyle = '#ff6b6b';
  ctx.lineWidth = 2 / Math.sqrt(controlGraphZoomX * controlGraphZoomY);
  ctx.beginPath();
  csvData.forEach((row, i) => {
    const thr = parseFloat(row[thrIdx]);
    const x = marginLeft + (i / (dataLength - 1)) * graphWidth;
    const y = marginTop + graphHeight - ((thr - thrMin) / (thrMax - thrMin)) * graphHeight;
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  });
  ctx.stroke();
  
  // ç¾åœ¨ä½ç½®ã®ãƒãƒ¼ã‚«ãƒ¼ï¼ˆç¸¦ç·šã¨ç‚¹ï¼‰
  if (currentTimeIndex < dataLength) {
    const x = marginLeft + (currentTimeIndex / (dataLength - 1)) * graphWidth;
    
    // ç¸¦ç·š
    ctx.strokeStyle = 'rgba(255,255,0,0.6)';
    ctx.lineWidth = 2 / Math.sqrt(controlGraphZoomX * controlGraphZoomY);
    ctx.setLineDash([5 / controlGraphZoomX, 5 / controlGraphZoomX]);
    ctx.beginPath();
    ctx.moveTo(x, marginTop);
    ctx.lineTo(x, marginTop + graphHeight);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Str ã®ç‚¹
    const str = parseFloat(csvData[currentTimeIndex][strIdx]);
    const strY = marginTop + graphHeight - ((str - strMin) / (strMax - strMin)) * graphHeight;
    ctx.fillStyle = '#4ecdc4';
    ctx.beginPath();
    ctx.arc(x, strY, 5 / Math.sqrt(controlGraphZoomX * controlGraphZoomY), 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 2 / Math.sqrt(controlGraphZoomX * controlGraphZoomY);
    ctx.stroke();
    
    // Thr ã®ç‚¹
    const thr = parseFloat(csvData[currentTimeIndex][thrIdx]);
    const thrY = marginTop + graphHeight - ((thr - thrMin) / (thrMax - thrMin)) * graphHeight;
    ctx.fillStyle = '#ff6b6b';
    ctx.beginPath();
    ctx.arc(x, thrY, 5 / Math.sqrt(controlGraphZoomX * controlGraphZoomY), 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.8)';
    ctx.lineWidth = 2 / Math.sqrt(controlGraphZoomX * controlGraphZoomY);
    ctx.stroke();
  }
  
  ctx.restore();
  
  // è¡¨ç¤ºç¯„å›²ã‚’è¨ˆç®—ï¼ˆã‚ºãƒ¼ãƒ ã¨ãƒ‘ãƒ³ã‚’è€ƒæ…®ï¼‰
  // é€†å¤‰æ›è¡Œåˆ—ã‚’ä½¿ã£ã¦ç”»é¢åº§æ¨™ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿åº§æ¨™ã‚’è¨ˆç®—
  const getDataCoords = (screenX, screenY) => {
    const dx = screenX - centerX - controlGraphOffsetX;
    const dy = screenY - centerY - controlGraphOffsetY;
    const dataX = centerX + dx / controlGraphZoomX;
    const dataY = centerY + dy / controlGraphZoomY;
    return { x: dataX, y: dataY };
  };
  
  // è¡¨ç¤ºç¯„å›²ã®å·¦ä¸Šã¨å³ä¸‹ã®ãƒ‡ãƒ¼ã‚¿åº§æ¨™ã‚’å–å¾—
  const topLeft = getDataCoords(marginLeft, marginTop);
  const bottomRight = getDataCoords(marginLeft + graphWidth, marginTop + graphHeight);
  
  // ãƒ‡ãƒ¼ã‚¿å€¤ã®ç¯„å›²ã‚’è¨ˆç®—
  const visibleDataIndexMin = Math.max(0, ((topLeft.x - marginLeft) / graphWidth) * (dataLength - 1));
  const visibleDataIndexMax = Math.min(dataLength - 1, ((bottomRight.x - marginLeft) / graphWidth) * (dataLength - 1));
  
  const visibleStrMin = strMax - ((bottomRight.y - marginTop) / graphHeight) * (strMax - strMin);
  const visibleStrMax = strMax - ((topLeft.y - marginTop) / graphHeight) * (strMax - strMin);
  
  const visibleThrMin = thrMax - ((bottomRight.y - marginTop) / graphHeight) * (thrMax - thrMin);
  const visibleThrMax = thrMax - ((topLeft.y - marginTop) / graphHeight) * (thrMax - thrMin);
  
  // Yè»¸ãƒ©ãƒ™ãƒ« (å·¦å´: Str) - è¡¨ç¤ºç¯„å›²ã«åˆã‚ã›ã¦
  ctx.fillStyle = '#4ecdc4';
  ctx.font = 'bold 11px Arial';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 5; i++) {
    const value = visibleStrMin + (i / 5) * (visibleStrMax - visibleStrMin);
    const y = marginTop + graphHeight - (i / 5) * graphHeight;
    ctx.fillText(value.toFixed(0), marginLeft - 8, y + 4);
  }
  
  // Yè»¸ã‚¿ã‚¤ãƒˆãƒ« (å·¦å´)
  ctx.save();
  ctx.translate(12, marginTop + graphHeight / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.fillStyle = '#4ecdc4';
  ctx.font = 'bold 12px Arial';
  ctx.fillText('Str (èˆµè§’ %)', 0, 0);
  ctx.restore();
  
  // Yè»¸ãƒ©ãƒ™ãƒ« (å³å´: Thr) - è¡¨ç¤ºç¯„å›²ã«åˆã‚ã›ã¦
  ctx.fillStyle = '#ff6b6b';
  ctx.font = 'bold 11px Arial';
  ctx.textAlign = 'left';
  for (let i = 0; i <= 5; i++) {
    const value = visibleThrMin + (i / 5) * (visibleThrMax - visibleThrMin);
    const y = marginTop + graphHeight - (i / 5) * graphHeight;
    ctx.fillText(value.toFixed(0), marginLeft + graphWidth + 8, y + 4);
  }
  
  // Yè»¸ã‚¿ã‚¤ãƒˆãƒ« (å³å´)
  ctx.save();
  ctx.translate(width - 12, marginTop + graphHeight / 2);
  ctx.rotate(Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.fillStyle = '#ff6b6b';
  ctx.font = 'bold 12px Arial';
  ctx.fillText('Thr (é§†å‹• %)', 0, 0);
  ctx.restore();
  
  // Xè»¸ãƒ©ãƒ™ãƒ« - è¡¨ç¤ºç¯„å›²ã«åˆã‚ã›ã¦
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 5; i++) {
    const index = Math.floor(visibleDataIndexMin + (i / 5) * (visibleDataIndexMax - visibleDataIndexMin));
    const x = marginLeft + (i / 5) * graphWidth;
    ctx.fillText(index, x, height - 8);
  }
  
  // Xè»¸ã‚¿ã‚¤ãƒˆãƒ«
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.font = 'bold 11px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹', marginLeft + graphWidth / 2, height - 2);
}

// ã‚»ãƒ³ã‚µã‚°ãƒ©ãƒ•æç”»
function drawSensorGraph() {
  if (!sensorCtx || !csvData || csvData.length === 0) return;
  
  // ãƒ¡ãƒ‡ã‚£ã‚¢ãƒ³ãƒ•ã‚£ãƒ«ã‚¿ãŒæœ‰åŠ¹ãªå ´åˆã¯ãƒ•ã‚£ãƒ«ã‚¿æ¸ˆã¿ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨
  const dataSource = (medianFilterEnabled && filteredData.length > 0) ? filteredData : csvData;
  
  const canvas = sensorGraph;
  const ctx = sensorCtx;
  const width = canvas.width;
  const height = canvas.height;
  
  if (!width || !height) return;
  
  // é¸æŠã•ã‚ŒãŸã‚»ãƒ³ã‚µã‚’å–å¾—
  const selectedSensors = Array.from(document.querySelectorAll('.sensor-select-checkbox input:checked'))
    .map(cb => cb.value);
  
  const sensorColors = {
    'RrLH': '#ff3296',
    'FrLH': '#64c8ff',
    'Fr': '#32ff32',
    'FrRH': '#ffc832',
    'RrRH': '#ff6432'
  };
  
  const marginLeft = 60;
  const marginRight = 30;
  const marginTop = 30;
  const marginBottom = 40;
  const graphWidth = width - marginLeft - marginRight;
  const graphHeight = height - marginTop - marginBottom;
  
  const dataLength = dataSource.length;
  
  // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
  ctx.clearRect(0, 0, width, height);
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, width, height);
  
  // ã‚»ãƒ³ã‚µãŒãªã„å ´åˆã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
  if (selectedSensors.length === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ã‚»ãƒ³ã‚µã‚’é¸æŠã—ã¦ãã ã•ã„', width / 2, height / 2);
    return;
  }
  
  // å„ã‚»ãƒ³ã‚µã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
  const sensorIndices = {};
  selectedSensors.forEach(sensor => {
    const idx = headers.indexOf(sensor);
    if (idx !== -1) {
      sensorIndices[sensor] = idx;
    }
  });
  
  // å…¨ã‚»ãƒ³ã‚µã®ãƒ‡ãƒ¼ã‚¿ç¯„å›²ã‚’è¨ˆç®—ï¼ˆã™ã¹ã¦åŒã˜Yè»¸ï¼‰
  let allMin = Infinity;
  let allMax = -Infinity;
  
  Object.values(sensorIndices).forEach(idx => {
    dataSource.forEach(row => {
      const value = parseFloat(row[idx]);
      if (!isNaN(value)) {
        allMin = Math.min(allMin, value);
        allMax = Math.max(allMax, value);
      }
    });
  });
  
  if (!isFinite(allMin) || !isFinite(allMax)) {
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“', width / 2, height / 2);
    return;
  }
  
  // ç¯„å›²ã«ä½™è£•ã‚’æŒãŸã›ã‚‹
  const range = allMax - allMin;
  allMin -= range * 0.1;
  allMax += range * 0.1;
  
  // ã‚°ãƒªãƒƒãƒ‰ç·šã‚’æç”»
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 5; i++) {
    const y = marginTop + (i / 5) * graphHeight;
    ctx.beginPath();
    ctx.moveTo(marginLeft, y);
    ctx.lineTo(marginLeft + graphWidth, y);
    ctx.stroke();
  }
  
  // è»¸ã‚’æç”»
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;
  ctx.strokeRect(marginLeft, marginTop, graphWidth, graphHeight);
  
  // ã‚¯ãƒªãƒƒãƒ”ãƒ³ã‚°é ˜åŸŸã‚’è¨­å®š
  ctx.save();
  ctx.beginPath();
  ctx.rect(marginLeft, marginTop, graphWidth, graphHeight);
  ctx.clip();
  
  // ã‚ºãƒ¼ãƒ ã¨ãƒ‘ãƒ³ã‚’é©ç”¨
  const centerX = marginLeft + graphWidth / 2;
  const centerY = marginTop + graphHeight / 2;
  
  ctx.translate(centerX + sensorGraphOffsetX, centerY + sensorGraphOffsetY);
  ctx.scale(sensorGraphZoomX, sensorGraphZoomY);
  ctx.translate(-centerX, -centerY);
  
  // å„ã‚»ãƒ³ã‚µã®ãƒ©ã‚¤ãƒ³ã‚’æç”»
  selectedSensors.forEach(sensor => {
    const idx = sensorIndices[sensor];
    if (idx === undefined) return;
    
    const color = sensorColors[sensor];
    ctx.strokeStyle = color;
    ctx.lineWidth = 2 / Math.sqrt(sensorGraphZoomX * sensorGraphZoomY);
    ctx.beginPath();
    
    dataSource.forEach((row, i) => {
      const value = parseFloat(row[idx]);
      if (isNaN(value)) return;
      
      const x = marginLeft + (i / (dataLength - 1)) * graphWidth;
      const y = marginTop + graphHeight - ((value - allMin) / (allMax - allMin)) * graphHeight;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    ctx.stroke();
  });
  
  // ç¾åœ¨ä½ç½®ã®ãƒãƒ¼ã‚«ãƒ¼
  if (currentTimeIndex < dataLength) {
    const x = marginLeft + (currentTimeIndex / (dataLength - 1)) * graphWidth;
    
    // ç¸¦ç·š
    ctx.strokeStyle = 'rgba(255,255,0,0.6)';
    ctx.lineWidth = 2 / Math.sqrt(sensorGraphZoomX * sensorGraphZoomY);
    ctx.setLineDash([5 / sensorGraphZoomX, 5 / sensorGraphZoomX]);
    ctx.beginPath();
    ctx.moveTo(x, marginTop);
    ctx.lineTo(x, marginTop + graphHeight);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // å„ã‚»ãƒ³ã‚µã®ç¾åœ¨ä½ç½®ã®ç‚¹
    selectedSensors.forEach(sensor => {
      const idx = sensorIndices[sensor];
      if (idx === undefined) return;
      
      const value = parseFloat(dataSource[currentTimeIndex][idx]);
      if (isNaN(value)) return;
      
      const y = marginTop + graphHeight - ((value - allMin) / (allMax - allMin)) * graphHeight;
      const color = sensorColors[sensor];
      
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, 5 / Math.sqrt(sensorGraphZoomX * sensorGraphZoomY), 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 2 / Math.sqrt(sensorGraphZoomX * sensorGraphZoomY);
      ctx.stroke();
    });
  }
  
  ctx.restore();
  
  // è¡¨ç¤ºç¯„å›²ã‚’è¨ˆç®—
  const getDataCoords = (screenX, screenY) => {
    const dx = screenX - centerX - sensorGraphOffsetX;
    const dy = screenY - centerY - sensorGraphOffsetY;
    const dataX = centerX + dx / sensorGraphZoomX;
    const dataY = centerY + dy / sensorGraphZoomY;
    return { x: dataX, y: dataY };
  };
  
  const topLeft = getDataCoords(marginLeft, marginTop);
  const bottomRight = getDataCoords(marginLeft + graphWidth, marginTop + graphHeight);
  
  const visibleDataIndexMin = Math.max(0, ((topLeft.x - marginLeft) / graphWidth) * (dataLength - 1));
  const visibleDataIndexMax = Math.min(dataLength - 1, ((bottomRight.x - marginLeft) / graphWidth) * (dataLength - 1));
  
  const visibleMin = allMax - ((bottomRight.y - marginTop) / graphHeight) * (allMax - allMin);
  const visibleMax = allMax - ((topLeft.y - marginTop) / graphHeight) * (allMax - allMin);
  
  // Yè»¸ãƒ©ãƒ™ãƒ«
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.font = 'bold 11px Arial';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 5; i++) {
    const value = visibleMin + (i / 5) * (visibleMax - visibleMin);
    const y = marginTop + graphHeight - (i / 5) * graphHeight;
    ctx.fillText(value.toFixed(0), marginLeft - 8, y + 4);
  }
  
  // Yè»¸ã‚¿ã‚¤ãƒˆãƒ«
  ctx.save();
  ctx.translate(15, marginTop + graphHeight / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.font = 'bold 12px Arial';
  ctx.fillText('ã‚»ãƒ³ã‚µå€¤ (mm)', 0, 0);
  ctx.restore();
  
  // Xè»¸ãƒ©ãƒ™ãƒ«
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.font = '10px Arial';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 5; i++) {
    const index = Math.floor(visibleDataIndexMin + (i / 5) * (visibleDataIndexMax - visibleDataIndexMin));
    const x = marginLeft + (i / 5) * graphWidth;
    ctx.fillText(index, x, height - 8);
  }
  
  // Xè»¸ã‚¿ã‚¤ãƒˆãƒ«
  ctx.fillStyle = 'rgba(255,255,255,0.8)';
  ctx.font = 'bold 11px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹', marginLeft + graphWidth / 2, height - 2);
  
  // å‡¡ä¾‹
  const legendX = marginLeft + 10;
  const legendY = marginTop + 10;
  const legendLineHeight = 18;
  
  ctx.font = '11px Arial';
  selectedSensors.forEach((sensor, i) => {
    const color = sensorColors[sensor];
    const y = legendY + i * legendLineHeight;
    
    // è‰²ã®ãƒœãƒƒã‚¯ã‚¹
    ctx.fillStyle = color;
    ctx.fillRect(legendX, y - 8, 12, 12);
    
    // ã‚»ãƒ³ã‚µå
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.textAlign = 'left';
    ctx.fillText(sensor, legendX + 18, y + 2);
  });
}
</script>
</body>
</html>
